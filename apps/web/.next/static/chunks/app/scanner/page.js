/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/scanner/page"],{

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsam%2Fprojects%2Fvericard-scan-pro%2Fapps%2Fweb%2Fsrc%2Fapp%2Fscanner%2Fpage.tsx&server=false!":
/*!****************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsam%2Fprojects%2Fvericard-scan-pro%2Fapps%2Fweb%2Fsrc%2Fapp%2Fscanner%2Fpage.tsx&server=false! ***!
  \****************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/scanner/page.tsx */ \"(app-pages-browser)/./src/app/scanner/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1mbGlnaHQtY2xpZW50LWVudHJ5LWxvYWRlci5qcz9tb2R1bGVzPSUyRlVzZXJzJTJGc2FtJTJGcHJvamVjdHMlMkZ2ZXJpY2FyZC1zY2FuLXBybyUyRmFwcHMlMkZ3ZWIlMkZzcmMlMkZhcHAlMkZzY2FubmVyJTJGcGFnZS50c3gmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2E0MTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvc2FtL3Byb2plY3RzL3ZlcmljYXJkLXNjYW4tcHJvL2FwcHMvd2ViL3NyYy9hcHAvc2Nhbm5lci9wYWdlLnRzeFwiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsam%2Fprojects%2Fvericard-scan-pro%2Fapps%2Fweb%2Fsrc%2Fapp%2Fscanner%2Fpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ createLucideIcon; },\n/* harmony export */   toKebabCase: function() { return /* binding */ toKebabCase; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/**\n * @license lucide-react v0.344.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\nconst toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase().trim();\nconst createLucideIcon = (iconName, iconNode)=>{\n    const Component = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((param, ref)=>{\n        let { color = \"currentColor\", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = \"\", children, ...rest } = param;\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n            ref,\n            ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n            width: size,\n            height: size,\n            stroke: color,\n            strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n            className: [\n                \"lucide\",\n                \"lucide-\".concat(toKebabCase(iconName)),\n                className\n            ].join(\" \"),\n            ...rest\n        }, [\n            ...iconNode.map((param)=>{\n                let [tag, attrs] = param;\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs);\n            }),\n            ...Array.isArray(children) ? children : [\n                children\n            ]\n        ]);\n    });\n    Component.displayName = \"\".concat(iconName);\n    return Component;\n};\n //# sourceMappingURL=createLucideIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMzQ0LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7OztDQUtDLEdBRWlEO0FBQ0s7QUFFdkQsTUFBTUcsY0FBYyxDQUFDQyxTQUFXQSxPQUFPQyxPQUFPLENBQUMsc0JBQXNCLFNBQVNDLFdBQVcsR0FBR0MsSUFBSTtBQUNoRyxNQUFNQyxtQkFBbUIsQ0FBQ0MsVUFBVUM7SUFDbEMsTUFBTUMsMEJBQVlYLGlEQUFVQSxDQUMxQixRQVFHWTtZQVJGLEVBQ0NDLFFBQVEsY0FBYyxFQUN0QkMsT0FBTyxFQUFFLEVBQ1RDLGNBQWMsQ0FBQyxFQUNmQyxtQkFBbUIsRUFDbkJDLFlBQVksRUFBRSxFQUNkQyxRQUFRLEVBQ1IsR0FBR0MsTUFDSjtRQUNDLHFCQUFPbEIsb0RBQWFBLENBQ2xCLE9BQ0E7WUFDRVc7WUFDQSxHQUFHViw2REFBaUI7WUFDcEJrQixPQUFPTjtZQUNQTyxRQUFRUDtZQUNSUSxRQUFRVDtZQUNSRSxhQUFhQyxzQkFBc0JPLE9BQU9SLGVBQWUsS0FBS1EsT0FBT1QsUUFBUUM7WUFDN0VFLFdBQVc7Z0JBQUM7Z0JBQVcsVUFBK0IsT0FBdEJkLFlBQVlNO2dCQUFhUTthQUFVLENBQUNPLElBQUksQ0FBQztZQUN6RSxHQUFHTCxJQUFJO1FBQ1QsR0FDQTtlQUNLVCxTQUFTZSxHQUFHLENBQUM7b0JBQUMsQ0FBQ0MsS0FBS0MsTUFBTTtxQ0FBSzFCLG9EQUFhQSxDQUFDeUIsS0FBS0M7O2VBQ2xEQyxNQUFNQyxPQUFPLENBQUNYLFlBQVlBLFdBQVc7Z0JBQUNBO2FBQVM7U0FDbkQ7SUFFTDtJQUVGUCxVQUFVbUIsV0FBVyxHQUFHLEdBQVksT0FBVHJCO0lBQzNCLE9BQU9FO0FBQ1Q7QUFFb0QsQ0FDcEQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMzQ0LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcz8xNmE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjM0NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGRlZmF1bHRBdHRyaWJ1dGVzIGZyb20gJy4vZGVmYXVsdEF0dHJpYnV0ZXMuanMnO1xuXG5jb25zdCB0b0tlYmFiQ2FzZSA9IChzdHJpbmcpID0+IHN0cmluZy5yZXBsYWNlKC8oW2EtejAtOV0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuY29uc3QgY3JlYXRlTHVjaWRlSWNvbiA9IChpY29uTmFtZSwgaWNvbk5vZGUpID0+IHtcbiAgY29uc3QgQ29tcG9uZW50ID0gZm9yd2FyZFJlZihcbiAgICAoe1xuICAgICAgY29sb3IgPSBcImN1cnJlbnRDb2xvclwiLFxuICAgICAgc2l6ZSA9IDI0LFxuICAgICAgc3Ryb2tlV2lkdGggPSAyLFxuICAgICAgYWJzb2x1dGVTdHJva2VXaWR0aCxcbiAgICAgIGNsYXNzTmFtZSA9IFwiXCIsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIC4uLnJlc3RcbiAgICB9LCByZWYpID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgICBcInN2Z1wiLFxuICAgICAgICB7XG4gICAgICAgICAgcmVmLFxuICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBhYnNvbHV0ZVN0cm9rZVdpZHRoID8gTnVtYmVyKHN0cm9rZVdpZHRoKSAqIDI0IC8gTnVtYmVyKHNpemUpIDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgY2xhc3NOYW1lOiBbXCJsdWNpZGVcIiwgYGx1Y2lkZS0ke3RvS2ViYWJDYXNlKGljb25OYW1lKX1gLCBjbGFzc05hbWVdLmpvaW4oXCIgXCIpLFxuICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIC4uLmljb25Ob2RlLm1hcCgoW3RhZywgYXR0cnNdKSA9PiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpKSxcbiAgICAgICAgICAuLi5BcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuIDogW2NoaWxkcmVuXVxuICAgICAgICBdXG4gICAgICApO1xuICAgIH1cbiAgKTtcbiAgQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gYCR7aWNvbk5hbWV9YDtcbiAgcmV0dXJuIENvbXBvbmVudDtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUx1Y2lkZUljb24gYXMgZGVmYXVsdCwgdG9LZWJhYkNhc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUx1Y2lkZUljb24uanMubWFwXG4iXSwibmFtZXMiOlsiZm9yd2FyZFJlZiIsImNyZWF0ZUVsZW1lbnQiLCJkZWZhdWx0QXR0cmlidXRlcyIsInRvS2ViYWJDYXNlIiwic3RyaW5nIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwidHJpbSIsImNyZWF0ZUx1Y2lkZUljb24iLCJpY29uTmFtZSIsImljb25Ob2RlIiwiQ29tcG9uZW50IiwicmVmIiwiY29sb3IiLCJzaXplIiwic3Ryb2tlV2lkdGgiLCJhYnNvbHV0ZVN0cm9rZVdpZHRoIiwiY2xhc3NOYW1lIiwiY2hpbGRyZW4iLCJyZXN0Iiwid2lkdGgiLCJoZWlnaHQiLCJzdHJva2UiLCJOdW1iZXIiLCJqb2luIiwibWFwIiwidGFnIiwiYXR0cnMiLCJBcnJheSIsImlzQXJyYXkiLCJkaXNwbGF5TmFtZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!**************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \**************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ defaultAttributes; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.344.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ var defaultAttributes = {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 24,\n    height: 24,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    strokeWidth: 2,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n};\n //# sourceMappingURL=defaultAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMzQ0LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7OztDQUtDLEdBRUQsSUFBSUEsb0JBQW9CO0lBQ3RCQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxhQUFhO0lBQ2JDLGVBQWU7SUFDZkMsZ0JBQWdCO0FBQ2xCO0FBRXdDLENBQ3hDLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2x1Y2lkZS1yZWFjdEAwLjM0NC4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2RlZmF1bHRBdHRyaWJ1dGVzLmpzP2Y5ODEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuMzQ0LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBkZWZhdWx0QXR0cmlidXRlcyA9IHtcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG59O1xuXG5leHBvcnQgeyBkZWZhdWx0QXR0cmlidXRlcyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0QXR0cmlidXRlcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZWZhdWx0QXR0cmlidXRlcyIsInhtbG5zIiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3Qm94IiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/camera.js":
/*!*********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/camera.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Camera; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.344.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Camera = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Camera\", [\n    [\n        \"path\",\n        {\n            d: \"M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z\",\n            key: \"1tc9qg\"\n        }\n    ],\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"13\",\n            r: \"3\",\n            key: \"1vg3eu\"\n        }\n    ]\n]);\n //# sourceMappingURL=camera.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMzQ0LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2FtZXJhLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FFcUQ7QUFFdEQsTUFBTUMsU0FBU0QsZ0VBQWdCQSxDQUFDLFVBQVU7SUFDeEM7UUFDRTtRQUNBO1lBQ0VFLEdBQUc7WUFDSEMsS0FBSztRQUNQO0tBQ0Q7SUFDRDtRQUFDO1FBQVU7WUFBRUMsSUFBSTtZQUFNQyxJQUFJO1lBQU1DLEdBQUc7WUFBS0gsS0FBSztRQUFTO0tBQUU7Q0FDMUQ7QUFFNEIsQ0FDN0Isa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMzQ0LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2FtZXJhLmpzP2E4YWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuMzQ0LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBDYW1lcmEgPSBjcmVhdGVMdWNpZGVJY29uKFwiQ2FtZXJhXCIsIFtcbiAgW1xuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGQ6IFwiTTE0LjUgNGgtNUw3IDdINGEyIDIgMCAwIDAtMiAydjlhMiAyIDAgMCAwIDIgMmgxNmEyIDIgMCAwIDAgMi0yVjlhMiAyIDAgMCAwLTItMmgtM2wtMi41LTN6XCIsXG4gICAgICBrZXk6IFwiMXRjOXFnXCJcbiAgICB9XG4gIF0sXG4gIFtcImNpcmNsZVwiLCB7IGN4OiBcIjEyXCIsIGN5OiBcIjEzXCIsIHI6IFwiM1wiLCBrZXk6IFwiMXZnM2V1XCIgfV1cbl0pO1xuXG5leHBvcnQgeyBDYW1lcmEgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FtZXJhLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNyZWF0ZUx1Y2lkZUljb24iLCJDYW1lcmEiLCJkIiwia2V5IiwiY3giLCJjeSIsInIiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/camera.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/check.js":
/*!********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/check.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Check; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.344.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Check = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Check\", [\n    [\n        \"path\",\n        {\n            d: \"M20 6 9 17l-5-5\",\n            key: \"1gmf2c\"\n        }\n    ]\n]);\n //# sourceMappingURL=check.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMzQ0LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2hlY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVxRDtBQUV0RCxNQUFNQyxRQUFRRCxnRUFBZ0JBLENBQUMsU0FBUztJQUFDO1FBQUM7UUFBUTtZQUFFRSxHQUFHO1lBQW1CQyxLQUFLO1FBQVM7S0FBRTtDQUFDO0FBRS9ELENBQzVCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2x1Y2lkZS1yZWFjdEAwLjM0NC4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2NoZWNrLmpzPzFmODAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuMzQ0LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBDaGVjayA9IGNyZWF0ZUx1Y2lkZUljb24oXCJDaGVja1wiLCBbW1wicGF0aFwiLCB7IGQ6IFwiTTIwIDYgOSAxN2wtNS01XCIsIGtleTogXCIxZ21mMmNcIiB9XV0pO1xuXG5leHBvcnQgeyBDaGVjayBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVjay5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVMdWNpZGVJY29uIiwiQ2hlY2siLCJkIiwia2V5IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/check.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/loader-2.js":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/loader-2.js ***!
  \***********************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Loader2; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.344.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Loader2 = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Loader2\", [\n    [\n        \"path\",\n        {\n            d: \"M21 12a9 9 0 1 1-6.219-8.56\",\n            key: \"13zald\"\n        }\n    ]\n]);\n //# sourceMappingURL=loader-2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMzQ0LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbG9hZGVyLTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVxRDtBQUV0RCxNQUFNQyxVQUFVRCxnRUFBZ0JBLENBQUMsV0FBVztJQUMxQztRQUFDO1FBQVE7WUFBRUUsR0FBRztZQUErQkMsS0FBSztRQUFTO0tBQUU7Q0FDOUQ7QUFFNkIsQ0FDOUIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMzQ0LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbG9hZGVyLTIuanM/MDUxOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC4zNDQuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IExvYWRlcjIgPSBjcmVhdGVMdWNpZGVJY29uKFwiTG9hZGVyMlwiLCBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0yMSAxMmE5IDkgMCAxIDEtNi4yMTktOC41NlwiLCBrZXk6IFwiMTN6YWxkXCIgfV1cbl0pO1xuXG5leHBvcnQgeyBMb2FkZXIyIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRlci0yLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNyZWF0ZUx1Y2lkZUljb24iLCJMb2FkZXIyIiwiZCIsImtleSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/loader-2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/rotate-cw.js":
/*!************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/rotate-cw.js ***!
  \************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ RotateCw; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.344.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst RotateCw = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"RotateCw\", [\n    [\n        \"path\",\n        {\n            d: \"M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8\",\n            key: \"1p45f6\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M21 3v5h-5\",\n            key: \"1q7to0\"\n        }\n    ]\n]);\n //# sourceMappingURL=rotate-cw.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMzQ0LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvcm90YXRlLWN3LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FFcUQ7QUFFdEQsTUFBTUMsV0FBV0QsZ0VBQWdCQSxDQUFDLFlBQVk7SUFDNUM7UUFBQztRQUFRO1lBQUVFLEdBQUc7WUFBcURDLEtBQUs7UUFBUztLQUFFO0lBQ25GO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQWNDLEtBQUs7UUFBUztLQUFFO0NBQzdDO0FBRThCLENBQy9CLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2x1Y2lkZS1yZWFjdEAwLjM0NC4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL3JvdGF0ZS1jdy5qcz85MjVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjM0NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgUm90YXRlQ3cgPSBjcmVhdGVMdWNpZGVJY29uKFwiUm90YXRlQ3dcIiwgW1xuICBbXCJwYXRoXCIsIHsgZDogXCJNMjEgMTJhOSA5IDAgMSAxLTktOWMyLjUyIDAgNC45MyAxIDYuNzQgMi43NEwyMSA4XCIsIGtleTogXCIxcDQ1ZjZcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTIxIDN2NWgtNVwiLCBrZXk6IFwiMXE3dG8wXCIgfV1cbl0pO1xuXG5leHBvcnQgeyBSb3RhdGVDdyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3RhdGUtY3cuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlTHVjaWRlSWNvbiIsIlJvdGF0ZUN3IiwiZCIsImtleSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/rotate-cw.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/x.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/x.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ X; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.344.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst X = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"X\", [\n    [\n        \"path\",\n        {\n            d: \"M18 6 6 18\",\n            key: \"1bl5f8\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m6 6 12 12\",\n            key: \"d8bk6v\"\n        }\n    ]\n]);\n //# sourceMappingURL=x.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMzQ0LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMveC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7OztDQUtDLEdBRXFEO0FBRXRELE1BQU1DLElBQUlELGdFQUFnQkEsQ0FBQyxLQUFLO0lBQzlCO1FBQUM7UUFBUTtZQUFFRSxHQUFHO1lBQWNDLEtBQUs7UUFBUztLQUFFO0lBQzVDO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQWNDLEtBQUs7UUFBUztLQUFFO0NBQzdDO0FBRXVCLENBQ3hCLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2x1Y2lkZS1yZWFjdEAwLjM0NC4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL3guanM/MDEyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC4zNDQuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IFggPSBjcmVhdGVMdWNpZGVJY29uKFwiWFwiLCBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xOCA2IDYgMThcIiwga2V5OiBcIjFibDVmOFwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJtNiA2IDEyIDEyXCIsIGtleTogXCJkOGJrNnZcIiB9XVxuXSk7XG5cbmV4cG9ydCB7IFggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVMdWNpZGVJY29uIiwiWCIsImQiLCJrZXkiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/x.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/api/link.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/api/link.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _client_link__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/link */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/link.js\");\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_link__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_link__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_link__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n //# sourceMappingURL=link.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9hcGkvbGluay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBeUM7QUFDVixDQUUvQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjEuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9saW5rLmpzPzZmNDUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCIuLi9jbGllbnQvbGlua1wiO1xuZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9saW5rXCI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmsuanMubWFwIl0sIm5hbWVzIjpbImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/api/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDO1FBQ0g7UUFFQSxJQUFJQyxRQUFRQyxtQkFBT0EsQ0FBQyx1S0FBMEI7UUFFOUMsWUFBWTtRQUNaLHdDQUF3QztRQUN4QyxrRkFBa0Y7UUFDbEYsc0RBQXNEO1FBQ3RELElBQUlDLHFCQUFxQkMsT0FBT0MsR0FBRyxDQUFDO1FBQ3BDLElBQUlDLG9CQUFvQkYsT0FBT0MsR0FBRyxDQUFDO1FBQ25DLElBQUlFLHNCQUFzQkgsT0FBT0MsR0FBRyxDQUFDO1FBQ3JDLElBQUlHLHlCQUF5QkosT0FBT0MsR0FBRyxDQUFDO1FBQ3hDLElBQUlJLHNCQUFzQkwsT0FBT0MsR0FBRyxDQUFDO1FBQ3JDLElBQUlLLHNCQUFzQk4sT0FBT0MsR0FBRyxDQUFDO1FBQ3JDLElBQUlNLHFCQUFxQlAsT0FBT0MsR0FBRyxDQUFDO1FBQ3BDLElBQUlPLHlCQUF5QlIsT0FBT0MsR0FBRyxDQUFDO1FBQ3hDLElBQUlRLHNCQUFzQlQsT0FBT0MsR0FBRyxDQUFDO1FBQ3JDLElBQUlTLDJCQUEyQlYsT0FBT0MsR0FBRyxDQUFDO1FBQzFDLElBQUlVLGtCQUFrQlgsT0FBT0MsR0FBRyxDQUFDO1FBQ2pDLElBQUlXLGtCQUFrQlosT0FBT0MsR0FBRyxDQUFDO1FBQ2pDLElBQUlZLHVCQUF1QmIsT0FBT0MsR0FBRyxDQUFDO1FBQ3RDLElBQUlhLG1CQUFtQmQsT0FBT0MsR0FBRyxDQUFDO1FBQ2xDLElBQUljLHdCQUF3QmYsT0FBT2dCLFFBQVE7UUFDM0MsSUFBSUMsdUJBQXVCO1FBQzNC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QkFBa0J3QixVQUFVN007d0JBQzlCO29CQUNGO2dCQUNGO2dCQUVBLElBQUl1RyxlQUFlaEgsSUFBSSxDQUFDc0QsT0FBTyxRQUFRO29CQUNyQyxJQUFJdUUsZ0JBQWdCdkcseUJBQXlCYjtvQkFDN0MsSUFBSXNNLE9BQU8zSyxPQUFPMkssSUFBSSxDQUFDekosT0FBT2lLLE1BQU0sQ0FBQyxTQUFVQyxDQUFDO3dCQUM5QyxPQUFPQSxNQUFNO29CQUNmO29CQUNBLElBQUlDLGdCQUFnQlYsS0FBS2pPLE1BQU0sR0FBRyxJQUFJLG9CQUFvQmlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7b0JBRTVGLElBQUksQ0FBQ1YscUJBQXFCLENBQUNuRixnQkFBZ0I0RixjQUFjLEVBQUU7d0JBQ3pELElBQUlFLGVBQWVaLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxNQUFNaU8sS0FBS1csSUFBSSxDQUFDLGFBQWEsV0FBVzt3QkFFN0VoUCxNQUFNLHVFQUF1RSx3QkFBd0IsMEJBQTBCLHNFQUFzRSx3QkFBd0IscUNBQXFDK08sZUFBZTVGLGVBQWU4RixjQUFjOUY7d0JBRTlTbUYscUJBQXFCLENBQUNuRixnQkFBZ0I0RixjQUFjLEdBQUc7b0JBQ3pEO2dCQUNGO2dCQUVBLElBQUloTixTQUFTbkQscUJBQXFCO29CQUNoQ3VQLHNCQUFzQnpGO2dCQUN4QixPQUFPO29CQUNMbUYsa0JBQWtCbkY7Z0JBQ3BCO2dCQUVBLE9BQU9BO1lBQ1Q7UUFDRixFQUFFLCtEQUErRDtRQUVqRSxJQUFJd0csU0FBU1g7UUFFYlksZ0JBQWdCLEdBQUd2UTtRQUNuQnVRLGNBQWMsR0FBR0Q7SUFDZjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzQ2N2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlO1xuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpOyAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEpIHtcbiAgICAgIC8vIFRPRE86IENyZWF0ZSBhIGNvbnZlbnRpb24gZm9yIG5hbWluZyBjbGllbnQgcmVmZXJlbmNlcyB3aXRoIGRlYnVnIGluZm8uXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgfVxuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuLyoqXG4gKiBMZXZlcmFnZXMgbmF0aXZlIGJyb3dzZXIvVk0gc3RhY2sgZnJhbWVzIHRvIGdldCBwcm9wZXIgZGV0YWlscyAoZS5nLlxuICogZmlsZW5hbWUsIGxpbmUgKyBjb2wgbnVtYmVyKSBmb3IgYSBzaW5nbGUgY29tcG9uZW50IGluIGEgY29tcG9uZW50IHN0YWNrLiBXZVxuICogZG8gdGhpcyBieTpcbiAqICAgKDEpIHRocm93aW5nIGFuZCBjYXRjaGluZyBhbiBlcnJvciBpbiB0aGUgZnVuY3Rpb24gLSB0aGlzIHdpbGwgYmUgb3VyXG4gKiAgICAgICBjb250cm9sIGVycm9yLlxuICogICAoMikgY2FsbGluZyB0aGUgY29tcG9uZW50IHdoaWNoIHdpbGwgZXZlbnR1YWxseSB0aHJvdyBhbiBlcnJvciB0aGF0IHdlJ2xsXG4gKiAgICAgICBjYXRjaCAtIHRoaXMgd2lsbCBiZSBvdXIgc2FtcGxlIGVycm9yLlxuICogICAoMykgZGlmZmluZyB0aGUgY29udHJvbCBhbmQgc2FtcGxlIGVycm9yIHN0YWNrcyB0byBmaW5kIHRoZSBzdGFjayBmcmFtZVxuICogICAgICAgd2hpY2ggcmVwcmVzZW50cyBvdXIgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuICAvKipcbiAgICogRmluZGluZyBhIGNvbW1vbiBzdGFjayBmcmFtZSBiZXR3ZWVuIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgY2FuIGJlXG4gICAqIHRyaWNreSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzIGFuZCBsZXZlbHMgb2Ygc3RhY2sgdHJhY2UgdHJ1bmNhdGlvbiBmcm9tXG4gICAqIGRpZmZlcmVudCBKUyBWTXMuIFNvIGluc3RlYWQgd2UnbGwgYXR0ZW1wdCB0byBjb250cm9sIHdoYXQgdGhhdCBjb21tb25cbiAgICogZnJhbWUgc2hvdWxkIGJlIHRocm91Z2ggdGhpcyBvYmplY3QgbWV0aG9kOlxuICAgKiBIYXZpbmcgYm90aCB0aGUgc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBiZSBpbiB0aGUgZnVuY3Rpb24gdW5kZXIgdGhlXG4gICAqIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgcHJvcGVydHksICsgc2V0dGluZyB0aGUgYG5hbWVgIGFuZFxuICAgKiBgZGlzcGxheU5hbWVgIHByb3BlcnRpZXMgb2YgdGhlIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBhIHN0YWNrXG4gICAqIGZyYW1lIGV4aXN0cyB0aGF0IGhhcyB0aGUgbWV0aG9kIG5hbWUgYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBpblxuICAgKiBpdCBmb3IgYm90aCBjb250cm9sIGFuZCBzYW1wbGUgc3RhY2tzLlxuICAgKi9cblxuXG4gIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250cm9sO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSBmbigpOyAvLyBJZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHJldHVybnMgYSBwcm9taXNlLCBpdCdzIGxpa2VseSBhbiBhc3luY1xuICAgICAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBjb21wb25lbnQgc3RhY2tzIGZvciBhc3luYyBjbGllbnQgY29tcG9uZW50cz9cblxuICAgICAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICB9XG4gIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnO1xuICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsICduYW1lJyk7IC8vIEJlZm9yZSBFUzYsIHRoZSBgbmFtZWAgcHJvcGVydHkgd2FzIG5vdCBjb25maWd1cmFibGUuXG5cbiAgaWYgKG5hbWVQcm9wRGVzY3JpcHRvciAmJiBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgLy8gVjggdXRpbGl6ZXMgYSBmdW5jdGlvbidzIGBuYW1lYCBwcm9wZXJ0eSB3aGVuIGdlbmVyYXRpbmcgYSBzdGFjayB0cmFjZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAvLyBDb25maWd1cmFibGUgcHJvcGVydGllcyBjYW4gYmUgdXBkYXRlZCBldmVuIGlmIGl0cyB3cml0YWJsZSBkZXNjcmlwdG9yXG4gICAgLy8gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG4gICAgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCdcbiAgICB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuXG4gICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IDA7XG4gICAgICB2YXIgYyA9IDA7XG5cbiAgICAgIHdoaWxlIChzIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmICFzYW1wbGVMaW5lc1tzXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgcysrO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoYyA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiYgIWNvbnRyb2xMaW5lc1tjXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgYysrO1xuICAgICAgfSAvLyBXZSBjb3VsZG4ndCBmaW5kIG91ciBpbnRlbnRpb25hbGx5IGluamVjdGVkIGNvbW1vbiByb290IGZyYW1lLCBhdHRlbXB0XG4gICAgICAvLyB0byBmaW5kIGFub3RoZXIgY29tbW9uIHJvb3QgZnJhbWUgYnkgc2VhcmNoIGZyb20gdGhlIGJvdHRvbSBvZiB0aGVcbiAgICAgIC8vIGNvbnRyb2wgc3RhY2suLi5cblxuXG4gICAgICBpZiAocyA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8IGMgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICAgIGMtLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG5mdW5jdGlvbiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWJDEodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkgOyBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWJDEodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2tleScpKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViA9IGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeERFViA9IGpzeERFVjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiUmVhY3QiLCJyZXF1aXJlIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX0NBQ0hFX1RZUEUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsImVycm9yIiwiZm9ybWF0IiwiX2xlbjIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5MiIsInByaW50V2FybmluZyIsImxldmVsIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsInN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsImNvbmNhdCIsImFyZ3NXaXRoRm9ybWF0IiwibWFwIiwiaXRlbSIsIlN0cmluZyIsInVuc2hpZnQiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImFwcGx5IiwiY2FsbCIsImNvbnNvbGUiLCJlbmFibGVTY29wZUFQSSIsImVuYWJsZUNhY2hlRWxlbWVudCIsImVuYWJsZVRyYW5zaXRpb25UcmFjaW5nIiwiZW5hYmxlTGVnYWN5SGlkZGVuIiwiZW5hYmxlRGVidWdUcmFjaW5nIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwidHlwZSIsIiQkdHlwZW9mIiwiZ2V0TW9kdWxlSWQiLCJ1bmRlZmluZWQiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJ0YWciLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJ4IiwiYXNzaWduIiwiT2JqZWN0IiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImxvZyIsImluZm8iLCJ3YXJuIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwicHJvcHMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwidmFsdWUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJyZWVuYWJsZUxvZ3MiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyIiwicHJlZml4IiwiZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUiLCJzb3VyY2UiLCJvd25lckZuIiwiRXJyb3IiLCJtYXRjaCIsInRyaW0iLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsImdldCIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsImN1cnJlbnQiLCJSdW5JblJvb3RGcmFtZSIsIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCIsImNvbnRyb2wiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJzZXQiLCJSZWZsZWN0IiwibWF5YmVQcm9taXNlIiwiY2F0Y2giLCJzYW1wbGUiLCJuYW1lUHJvcERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfUnVuSW5Sb290RnJhbWUkRGV0ZXIiLCJzYW1wbGVTdGFjayIsImNvbnRyb2xTdGFjayIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJzIiwiYyIsImluY2x1ZGVzIiwiX2ZyYW1lIiwicmVwbGFjZSIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwic2hvdWxkQ29uc3RydWN0IiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImhhc093blByb3BlcnR5IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMSIsImVsZW1lbnQiLCJvd25lciIsIl9vd25lciIsIl9zb3VyY2UiLCJzZXRFeHRyYVN0YWNrRnJhbWUiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImxvY2F0aW9uIiwiY29tcG9uZW50TmFtZSIsImhhcyIsImJpbmQiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJtZXNzYWdlIiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiYSIsInR5cGVOYW1lIiwiaGFzVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImNvbnN0cnVjdG9yIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJlIiwiY2hlY2tLZXlTdHJpbmdDb2VyY2lvbiIsIlJlYWN0Q3VycmVudE93bmVyJDEiLCJSZWFjdEN1cnJlbnRPd25lciIsIlJFU0VSVkVEX1BST1BTIiwia2V5IiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiZGlkV2FybkFib3V0U3RyaW5nUmVmcyIsImhhc1ZhbGlkUmVmIiwiY29uZmlnIiwiZ2V0dGVyIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsIndhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZCIsInNlbGYiLCJzdGF0ZU5vZGUiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwiUmVhY3RFbGVtZW50IiwiX3N0b3JlIiwiZnJlZXplIiwianN4REVWJDEiLCJtYXliZUtleSIsInByb3BOYW1lIiwiZGVmYXVsdFByb3BzIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwicHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24iLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudFR5cGUiLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsInZhbGlkYXRlZCIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyIiwidmFsaWRhdGVDaGlsZEtleXMiLCJub2RlIiwiaSIsImNoaWxkIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJzdGVwIiwibmV4dCIsImRvbmUiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIl9uYW1lIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsImtleXMiLCJkaWRXYXJuQWJvdXRLZXlTcHJlYWQiLCJqc3hXaXRoVmFsaWRhdGlvbiIsImlzU3RhdGljQ2hpbGRyZW4iLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwidHlwZVN0cmluZyIsImNoaWxkcmVuIiwiZmlsdGVyIiwiayIsImJlZm9yZUV4YW1wbGUiLCJqb2luIiwiYWZ0ZXJFeGFtcGxlIiwianN4REVWIiwiZXhwb3J0cyIsIkZyYWdtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \***********************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMsK1BBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/M2U0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/react-webcam@7.2.0_react-dom@18.3.1_react@18.2.0/node_modules/react-webcam/dist/react-webcam.js":
/*!********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-webcam@7.2.0_react-dom@18.3.1_react@18.2.0/node_modules/react-webcam/dist/react-webcam.js ***!
  \********************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/index.js\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE_react__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_668__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_668__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_668__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_668__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_668__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_668__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_668__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_668__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_668__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_668__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_668__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_668__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_668__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_668__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_668__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_668__(__nested_webpack_require_668__.s = \"./src/react-webcam.tsx\");\n    /******/ }({\n        /***/ \"./src/react-webcam.tsx\": /*!******************************!*\\\n  !*** ./src/react-webcam.tsx ***!\n  \\******************************/ /*! exports provided: default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_5080__) {\n            \"use strict\";\n            __nested_webpack_require_5080__.r(__nested_webpack_exports__);\n            /* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_5080__(/*! react */ \"react\");\n            /* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_5080__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n            var __extends =  false || function() {\n                var extendStatics = function(d, b) {\n                    extendStatics = Object.setPrototypeOf || ({\n                        __proto__: []\n                    }) instanceof Array && function(d, b) {\n                        d.__proto__ = b;\n                    } || function(d, b) {\n                        for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                    };\n                    return extendStatics(d, b);\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            var __assign =  false || function() {\n                __assign = Object.assign || function(t) {\n                    for(var s, i = 1, n = arguments.length; i < n; i++){\n                        s = arguments[i];\n                        for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n                    }\n                    return t;\n                };\n                return __assign.apply(this, arguments);\n            };\n            var __rest =  false || function(s, e) {\n                var t = {};\n                for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n                if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n                    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n                }\n                return t;\n            };\n            // polyfill based on https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n            (function polyfillGetUserMedia() {\n                if (false) {}\n                // Older browsers might not implement mediaDevices at all, so we set an empty object first\n                if (navigator.mediaDevices === undefined) {\n                    navigator.mediaDevices = {};\n                }\n                // Some browsers partially implement mediaDevices. We can't just assign an object\n                // with getUserMedia as it would overwrite existing properties.\n                // Here, we will just add the getUserMedia property if it's missing.\n                if (navigator.mediaDevices.getUserMedia === undefined) {\n                    navigator.mediaDevices.getUserMedia = function(constraints) {\n                        // First get ahold of the legacy getUserMedia, if present\n                        var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n                        // Some browsers just don't implement it - return a rejected promise with an error\n                        // to keep a consistent interface\n                        if (!getUserMedia) {\n                            return Promise.reject(new Error(\"getUserMedia is not implemented in this browser\"));\n                        }\n                        // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\n                        return new Promise(function(resolve, reject) {\n                            getUserMedia.call(navigator, constraints, resolve, reject);\n                        });\n                    };\n                }\n            })();\n            function hasGetUserMedia() {\n                return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);\n            }\n            var Webcam = /** @class */ function(_super) {\n                __extends(Webcam, _super);\n                function Webcam(props) {\n                    var _this = _super.call(this, props) || this;\n                    _this.canvas = null;\n                    _this.ctx = null;\n                    _this.requestUserMediaId = 0;\n                    _this.unmounted = false;\n                    _this.state = {\n                        hasUserMedia: false\n                    };\n                    return _this;\n                }\n                Webcam.prototype.componentDidMount = function() {\n                    var _a = this, state = _a.state, props = _a.props;\n                    this.unmounted = false;\n                    if (!hasGetUserMedia()) {\n                        props.onUserMediaError(\"getUserMedia not supported\");\n                        return;\n                    }\n                    if (!state.hasUserMedia) {\n                        this.requestUserMedia();\n                    }\n                    if (props.children && typeof props.children != \"function\") {\n                        console.warn(\"children must be a function\");\n                    }\n                };\n                Webcam.prototype.componentDidUpdate = function(nextProps) {\n                    var props = this.props;\n                    if (!hasGetUserMedia()) {\n                        props.onUserMediaError(\"getUserMedia not supported\");\n                        return;\n                    }\n                    var audioConstraintsChanged = JSON.stringify(nextProps.audioConstraints) !== JSON.stringify(props.audioConstraints);\n                    var videoConstraintsChanged = JSON.stringify(nextProps.videoConstraints) !== JSON.stringify(props.videoConstraints);\n                    var minScreenshotWidthChanged = nextProps.minScreenshotWidth !== props.minScreenshotWidth;\n                    var minScreenshotHeightChanged = nextProps.minScreenshotHeight !== props.minScreenshotHeight;\n                    if (videoConstraintsChanged || minScreenshotWidthChanged || minScreenshotHeightChanged) {\n                        this.canvas = null;\n                        this.ctx = null;\n                    }\n                    if (audioConstraintsChanged || videoConstraintsChanged) {\n                        this.stopAndCleanup();\n                        this.requestUserMedia();\n                    }\n                };\n                Webcam.prototype.componentWillUnmount = function() {\n                    this.unmounted = true;\n                    this.stopAndCleanup();\n                };\n                Webcam.stopMediaStream = function(stream) {\n                    if (stream) {\n                        if (stream.getVideoTracks && stream.getAudioTracks) {\n                            stream.getVideoTracks().map(function(track) {\n                                stream.removeTrack(track);\n                                track.stop();\n                            });\n                            stream.getAudioTracks().map(function(track) {\n                                stream.removeTrack(track);\n                                track.stop();\n                            });\n                        } else {\n                            stream.stop();\n                        }\n                    }\n                };\n                Webcam.prototype.stopAndCleanup = function() {\n                    var state = this.state;\n                    if (state.hasUserMedia) {\n                        Webcam.stopMediaStream(this.stream);\n                        if (state.src) {\n                            window.URL.revokeObjectURL(state.src);\n                        }\n                    }\n                };\n                Webcam.prototype.getScreenshot = function(screenshotDimensions) {\n                    var _a = this, state = _a.state, props = _a.props;\n                    if (!state.hasUserMedia) return null;\n                    var canvas = this.getCanvas(screenshotDimensions);\n                    return canvas && canvas.toDataURL(props.screenshotFormat, props.screenshotQuality);\n                };\n                Webcam.prototype.getCanvas = function(screenshotDimensions) {\n                    var _a = this, state = _a.state, props = _a.props;\n                    if (!this.video) {\n                        return null;\n                    }\n                    if (!state.hasUserMedia || !this.video.videoHeight) return null;\n                    if (!this.ctx) {\n                        var canvasWidth = this.video.videoWidth;\n                        var canvasHeight = this.video.videoHeight;\n                        if (!this.props.forceScreenshotSourceSize) {\n                            var aspectRatio = canvasWidth / canvasHeight;\n                            canvasWidth = props.minScreenshotWidth || this.video.clientWidth;\n                            canvasHeight = canvasWidth / aspectRatio;\n                            if (props.minScreenshotHeight && canvasHeight < props.minScreenshotHeight) {\n                                canvasHeight = props.minScreenshotHeight;\n                                canvasWidth = canvasHeight * aspectRatio;\n                            }\n                        }\n                        this.canvas = document.createElement(\"canvas\");\n                        this.canvas.width = (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.width) || canvasWidth;\n                        this.canvas.height = (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.height) || canvasHeight;\n                        this.ctx = this.canvas.getContext(\"2d\");\n                    }\n                    var _b = this, ctx = _b.ctx, canvas = _b.canvas;\n                    if (ctx && canvas) {\n                        // adjust the height and width of the canvas to the given dimensions\n                        canvas.width = (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.width) || canvas.width;\n                        canvas.height = (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.height) || canvas.height;\n                        // mirror the screenshot\n                        if (props.mirrored) {\n                            ctx.translate(canvas.width, 0);\n                            ctx.scale(-1, 1);\n                        }\n                        ctx.imageSmoothingEnabled = props.imageSmoothing;\n                        ctx.drawImage(this.video, 0, 0, (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.width) || canvas.width, (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.height) || canvas.height);\n                        // invert mirroring\n                        if (props.mirrored) {\n                            ctx.scale(-1, 1);\n                            ctx.translate(-canvas.width, 0);\n                        }\n                    }\n                    return canvas;\n                };\n                Webcam.prototype.requestUserMedia = function() {\n                    var _this = this;\n                    var props = this.props;\n                    var sourceSelected = function(audioConstraints, videoConstraints) {\n                        var constraints = {\n                            video: typeof videoConstraints !== \"undefined\" ? videoConstraints : true\n                        };\n                        if (props.audio) {\n                            constraints.audio = typeof audioConstraints !== \"undefined\" ? audioConstraints : true;\n                        }\n                        _this.requestUserMediaId++;\n                        var myRequestUserMediaId = _this.requestUserMediaId;\n                        navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {\n                            if (_this.unmounted || myRequestUserMediaId !== _this.requestUserMediaId) {\n                                Webcam.stopMediaStream(stream);\n                            } else {\n                                _this.handleUserMedia(null, stream);\n                            }\n                        }).catch(function(e) {\n                            _this.handleUserMedia(e);\n                        });\n                    };\n                    if (\"mediaDevices\" in navigator) {\n                        sourceSelected(props.audioConstraints, props.videoConstraints);\n                    } else {\n                        var optionalSource_1 = function(id) {\n                            return {\n                                optional: [\n                                    {\n                                        sourceId: id\n                                    }\n                                ]\n                            };\n                        };\n                        var constraintToSourceId_1 = function(constraint) {\n                            var deviceId = constraint.deviceId;\n                            if (typeof deviceId === \"string\") {\n                                return deviceId;\n                            }\n                            if (Array.isArray(deviceId) && deviceId.length > 0) {\n                                return deviceId[0];\n                            }\n                            if (typeof deviceId === \"object\" && deviceId.ideal) {\n                                return deviceId.ideal;\n                            }\n                            return null;\n                        };\n                        // @ts-ignore: deprecated api\n                        MediaStreamTrack.getSources(function(sources) {\n                            var audioSource = null;\n                            var videoSource = null;\n                            sources.forEach(function(source) {\n                                if (source.kind === \"audio\") {\n                                    audioSource = source.id;\n                                } else if (source.kind === \"video\") {\n                                    videoSource = source.id;\n                                }\n                            });\n                            var audioSourceId = constraintToSourceId_1(props.audioConstraints);\n                            if (audioSourceId) {\n                                audioSource = audioSourceId;\n                            }\n                            var videoSourceId = constraintToSourceId_1(props.videoConstraints);\n                            if (videoSourceId) {\n                                videoSource = videoSourceId;\n                            }\n                            sourceSelected(optionalSource_1(audioSource), optionalSource_1(videoSource));\n                        });\n                    }\n                };\n                Webcam.prototype.handleUserMedia = function(err, stream) {\n                    var props = this.props;\n                    if (err || !stream) {\n                        this.setState({\n                            hasUserMedia: false\n                        });\n                        props.onUserMediaError(err);\n                        return;\n                    }\n                    this.stream = stream;\n                    try {\n                        if (this.video) {\n                            this.video.srcObject = stream;\n                        }\n                        this.setState({\n                            hasUserMedia: true\n                        });\n                    } catch (error) {\n                        this.setState({\n                            hasUserMedia: true,\n                            src: window.URL.createObjectURL(stream)\n                        });\n                    }\n                    props.onUserMedia(stream);\n                };\n                Webcam.prototype.render = function() {\n                    var _this = this;\n                    var _a = this, state = _a.state, props = _a.props;\n                    var audio = props.audio, forceScreenshotSourceSize = props.forceScreenshotSourceSize, disablePictureInPicture = props.disablePictureInPicture, onUserMedia = props.onUserMedia, onUserMediaError = props.onUserMediaError, screenshotFormat = props.screenshotFormat, screenshotQuality = props.screenshotQuality, minScreenshotWidth = props.minScreenshotWidth, minScreenshotHeight = props.minScreenshotHeight, audioConstraints = props.audioConstraints, videoConstraints = props.videoConstraints, imageSmoothing = props.imageSmoothing, mirrored = props.mirrored, _b = props.style, style = _b === void 0 ? {} : _b, children = props.children, rest = __rest(props, [\n                        \"audio\",\n                        \"forceScreenshotSourceSize\",\n                        \"disablePictureInPicture\",\n                        \"onUserMedia\",\n                        \"onUserMediaError\",\n                        \"screenshotFormat\",\n                        \"screenshotQuality\",\n                        \"minScreenshotWidth\",\n                        \"minScreenshotHeight\",\n                        \"audioConstraints\",\n                        \"videoConstraints\",\n                        \"imageSmoothing\",\n                        \"mirrored\",\n                        \"style\",\n                        \"children\"\n                    ]);\n                    var videoStyle = mirrored ? __assign(__assign({}, style), {\n                        transform: (style.transform || \"\") + \" scaleX(-1)\"\n                    }) : style;\n                    var childrenProps = {\n                        getScreenshot: this.getScreenshot.bind(this)\n                    };\n                    return react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](react__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], null, react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](\"video\", __assign({\n                        autoPlay: true,\n                        disablePictureInPicture: disablePictureInPicture,\n                        src: state.src,\n                        muted: !audio,\n                        playsInline: true,\n                        ref: function(ref) {\n                            _this.video = ref;\n                        },\n                        style: videoStyle\n                    }, rest)), children && children(childrenProps));\n                };\n                Webcam.defaultProps = {\n                    audio: false,\n                    disablePictureInPicture: false,\n                    forceScreenshotSourceSize: false,\n                    imageSmoothing: true,\n                    mirrored: false,\n                    onUserMedia: function() {\n                        return undefined;\n                    },\n                    onUserMediaError: function() {\n                        return undefined;\n                    },\n                    screenshotFormat: \"image/webp\",\n                    screenshotQuality: 0.92\n                };\n                return Webcam;\n            }(react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]);\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = Webcam;\n        /***/ },\n        /***/ \"react\": /*!**************************************************************************************!*\\\n  !*** external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"} ***!\n  \\**************************************************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n        /***/ }\n    })[\"default\"];\n}); //# sourceMappingURL=react-webcam.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3Qtd2ViY2FtQDcuMi4wX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC13ZWJjYW0vZGlzdC9yZWFjdC13ZWJjYW0uanMiLCJtYXBwaW5ncyI6IjtBQUFDLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0QsUUFBUUcsbUJBQU9BLENBQUMsb0pBQU87U0FDcEMsRUFLb0M7QUFDMUMsR0FBRyxRQUFNLFNBQVNHLGlDQUFpQztJQUNuRCxPQUFnQixNQUFILEdBQUksU0FBU0MsT0FBTztRQUNqQyxNQUFNLEdBQUksbUJBQW1CO1FBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtRQUNqQyxNQUFNLEdBQUksU0FBU0MsOEJBQW1CQSxDQUFDQyxRQUFRO1lBQy9DLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBSyxJQUFHRixnQkFBZ0IsQ0FBQ0UsU0FBUyxFQUFFO2dCQUMxQyxNQUFNLEdBQU0sT0FBT0YsZ0JBQWdCLENBQUNFLFNBQVMsQ0FBQ1QsT0FBTztZQUNyRCxNQUFNLEdBQUs7WUFDWCxNQUFNLEdBQUssa0RBQWtEO1lBQzdELE1BQU0sR0FBSyxJQUFJQyxVQUFTTSxnQkFBZ0IsQ0FBQ0UsU0FBUyxHQUFHO2dCQUNyRCxNQUFNLEdBQU1DLEdBQUdEO2dCQUNmLE1BQU0sR0FBTUUsR0FBRztnQkFDZixNQUFNLEdBQU1YLFNBQVMsQ0FBQztZQUNYO1lBQ1gsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLTSxPQUFPLENBQUNHLFNBQVMsQ0FBQ0csSUFBSSxDQUFDWCxRQUFPRCxPQUFPLEVBQUVDLFNBQVFBLFFBQU9ELE9BQU8sRUFBRVEs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LFVBQVUsR0FBSW1DO1FBRy9ELEdBQUcsR0FBRztRQUVOLEdBQUcsR0FBRyxTQUNOOzt3RkFFd0YsR0FDeEYsNEJBQTRCLEdBQzVCLEdBQUcsR0FBSSxTQUFTN0UsT0FBTSxFQUFFRCxRQUFPO1lBRS9CQyxRQUFPRCxPQUFPLEdBQUdLO1FBRWpCLEdBQUcsR0FBRztJQUVHLEVBQUUsQ0FBQyxVQUFVO0FBQ3RCLElBQ0Esd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3Qtd2ViY2FtQDcuMi4wX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC13ZWJjYW0vZGlzdC9yZWFjdC13ZWJjYW0uanM/OGQwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJyZWFjdFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJXZWJjYW1cIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiV2ViY2FtXCJdID0gZmFjdG9yeShyb290W1wiUmVhY3RcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL3JlYWN0LXdlYmNhbS50c3hcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi9zcmMvcmVhY3Qtd2ViY2FtLnRzeFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlYWN0LXdlYmNhbS50c3ggKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWFjdCAqLyBcInJlYWN0XCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG52YXIgX19leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3Jlc3QgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5cbi8vIHBvbHlmaWxsIGJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYURldmljZXMvZ2V0VXNlck1lZGlhXG4oZnVuY3Rpb24gcG9seWZpbGxHZXRVc2VyTWVkaWEoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gT2xkZXIgYnJvd3NlcnMgbWlnaHQgbm90IGltcGxlbWVudCBtZWRpYURldmljZXMgYXQgYWxsLCBzbyB3ZSBzZXQgYW4gZW1wdHkgb2JqZWN0IGZpcnN0XG4gICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzID0ge307XG4gICAgfVxuICAgIC8vIFNvbWUgYnJvd3NlcnMgcGFydGlhbGx5IGltcGxlbWVudCBtZWRpYURldmljZXMuIFdlIGNhbid0IGp1c3QgYXNzaWduIGFuIG9iamVjdFxuICAgIC8vIHdpdGggZ2V0VXNlck1lZGlhIGFzIGl0IHdvdWxkIG92ZXJ3cml0ZSBleGlzdGluZyBwcm9wZXJ0aWVzLlxuICAgIC8vIEhlcmUsIHdlIHdpbGwganVzdCBhZGQgdGhlIGdldFVzZXJNZWRpYSBwcm9wZXJ0eSBpZiBpdCdzIG1pc3NpbmcuXG4gICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoY29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGdldCBhaG9sZCBvZiB0aGUgbGVnYWN5IGdldFVzZXJNZWRpYSwgaWYgcHJlc2VudFxuICAgICAgICAgICAgdmFyIGdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSB8fFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYTtcbiAgICAgICAgICAgIC8vIFNvbWUgYnJvd3NlcnMganVzdCBkb24ndCBpbXBsZW1lbnQgaXQgLSByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIHdpdGggYW4gZXJyb3JcbiAgICAgICAgICAgIC8vIHRvIGtlZXAgYSBjb25zaXN0ZW50IGludGVyZmFjZVxuICAgICAgICAgICAgaWYgKCFnZXRVc2VyTWVkaWEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiZ2V0VXNlck1lZGlhIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIGJyb3dzZXJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3cmFwIHRoZSBjYWxsIHRvIHRoZSBvbGQgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSB3aXRoIGEgUHJvbWlzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBnZXRVc2VyTWVkaWEuY2FsbChuYXZpZ2F0b3IsIGNvbnN0cmFpbnRzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcbmZ1bmN0aW9uIGhhc0dldFVzZXJNZWRpYSgpIHtcbiAgICByZXR1cm4gISEobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSk7XG59XG52YXIgV2ViY2FtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXZWJjYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2ViY2FtKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgICBfdGhpcy5jdHggPSBudWxsO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0VXNlck1lZGlhSWQgPSAwO1xuICAgICAgICBfdGhpcy51bm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBoYXNVc2VyTWVkaWE6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV2ViY2FtLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgc3RhdGUgPSBfYS5zdGF0ZSwgcHJvcHMgPSBfYS5wcm9wcztcbiAgICAgICAgdGhpcy51bm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFoYXNHZXRVc2VyTWVkaWEoKSkge1xuICAgICAgICAgICAgcHJvcHMub25Vc2VyTWVkaWFFcnJvcihcImdldFVzZXJNZWRpYSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGUuaGFzVXNlck1lZGlhKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RVc2VyTWVkaWEoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuY2hpbGRyZW4gJiYgdHlwZW9mIHByb3BzLmNoaWxkcmVuICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImNoaWxkcmVuIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2ViY2FtLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmICghaGFzR2V0VXNlck1lZGlhKCkpIHtcbiAgICAgICAgICAgIHByb3BzLm9uVXNlck1lZGlhRXJyb3IoXCJnZXRVc2VyTWVkaWEgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXVkaW9Db25zdHJhaW50c0NoYW5nZWQgPSBKU09OLnN0cmluZ2lmeShuZXh0UHJvcHMuYXVkaW9Db25zdHJhaW50cykgIT09XG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwcm9wcy5hdWRpb0NvbnN0cmFpbnRzKTtcbiAgICAgICAgdmFyIHZpZGVvQ29uc3RyYWludHNDaGFuZ2VkID0gSlNPTi5zdHJpbmdpZnkobmV4dFByb3BzLnZpZGVvQ29uc3RyYWludHMpICE9PVxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocHJvcHMudmlkZW9Db25zdHJhaW50cyk7XG4gICAgICAgIHZhciBtaW5TY3JlZW5zaG90V2lkdGhDaGFuZ2VkID0gbmV4dFByb3BzLm1pblNjcmVlbnNob3RXaWR0aCAhPT0gcHJvcHMubWluU2NyZWVuc2hvdFdpZHRoO1xuICAgICAgICB2YXIgbWluU2NyZWVuc2hvdEhlaWdodENoYW5nZWQgPSBuZXh0UHJvcHMubWluU2NyZWVuc2hvdEhlaWdodCAhPT0gcHJvcHMubWluU2NyZWVuc2hvdEhlaWdodDtcbiAgICAgICAgaWYgKHZpZGVvQ29uc3RyYWludHNDaGFuZ2VkIHx8XG4gICAgICAgICAgICBtaW5TY3JlZW5zaG90V2lkdGhDaGFuZ2VkIHx8XG4gICAgICAgICAgICBtaW5TY3JlZW5zaG90SGVpZ2h0Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdWRpb0NvbnN0cmFpbnRzQ2hhbmdlZCB8fCB2aWRlb0NvbnN0cmFpbnRzQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wQW5kQ2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VXNlck1lZGlhKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdlYmNhbS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdG9wQW5kQ2xlYW51cCgpO1xuICAgIH07XG4gICAgV2ViY2FtLnN0b3BNZWRpYVN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5nZXRWaWRlb1RyYWNrcyAmJiBzdHJlYW0uZ2V0QXVkaW9UcmFja3MpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5tYXAoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5tYXAoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdlYmNhbS5wcm90b3R5cGUuc3RvcEFuZENsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZS5oYXNVc2VyTWVkaWEpIHtcbiAgICAgICAgICAgIFdlYmNhbS5zdG9wTWVkaWFTdHJlYW0odGhpcy5zdHJlYW0pO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNyYykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHN0YXRlLnNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdlYmNhbS5wcm90b3R5cGUuZ2V0U2NyZWVuc2hvdCA9IGZ1bmN0aW9uIChzY3JlZW5zaG90RGltZW5zaW9ucykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBzdGF0ZSA9IF9hLnN0YXRlLCBwcm9wcyA9IF9hLnByb3BzO1xuICAgICAgICBpZiAoIXN0YXRlLmhhc1VzZXJNZWRpYSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoc2NyZWVuc2hvdERpbWVuc2lvbnMpO1xuICAgICAgICByZXR1cm4gKGNhbnZhcyAmJlxuICAgICAgICAgICAgY2FudmFzLnRvRGF0YVVSTChwcm9wcy5zY3JlZW5zaG90Rm9ybWF0LCBwcm9wcy5zY3JlZW5zaG90UXVhbGl0eSkpO1xuICAgIH07XG4gICAgV2ViY2FtLnByb3RvdHlwZS5nZXRDYW52YXMgPSBmdW5jdGlvbiAoc2NyZWVuc2hvdERpbWVuc2lvbnMpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgc3RhdGUgPSBfYS5zdGF0ZSwgcHJvcHMgPSBfYS5wcm9wcztcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXRlLmhhc1VzZXJNZWRpYSB8fCAhdGhpcy52aWRlby52aWRlb0hlaWdodClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuY3R4KSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLnZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gdGhpcy52aWRlby52aWRlb0hlaWdodDtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5mb3JjZVNjcmVlbnNob3RTb3VyY2VTaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFzcGVjdFJhdGlvID0gY2FudmFzV2lkdGggLyBjYW52YXNIZWlnaHQ7XG4gICAgICAgICAgICAgICAgY2FudmFzV2lkdGggPSBwcm9wcy5taW5TY3JlZW5zaG90V2lkdGggfHwgdGhpcy52aWRlby5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXNIZWlnaHQgPSBjYW52YXNXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5taW5TY3JlZW5zaG90SGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0hlaWdodCA8IHByb3BzLm1pblNjcmVlbnNob3RIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzSGVpZ2h0ID0gcHJvcHMubWluU2NyZWVuc2hvdEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzV2lkdGggPSBjYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IChzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gbnVsbCB8fCBzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NyZWVuc2hvdERpbWVuc2lvbnMud2lkdGgpIHx8IGNhbnZhc1dpZHRoO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gKHNjcmVlbnNob3REaW1lbnNpb25zID09PSBudWxsIHx8IHNjcmVlbnNob3REaW1lbnNpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY3JlZW5zaG90RGltZW5zaW9ucy5oZWlnaHQpIHx8IGNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYiA9IHRoaXMsIGN0eCA9IF9iLmN0eCwgY2FudmFzID0gX2IuY2FudmFzO1xuICAgICAgICBpZiAoY3R4ICYmIGNhbnZhcykge1xuICAgICAgICAgICAgLy8gYWRqdXN0IHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSBjYW52YXMgdG8gdGhlIGdpdmVuIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IChzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gbnVsbCB8fCBzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NyZWVuc2hvdERpbWVuc2lvbnMud2lkdGgpIHx8IGNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSAoc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IG51bGwgfHwgc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjcmVlbnNob3REaW1lbnNpb25zLmhlaWdodCkgfHwgY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIC8vIG1pcnJvciB0aGUgc2NyZWVuc2hvdFxuICAgICAgICAgICAgaWYgKHByb3BzLm1pcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjYW52YXMud2lkdGgsIDApO1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gcHJvcHMuaW1hZ2VTbW9vdGhpbmc7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMudmlkZW8sIDAsIDAsIChzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gbnVsbCB8fCBzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NyZWVuc2hvdERpbWVuc2lvbnMud2lkdGgpIHx8IGNhbnZhcy53aWR0aCwgKHNjcmVlbnNob3REaW1lbnNpb25zID09PSBudWxsIHx8IHNjcmVlbnNob3REaW1lbnNpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY3JlZW5zaG90RGltZW5zaW9ucy5oZWlnaHQpIHx8IGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgLy8gaW52ZXJ0IG1pcnJvcmluZ1xuICAgICAgICAgICAgaWYgKHByb3BzLm1pcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jYW52YXMud2lkdGgsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfTtcbiAgICBXZWJjYW0ucHJvdG90eXBlLnJlcXVlc3RVc2VyTWVkaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBzb3VyY2VTZWxlY3RlZCA9IGZ1bmN0aW9uIChhdWRpb0NvbnN0cmFpbnRzLCB2aWRlb0NvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICAgICAgdmlkZW86IHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzICE9PSBcInVuZGVmaW5lZFwiID8gdmlkZW9Db25zdHJhaW50cyA6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocHJvcHMuYXVkaW8pIHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5hdWRpbyA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBhdWRpb0NvbnN0cmFpbnRzICE9PSBcInVuZGVmaW5lZFwiID8gYXVkaW9Db25zdHJhaW50cyA6IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0VXNlck1lZGlhSWQrKztcbiAgICAgICAgICAgIHZhciBteVJlcXVlc3RVc2VyTWVkaWFJZCA9IF90aGlzLnJlcXVlc3RVc2VyTWVkaWFJZDtcbiAgICAgICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAgICAgICAgICAgICAgICAuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudW5tb3VudGVkIHx8IG15UmVxdWVzdFVzZXJNZWRpYUlkICE9PSBfdGhpcy5yZXF1ZXN0VXNlck1lZGlhSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgV2ViY2FtLnN0b3BNZWRpYVN0cmVhbShzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlVXNlck1lZGlhKG51bGwsIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVVc2VyTWVkaWEoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwibWVkaWFEZXZpY2VzXCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAgICAgICBzb3VyY2VTZWxlY3RlZChwcm9wcy5hdWRpb0NvbnN0cmFpbnRzLCBwcm9wcy52aWRlb0NvbnN0cmFpbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25hbFNvdXJjZV8xID0gZnVuY3Rpb24gKGlkKSB7IHJldHVybiAoeyBvcHRpb25hbDogW3sgc291cmNlSWQ6IGlkIH1dIH0pOyB9O1xuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnRUb1NvdXJjZUlkXzEgPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IGNvbnN0cmFpbnQuZGV2aWNlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXZpY2VJZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRldmljZUlkKSAmJiBkZXZpY2VJZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2VJZFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXZpY2VJZCA9PT0gXCJvYmplY3RcIiAmJiBkZXZpY2VJZC5pZGVhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlSWQuaWRlYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGRlcHJlY2F0ZWQgYXBpXG4gICAgICAgICAgICBNZWRpYVN0cmVhbVRyYWNrLmdldFNvdXJjZXMoZnVuY3Rpb24gKHNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXVkaW9Tb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciB2aWRlb1NvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5raW5kID09PSBcImF1ZGlvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvU291cmNlID0gc291cmNlLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZS5raW5kID09PSBcInZpZGVvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvU291cmNlID0gc291cmNlLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGF1ZGlvU291cmNlSWQgPSBjb25zdHJhaW50VG9Tb3VyY2VJZF8xKHByb3BzLmF1ZGlvQ29uc3RyYWludHMpO1xuICAgICAgICAgICAgICAgIGlmIChhdWRpb1NvdXJjZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvU291cmNlID0gYXVkaW9Tb3VyY2VJZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZpZGVvU291cmNlSWQgPSBjb25zdHJhaW50VG9Tb3VyY2VJZF8xKHByb3BzLnZpZGVvQ29uc3RyYWludHMpO1xuICAgICAgICAgICAgICAgIGlmICh2aWRlb1NvdXJjZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvU291cmNlID0gdmlkZW9Tb3VyY2VJZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc291cmNlU2VsZWN0ZWQob3B0aW9uYWxTb3VyY2VfMShhdWRpb1NvdXJjZSksIG9wdGlvbmFsU291cmNlXzEodmlkZW9Tb3VyY2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXZWJjYW0ucHJvdG90eXBlLmhhbmRsZVVzZXJNZWRpYSA9IGZ1bmN0aW9uIChlcnIsIHN0cmVhbSkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoZXJyIHx8ICFzdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBoYXNVc2VyTWVkaWE6IGZhbHNlIH0pO1xuICAgICAgICAgICAgcHJvcHMub25Vc2VyTWVkaWFFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBoYXNVc2VyTWVkaWE6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBoYXNVc2VyTWVkaWE6IHRydWUsXG4gICAgICAgICAgICAgICAgc3JjOiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcy5vblVzZXJNZWRpYShzdHJlYW0pO1xuICAgIH07XG4gICAgV2ViY2FtLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHN0YXRlID0gX2Euc3RhdGUsIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIHZhciBhdWRpbyA9IHByb3BzLmF1ZGlvLCBmb3JjZVNjcmVlbnNob3RTb3VyY2VTaXplID0gcHJvcHMuZm9yY2VTY3JlZW5zaG90U291cmNlU2l6ZSwgZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUgPSBwcm9wcy5kaXNhYmxlUGljdHVyZUluUGljdHVyZSwgb25Vc2VyTWVkaWEgPSBwcm9wcy5vblVzZXJNZWRpYSwgb25Vc2VyTWVkaWFFcnJvciA9IHByb3BzLm9uVXNlck1lZGlhRXJyb3IsIHNjcmVlbnNob3RGb3JtYXQgPSBwcm9wcy5zY3JlZW5zaG90Rm9ybWF0LCBzY3JlZW5zaG90UXVhbGl0eSA9IHByb3BzLnNjcmVlbnNob3RRdWFsaXR5LCBtaW5TY3JlZW5zaG90V2lkdGggPSBwcm9wcy5taW5TY3JlZW5zaG90V2lkdGgsIG1pblNjcmVlbnNob3RIZWlnaHQgPSBwcm9wcy5taW5TY3JlZW5zaG90SGVpZ2h0LCBhdWRpb0NvbnN0cmFpbnRzID0gcHJvcHMuYXVkaW9Db25zdHJhaW50cywgdmlkZW9Db25zdHJhaW50cyA9IHByb3BzLnZpZGVvQ29uc3RyYWludHMsIGltYWdlU21vb3RoaW5nID0gcHJvcHMuaW1hZ2VTbW9vdGhpbmcsIG1pcnJvcmVkID0gcHJvcHMubWlycm9yZWQsIF9iID0gcHJvcHMuc3R5bGUsIHN0eWxlID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2IsIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sIHJlc3QgPSBfX3Jlc3QocHJvcHMsIFtcImF1ZGlvXCIsIFwiZm9yY2VTY3JlZW5zaG90U291cmNlU2l6ZVwiLCBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCIsIFwib25Vc2VyTWVkaWFcIiwgXCJvblVzZXJNZWRpYUVycm9yXCIsIFwic2NyZWVuc2hvdEZvcm1hdFwiLCBcInNjcmVlbnNob3RRdWFsaXR5XCIsIFwibWluU2NyZWVuc2hvdFdpZHRoXCIsIFwibWluU2NyZWVuc2hvdEhlaWdodFwiLCBcImF1ZGlvQ29uc3RyYWludHNcIiwgXCJ2aWRlb0NvbnN0cmFpbnRzXCIsIFwiaW1hZ2VTbW9vdGhpbmdcIiwgXCJtaXJyb3JlZFwiLCBcInN0eWxlXCIsIFwiY2hpbGRyZW5cIl0pO1xuICAgICAgICB2YXIgdmlkZW9TdHlsZSA9IG1pcnJvcmVkID8gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlKSwgeyB0cmFuc2Zvcm06IChzdHlsZS50cmFuc2Zvcm0gfHwgXCJcIikgKyBcIiBzY2FsZVgoLTEpXCIgfSkgOiBzdHlsZTtcbiAgICAgICAgdmFyIGNoaWxkcmVuUHJvcHMgPSB7XG4gICAgICAgICAgICBnZXRTY3JlZW5zaG90OiB0aGlzLmdldFNjcmVlbnNob3QuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChyZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY3JlYXRlRWxlbWVudFwiXShyZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRnJhZ21lbnRcIl0sIG51bGwsXG4gICAgICAgICAgICByZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY3JlYXRlRWxlbWVudFwiXShcInZpZGVvXCIsIF9fYXNzaWduKHsgYXV0b1BsYXk6IHRydWUsIGRpc2FibGVQaWN0dXJlSW5QaWN0dXJlOiBkaXNhYmxlUGljdHVyZUluUGljdHVyZSwgc3JjOiBzdGF0ZS5zcmMsIG11dGVkOiAhYXVkaW8sIHBsYXlzSW5saW5lOiB0cnVlLCByZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlkZW8gPSByZWY7XG4gICAgICAgICAgICAgICAgfSwgc3R5bGU6IHZpZGVvU3R5bGUgfSwgcmVzdCkpLFxuICAgICAgICAgICAgY2hpbGRyZW4gJiYgY2hpbGRyZW4oY2hpbGRyZW5Qcm9wcykpKTtcbiAgICB9O1xuICAgIFdlYmNhbS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgZGlzYWJsZVBpY3R1cmVJblBpY3R1cmU6IGZhbHNlLFxuICAgICAgICBmb3JjZVNjcmVlbnNob3RTb3VyY2VTaXplOiBmYWxzZSxcbiAgICAgICAgaW1hZ2VTbW9vdGhpbmc6IHRydWUsXG4gICAgICAgIG1pcnJvcmVkOiBmYWxzZSxcbiAgICAgICAgb25Vc2VyTWVkaWE6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgb25Vc2VyTWVkaWFFcnJvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICBzY3JlZW5zaG90Rm9ybWF0OiBcImltYWdlL3dlYnBcIixcbiAgICAgICAgc2NyZWVuc2hvdFF1YWxpdHk6IDAuOTIsXG4gICAgfTtcbiAgICByZXR1cm4gV2ViY2FtO1xufShyZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiQ29tcG9uZW50XCJdKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFdlYmNhbSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwicmVhY3RcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJjb21tb25qc1wiOlwicmVhY3RcIixcImFtZFwiOlwicmVhY3RcIn0gKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KVtcImRlZmF1bHRcIl07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXdlYmNhbS5qcy5tYXAiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInIiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwidCIsIm1vZGUiLCJfX2VzTW9kdWxlIiwibnMiLCJjcmVhdGUiLCJrZXkiLCJiaW5kIiwibiIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsInJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18iLCJyZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJfX2V4dGVuZHMiLCJ1bmRlZmluZWQiLCJleHRlbmRTdGF0aWNzIiwiYiIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJfXyIsImNvbnN0cnVjdG9yIiwiX19hc3NpZ24iLCJhc3NpZ24iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcHBseSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJwb2x5ZmlsbEdldFVzZXJNZWRpYSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImNvbnN0cmFpbnRzIiwid2Via2l0R2V0VXNlck1lZGlhIiwibW96R2V0VXNlck1lZGlhIiwibXNHZXRVc2VyTWVkaWEiLCJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJyZXNvbHZlIiwiaGFzR2V0VXNlck1lZGlhIiwiV2ViY2FtIiwiX3N1cGVyIiwicHJvcHMiLCJfdGhpcyIsImNhbnZhcyIsImN0eCIsInJlcXVlc3RVc2VyTWVkaWFJZCIsInVubW91bnRlZCIsInN0YXRlIiwiaGFzVXNlck1lZGlhIiwiY29tcG9uZW50RGlkTW91bnQiLCJfYSIsIm9uVXNlck1lZGlhRXJyb3IiLCJyZXF1ZXN0VXNlck1lZGlhIiwiY2hpbGRyZW4iLCJjb25zb2xlIiwid2FybiIsImNvbXBvbmVudERpZFVwZGF0ZSIsIm5leHRQcm9wcyIsImF1ZGlvQ29uc3RyYWludHNDaGFuZ2VkIiwiSlNPTiIsInN0cmluZ2lmeSIsImF1ZGlvQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0cmFpbnRzQ2hhbmdlZCIsInZpZGVvQ29uc3RyYWludHMiLCJtaW5TY3JlZW5zaG90V2lkdGhDaGFuZ2VkIiwibWluU2NyZWVuc2hvdFdpZHRoIiwibWluU2NyZWVuc2hvdEhlaWdodENoYW5nZWQiLCJtaW5TY3JlZW5zaG90SGVpZ2h0Iiwic3RvcEFuZENsZWFudXAiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInN0b3BNZWRpYVN0cmVhbSIsInN0cmVhbSIsImdldFZpZGVvVHJhY2tzIiwiZ2V0QXVkaW9UcmFja3MiLCJtYXAiLCJ0cmFjayIsInJlbW92ZVRyYWNrIiwic3RvcCIsInNyYyIsIndpbmRvdyIsIlVSTCIsInJldm9rZU9iamVjdFVSTCIsImdldFNjcmVlbnNob3QiLCJzY3JlZW5zaG90RGltZW5zaW9ucyIsImdldENhbnZhcyIsInRvRGF0YVVSTCIsInNjcmVlbnNob3RGb3JtYXQiLCJzY3JlZW5zaG90UXVhbGl0eSIsInZpZGVvIiwidmlkZW9IZWlnaHQiLCJjYW52YXNXaWR0aCIsInZpZGVvV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJmb3JjZVNjcmVlbnNob3RTb3VyY2VTaXplIiwiYXNwZWN0UmF0aW8iLCJjbGllbnRXaWR0aCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0Q29udGV4dCIsIl9iIiwibWlycm9yZWQiLCJ0cmFuc2xhdGUiLCJzY2FsZSIsImltYWdlU21vb3RoaW5nRW5hYmxlZCIsImltYWdlU21vb3RoaW5nIiwiZHJhd0ltYWdlIiwic291cmNlU2VsZWN0ZWQiLCJhdWRpbyIsIm15UmVxdWVzdFVzZXJNZWRpYUlkIiwidGhlbiIsImhhbmRsZVVzZXJNZWRpYSIsImNhdGNoIiwib3B0aW9uYWxTb3VyY2VfMSIsImlkIiwib3B0aW9uYWwiLCJzb3VyY2VJZCIsImNvbnN0cmFpbnRUb1NvdXJjZUlkXzEiLCJjb25zdHJhaW50IiwiZGV2aWNlSWQiLCJpc0FycmF5IiwiaWRlYWwiLCJNZWRpYVN0cmVhbVRyYWNrIiwiZ2V0U291cmNlcyIsInNvdXJjZXMiLCJhdWRpb1NvdXJjZSIsInZpZGVvU291cmNlIiwiZm9yRWFjaCIsInNvdXJjZSIsImtpbmQiLCJhdWRpb1NvdXJjZUlkIiwidmlkZW9Tb3VyY2VJZCIsImVyciIsInNldFN0YXRlIiwic3JjT2JqZWN0IiwiZXJyb3IiLCJjcmVhdGVPYmplY3RVUkwiLCJvblVzZXJNZWRpYSIsInJlbmRlciIsImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlIiwic3R5bGUiLCJyZXN0IiwidmlkZW9TdHlsZSIsInRyYW5zZm9ybSIsImNoaWxkcmVuUHJvcHMiLCJhdXRvUGxheSIsIm11dGVkIiwicGxheXNJbmxpbmUiLCJyZWYiLCJkZWZhdWx0UHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/react-webcam@7.2.0_react-dom@18.3.1_react@18.2.0/node_modules/react-webcam/dist/react-webcam.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/scanner/page.tsx":
/*!**********************************!*\
  !*** ./src/app/scanner/page.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ScannerPage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_webcam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-webcam */ \"(app-pages-browser)/../../node_modules/.pnpm/react-webcam@7.2.0_react-dom@18.3.1_react@18.2.0/node_modules/react-webcam/dist/react-webcam.js\");\n/* harmony import */ var react_webcam__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_webcam__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _barrel_optimize_names_Camera_Check_Loader2_RotateCw_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=Camera,Check,Loader2,RotateCw,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/x.js\");\n/* harmony import */ var _barrel_optimize_names_Camera_Check_Loader2_RotateCw_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=Camera,Check,Loader2,RotateCw,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/check.js\");\n/* harmony import */ var _barrel_optimize_names_Camera_Check_Loader2_RotateCw_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Camera,Check,Loader2,RotateCw,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/loader-2.js\");\n/* harmony import */ var _barrel_optimize_names_Camera_Check_Loader2_RotateCw_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=Camera,Check,Loader2,RotateCw,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/camera.js\");\n/* harmony import */ var _barrel_optimize_names_Camera_Check_Loader2_RotateCw_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! __barrel_optimize__?names=Camera,Check,Loader2,RotateCw,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.344.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/rotate-cw.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/api/link.js\");\n/* harmony import */ var _services_AIService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/AIService */ \"(app-pages-browser)/./src/services/AIService.ts\");\n/* harmony import */ var _services_DatabaseService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/services/DatabaseService */ \"(app-pages-browser)/./src/services/DatabaseService.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction ScannerPage() {\n    _s();\n    const webcamRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [currentStep, setCurrentStep] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"front\");\n    const [captures, setCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isProcessing, setIsProcessing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [scanResult, setScanResult] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const stepLabels = {\n        \"front\": \"Card Front\",\n        \"back\": \"Card Back\",\n        \"edge-top\": \"Top Edge\",\n        \"edge-bottom\": \"Bottom Edge\",\n        \"edge-left\": \"Left Edge\",\n        \"edge-right\": \"Right Edge\",\n        \"complete\": \"Scan Complete\"\n    };\n    const capture = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        var _webcamRef_current;\n        const imageSrc = (_webcamRef_current = webcamRef.current) === null || _webcamRef_current === void 0 ? void 0 : _webcamRef_current.getScreenshot();\n        if (imageSrc && currentStep !== \"complete\") {\n            setCaptures((prev)=>({\n                    ...prev,\n                    [currentStep]: imageSrc\n                }));\n            // Move to next step\n            const steps = [\n                \"front\",\n                \"back\",\n                \"edge-top\",\n                \"edge-bottom\",\n                \"edge-left\",\n                \"edge-right\",\n                \"complete\"\n            ];\n            const currentIndex = steps.indexOf(currentStep);\n            if (currentIndex < steps.length - 1) {\n                setCurrentStep(steps[currentIndex + 1]);\n            }\n            // If all captures complete, process\n            if (currentIndex === steps.length - 2) {\n                processScan({\n                    ...captures,\n                    [currentStep]: imageSrc\n                });\n            }\n        }\n    }, [\n        currentStep,\n        captures\n    ]);\n    const processScan = async (allCaptures)=>{\n        setIsProcessing(true);\n        setError(null);\n        try {\n            // Initialize services\n            await _services_DatabaseService__WEBPACK_IMPORTED_MODULE_5__.DatabaseService.init();\n            // Process with AI\n            const result = await _services_AIService__WEBPACK_IMPORTED_MODULE_4__.AIService.processCard(allCaptures);\n            // Save to database\n            const scan = await _services_DatabaseService__WEBPACK_IMPORTED_MODULE_5__.DatabaseService.saveScan({\n                captures: allCaptures,\n                result,\n                timestamp: Date.now()\n            });\n            setScanResult(result);\n            setCurrentStep(\"complete\");\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Processing failed\");\n        } finally{\n            setIsProcessing(false);\n        }\n    };\n    const reset = ()=>{\n        setCurrentStep(\"front\");\n        setCaptures({});\n        setScanResult(null);\n        setError(null);\n    };\n    if (currentStep === \"complete\" && scanResult) {\n        var _scanResult_damages;\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"min-h-screen bg-gray-900 text-white p-4\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"max-w-4xl mx-auto\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-3xl font-bold mb-8\",\n                        children: \"Scan Results\"\n                    }, void 0, false, {\n                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                        lineNumber: 88,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-gray-800 rounded-xl p-6 mb-6\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"grid grid-cols-2 gap-4 mb-6\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                className: \"text-sm text-gray-400 mb-1\",\n                                                children: \"Condition Grade\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                lineNumber: 93,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-3xl font-bold text-primary\",\n                                                children: [\n                                                    scanResult.grade,\n                                                    \"/10\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                lineNumber: 94,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                        lineNumber: 92,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                className: \"text-sm text-gray-400 mb-1\",\n                                                children: \"Confidence\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                lineNumber: 97,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-3xl font-bold text-green-500\",\n                                                children: [\n                                                    scanResult.confidence,\n                                                    \"%\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                lineNumber: 98,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                        lineNumber: 96,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                lineNumber: 91,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"space-y-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                className: \"font-semibold mb-2\",\n                                                children: \"Damage Detection\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                lineNumber: 104,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                className: \"space-y-1\",\n                                                children: ((_scanResult_damages = scanResult.damages) === null || _scanResult_damages === void 0 ? void 0 : _scanResult_damages.map((damage, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        className: \"flex items-center text-sm\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Check_Loader2_RotateCw_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                                                                className: \"w-4 h-4 text-red-500 mr-2\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                                lineNumber: 108,\n                                                                columnNumber: 23\n                                                            }, this),\n                                                            damage.type,\n                                                            \": \",\n                                                            damage.severity,\n                                                            \" (\",\n                                                            damage.location,\n                                                            \")\"\n                                                        ]\n                                                    }, i, true, {\n                                                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                        lineNumber: 107,\n                                                        columnNumber: 21\n                                                    }, this))) || /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    className: \"flex items-center text-sm text-green-500\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Check_Loader2_RotateCw_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                                            className: \"w-4 h-4 mr-2\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                            lineNumber: 113,\n                                                            columnNumber: 23\n                                                        }, this),\n                                                        \"No significant damage detected\"\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                    lineNumber: 112,\n                                                    columnNumber: 21\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                lineNumber: 105,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                        lineNumber: 103,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                className: \"font-semibold mb-2\",\n                                                children: \"Authentication\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                lineNumber: 121,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-sm \".concat(scanResult.authentic ? \"text-green-500\" : \"text-red-500\"),\n                                                children: scanResult.authentic ? \" Appears Authentic\" : \" Authentication Warning\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                lineNumber: 122,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                        lineNumber: 120,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                className: \"font-semibold mb-2\",\n                                                children: \"Market Value Estimate\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                lineNumber: 128,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-2xl font-bold text-primary\",\n                                                children: [\n                                                    \"$\",\n                                                    scanResult.estimatedValue || \"N/A\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                lineNumber: 129,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                        lineNumber: 127,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                lineNumber: 102,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                        lineNumber: 90,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex gap-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: reset,\n                                className: \"flex-1 bg-primary hover:bg-primary/90 text-white py-3 rounded-lg font-semibold transition\",\n                                children: \"Scan Another Card\"\n                            }, void 0, false, {\n                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                lineNumber: 135,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                href: \"/dashboard\",\n                                className: \"flex-1 bg-gray-700 hover:bg-gray-600 text-white py-3 rounded-lg font-semibold transition text-center\",\n                                children: \"View Dashboard\"\n                            }, void 0, false, {\n                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                lineNumber: 141,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                        lineNumber: 134,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                lineNumber: 87,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n            lineNumber: 86,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-gray-900 text-white\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"bg-black/50 backdrop-blur-lg border-b border-white/10 p-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"max-w-4xl mx-auto flex justify-between items-center\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                            href: \"/\",\n                            className: \"text-xl font-bold\",\n                            children: \"VeriCard Scan Pro\"\n                        }, void 0, false, {\n                            fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                            lineNumber: 158,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-sm\",\n                            children: [\n                                \"Step \",\n                                currentStep !== \"complete\" ? stepLabels[currentStep] : \"Processing\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                            lineNumber: 159,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                    lineNumber: 157,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                lineNumber: 156,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col items-center justify-center p-4 min-h-[calc(100vh-80px)]\",\n                children: [\n                    error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mb-4 p-4 bg-red-500/20 border border-red-500 rounded-lg max-w-md\",\n                        children: error\n                    }, void 0, false, {\n                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                        lineNumber: 168,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"relative w-full max-w-2xl aspect-[4/3] bg-black rounded-xl overflow-hidden mb-6\",\n                        children: isProcessing ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"absolute inset-0 flex items-center justify-center bg-black/80\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Check_Loader2_RotateCw_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                        className: \"w-12 h-12 animate-spin mx-auto mb-4\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                        lineNumber: 177,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-lg\",\n                                        children: \"Processing scan...\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                        lineNumber: 178,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-sm text-gray-400\",\n                                        children: \"This may take a few seconds\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                        lineNumber: 179,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                lineNumber: 176,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                            lineNumber: 175,\n                            columnNumber: 13\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react_webcam__WEBPACK_IMPORTED_MODULE_2___default()), {\n                                    ref: webcamRef,\n                                    audio: false,\n                                    screenshotFormat: \"image/jpeg\",\n                                    className: \"w-full h-full object-cover\",\n                                    videoConstraints: {\n                                        width: 1280,\n                                        height: 720,\n                                        facingMode: \"environment\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                    lineNumber: 184,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"absolute inset-0 pointer-events-none\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"scan-line\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                            lineNumber: 199,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"absolute top-8 left-8 w-16 h-16 border-l-2 border-t-2 border-primary\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                            lineNumber: 202,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"absolute top-8 right-8 w-16 h-16 border-r-2 border-t-2 border-primary\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                            lineNumber: 203,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"absolute bottom-8 left-8 w-16 h-16 border-l-2 border-b-2 border-primary\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                            lineNumber: 204,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"absolute bottom-8 right-8 w-16 h-16 border-r-2 border-b-2 border-primary\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                            lineNumber: 205,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-6\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    className: \"text-center text-lg font-semibold\",\n                                                    children: [\n                                                        \"Position \",\n                                                        stepLabels[currentStep]\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                    lineNumber: 209,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    className: \"text-center text-sm text-gray-300 mt-1\",\n                                                    children: \"Align card within the guides and hold steady\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                                    lineNumber: 212,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                            lineNumber: 208,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                    lineNumber: 197,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true)\n                    }, void 0, false, {\n                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                        lineNumber: 173,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex gap-2 mb-6\",\n                        children: Object.entries(stepLabels).filter((param)=>{\n                            let [k] = param;\n                            return k !== \"complete\";\n                        }).map((param)=>{\n                            let [step, label] = param;\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"px-3 py-1 rounded-full text-sm \".concat(captures[step] ? \"bg-green-500 text-white\" : step === currentStep ? \"bg-primary text-white\" : \"bg-gray-700 text-gray-400\"),\n                                children: [\n                                    captures[step] ? \"\" : \"\",\n                                    \" \",\n                                    label\n                                ]\n                            }, step, true, {\n                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                lineNumber: 224,\n                                columnNumber: 13\n                            }, this);\n                        })\n                    }, void 0, false, {\n                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                        lineNumber: 222,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex gap-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: capture,\n                                disabled: isProcessing || currentStep === \"complete\",\n                                className: \"bg-primary hover:bg-primary/90 disabled:bg-gray-700 disabled:opacity-50 text-white px-8 py-3 rounded-lg font-semibold transition flex items-center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Check_Loader2_RotateCw_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                        className: \"w-5 h-5 mr-2\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                        lineNumber: 246,\n                                        columnNumber: 13\n                                    }, this),\n                                    \"Capture \",\n                                    stepLabels[currentStep]\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                lineNumber: 241,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: reset,\n                                disabled: isProcessing,\n                                className: \"bg-gray-700 hover:bg-gray-600 disabled:opacity-50 text-white px-6 py-3 rounded-lg font-semibold transition flex items-center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Check_Loader2_RotateCw_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                        className: \"w-5 h-5 mr-2\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                        lineNumber: 255,\n                                        columnNumber: 13\n                                    }, this),\n                                    \"Reset\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                                lineNumber: 250,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                        lineNumber: 240,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n                lineNumber: 166,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/sam/projects/vericard-scan-pro/apps/web/src/app/scanner/page.tsx\",\n        lineNumber: 154,\n        columnNumber: 5\n    }, this);\n}\n_s(ScannerPage, \"80oMefK4ZxH2wAB7JOQwSVwEOwo=\");\n_c = ScannerPage;\nvar _c;\n$RefreshReg$(_c, \"ScannerPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc2Nhbm5lci9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXFEO0FBQ3BCO0FBQ2lDO0FBQ3RDO0FBRW9CO0FBQ1k7QUFJN0MsU0FBU1k7O0lBQ3RCLE1BQU1DLFlBQVlaLDZDQUFNQSxDQUFTO0lBQ2pDLE1BQU0sQ0FBQ2EsYUFBYUMsZUFBZSxHQUFHZiwrQ0FBUUEsQ0FBYztJQUM1RCxNQUFNLENBQUNnQixVQUFVQyxZQUFZLEdBQUdqQiwrQ0FBUUEsQ0FBeUIsQ0FBQztJQUNsRSxNQUFNLENBQUNrQixjQUFjQyxnQkFBZ0IsR0FBR25CLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ29CLFlBQVlDLGNBQWMsR0FBR3JCLCtDQUFRQSxDQUFNO0lBQ2xELE1BQU0sQ0FBQ3NCLE9BQU9DLFNBQVMsR0FBR3ZCLCtDQUFRQSxDQUFnQjtJQUVsRCxNQUFNd0IsYUFBMEM7UUFDOUMsU0FBUztRQUNULFFBQVE7UUFDUixZQUFZO1FBQ1osZUFBZTtRQUNmLGFBQWE7UUFDYixjQUFjO1FBQ2QsWUFBWTtJQUNkO0lBRUEsTUFBTUMsVUFBVXZCLGtEQUFXQSxDQUFDO1lBQ1RXO1FBQWpCLE1BQU1hLFlBQVdiLHFCQUFBQSxVQUFVYyxPQUFPLGNBQWpCZCx5Q0FBQUEsbUJBQW1CZSxhQUFhO1FBQ2pELElBQUlGLFlBQVlaLGdCQUFnQixZQUFZO1lBQzFDRyxZQUFZWSxDQUFBQSxPQUFTO29CQUFFLEdBQUdBLElBQUk7b0JBQUUsQ0FBQ2YsWUFBWSxFQUFFWTtnQkFBUztZQUV4RCxvQkFBb0I7WUFDcEIsTUFBTUksUUFBdUI7Z0JBQUM7Z0JBQVM7Z0JBQVE7Z0JBQVk7Z0JBQWU7Z0JBQWE7Z0JBQWM7YUFBVztZQUNoSCxNQUFNQyxlQUFlRCxNQUFNRSxPQUFPLENBQUNsQjtZQUNuQyxJQUFJaUIsZUFBZUQsTUFBTUcsTUFBTSxHQUFHLEdBQUc7Z0JBQ25DbEIsZUFBZWUsS0FBSyxDQUFDQyxl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bm5lci9wYWdlLnRzeD9hNTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFdlYmNhbSBmcm9tICdyZWFjdC13ZWJjYW0nXG5pbXBvcnQgeyBDYW1lcmEsIFJvdGF0ZUN3LCBDaGVjaywgWCwgTG9hZGVyMiB9IGZyb20gJ2x1Y2lkZS1yZWFjdCdcbmltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluaydcbmltcG9ydCB7IENhbWVyYVNlcnZpY2UgfSBmcm9tICdAL3NlcnZpY2VzL0NhbWVyYVNlcnZpY2UnXG5pbXBvcnQgeyBBSVNlcnZpY2UgfSBmcm9tICdAL3NlcnZpY2VzL0FJU2VydmljZSdcbmltcG9ydCB7IERhdGFiYXNlU2VydmljZSB9IGZyb20gJ0Avc2VydmljZXMvRGF0YWJhc2VTZXJ2aWNlJ1xuXG50eXBlIENhcHR1cmVTdGVwID0gJ2Zyb250JyB8ICdiYWNrJyB8ICdlZGdlLXRvcCcgfCAnZWRnZS1ib3R0b20nIHwgJ2VkZ2UtbGVmdCcgfCAnZWRnZS1yaWdodCcgfCAnY29tcGxldGUnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNjYW5uZXJQYWdlKCkge1xuICBjb25zdCB3ZWJjYW1SZWYgPSB1c2VSZWY8V2ViY2FtPihudWxsKVxuICBjb25zdCBbY3VycmVudFN0ZXAsIHNldEN1cnJlbnRTdGVwXSA9IHVzZVN0YXRlPENhcHR1cmVTdGVwPignZnJvbnQnKVxuICBjb25zdCBbY2FwdHVyZXMsIHNldENhcHR1cmVzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KHt9KVxuICBjb25zdCBbaXNQcm9jZXNzaW5nLCBzZXRJc1Byb2Nlc3NpbmddID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtzY2FuUmVzdWx0LCBzZXRTY2FuUmVzdWx0XSA9IHVzZVN0YXRlPGFueT4obnVsbClcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKVxuXG4gIGNvbnN0IHN0ZXBMYWJlbHM6IFJlY29yZDxDYXB0dXJlU3RlcCwgc3RyaW5nPiA9IHtcbiAgICAnZnJvbnQnOiAnQ2FyZCBGcm9udCcsXG4gICAgJ2JhY2snOiAnQ2FyZCBCYWNrJyxcbiAgICAnZWRnZS10b3AnOiAnVG9wIEVkZ2UnLFxuICAgICdlZGdlLWJvdHRvbSc6ICdCb3R0b20gRWRnZScsXG4gICAgJ2VkZ2UtbGVmdCc6ICdMZWZ0IEVkZ2UnLFxuICAgICdlZGdlLXJpZ2h0JzogJ1JpZ2h0IEVkZ2UnLFxuICAgICdjb21wbGV0ZSc6ICdTY2FuIENvbXBsZXRlJ1xuICB9XG5cbiAgY29uc3QgY2FwdHVyZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBpbWFnZVNyYyA9IHdlYmNhbVJlZi5jdXJyZW50Py5nZXRTY3JlZW5zaG90KClcbiAgICBpZiAoaW1hZ2VTcmMgJiYgY3VycmVudFN0ZXAgIT09ICdjb21wbGV0ZScpIHtcbiAgICAgIHNldENhcHR1cmVzKHByZXYgPT4gKHsgLi4ucHJldiwgW2N1cnJlbnRTdGVwXTogaW1hZ2VTcmMgfSkpXG4gICAgICBcbiAgICAgIC8vIE1vdmUgdG8gbmV4dCBzdGVwXG4gICAgICBjb25zdCBzdGVwczogQ2FwdHVyZVN0ZXBbXSA9IFsnZnJvbnQnLCAnYmFjaycsICdlZGdlLXRvcCcsICdlZGdlLWJvdHRvbScsICdlZGdlLWxlZnQnLCAnZWRnZS1yaWdodCcsICdjb21wbGV0ZSddXG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBzdGVwcy5pbmRleE9mKGN1cnJlbnRTdGVwKVxuICAgICAgaWYgKGN1cnJlbnRJbmRleCA8IHN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgc2V0Q3VycmVudFN0ZXAoc3RlcHNbY3VycmVudEluZGV4ICsgMV0gYXMgQ2FwdHVyZVN0ZXApXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIGFsbCBjYXB0dXJlcyBjb21wbGV0ZSwgcHJvY2Vzc1xuICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gc3RlcHMubGVuZ3RoIC0gMikge1xuICAgICAgICBwcm9jZXNzU2Nhbih7IC4uLmNhcHR1cmVzLCBbY3VycmVudFN0ZXBdOiBpbWFnZVNyYyB9KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW2N1cnJlbnRTdGVwLCBjYXB0dXJlc10pXG5cbiAgY29uc3QgcHJvY2Vzc1NjYW4gPSBhc3luYyAoYWxsQ2FwdHVyZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pID0+IHtcbiAgICBzZXRJc1Byb2Nlc3NpbmcodHJ1ZSlcbiAgICBzZXRFcnJvcihudWxsKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBJbml0aWFsaXplIHNlcnZpY2VzXG4gICAgICBhd2FpdCBEYXRhYmFzZVNlcnZpY2UuaW5pdCgpXG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3Mgd2l0aCBBSVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQUlTZXJ2aWNlLnByb2Nlc3NDYXJkKGFsbENhcHR1cmVzKVxuICAgICAgXG4gICAgICAvLyBTYXZlIHRvIGRhdGFiYXNlXG4gICAgICBjb25zdCBzY2FuID0gYXdhaXQgRGF0YWJhc2VTZXJ2aWNlLnNhdmVTY2FuKHtcbiAgICAgICAgY2FwdHVyZXM6IGFsbENhcHR1cmVzLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgc2V0U2NhblJlc3VsdChyZXN1bHQpXG4gICAgICBzZXRDdXJyZW50U3RlcCgnY29tcGxldGUnKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdQcm9jZXNzaW5nIGZhaWxlZCcpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSlcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBzZXRDdXJyZW50U3RlcCgnZnJvbnQnKVxuICAgIHNldENhcHR1cmVzKHt9KVxuICAgIHNldFNjYW5SZXN1bHQobnVsbClcbiAgICBzZXRFcnJvcihudWxsKVxuICB9XG5cbiAgaWYgKGN1cnJlbnRTdGVwID09PSAnY29tcGxldGUnICYmIHNjYW5SZXN1bHQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gYmctZ3JheS05MDAgdGV4dC13aGl0ZSBwLTRcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtdy00eGwgbXgtYXV0b1wiPlxuICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBmb250LWJvbGQgbWItOFwiPlNjYW4gUmVzdWx0czwvaDE+XG4gICAgICAgICAgXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1ncmF5LTgwMCByb3VuZGVkLXhsIHAtNiBtYi02XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgZ2FwLTQgbWItNlwiPlxuICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS00MDAgbWItMVwiPkNvbmRpdGlvbiBHcmFkZTwvaDM+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC0zeGwgZm9udC1ib2xkIHRleHQtcHJpbWFyeVwiPntzY2FuUmVzdWx0LmdyYWRlfS8xMDwvcD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTQwMCBtYi0xXCI+Q29uZmlkZW5jZTwvaDM+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC0zeGwgZm9udC1ib2xkIHRleHQtZ3JlZW4tNTAwXCI+e3NjYW5SZXN1bHQuY29uZmlkZW5jZX0lPC9wPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktNFwiPlxuICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkIG1iLTJcIj5EYW1hZ2UgRGV0ZWN0aW9uPC9oMz5cbiAgICAgICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwic3BhY2UteS0xXCI+XG4gICAgICAgICAgICAgICAgICB7c2NhblJlc3VsdC5kYW1hZ2VzPy5tYXAoKGRhbWFnZTogYW55LCBpOiBudW1iZXIpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPGxpIGtleT17aX0gY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgdGV4dC1zbVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxYIGNsYXNzTmFtZT1cInctNCBoLTQgdGV4dC1yZWQtNTAwIG1yLTJcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgIHtkYW1hZ2UudHlwZX06IHtkYW1hZ2Uuc2V2ZXJpdHl9ICh7ZGFtYWdlLmxvY2F0aW9ufSlcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICkpIHx8IChcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHRleHQtc20gdGV4dC1ncmVlbi01MDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2sgY2xhc3NOYW1lPVwidy00IGgtNCBtci0yXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICBObyBzaWduaWZpY2FudCBkYW1hZ2UgZGV0ZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkIG1iLTJcIj5BdXRoZW50aWNhdGlvbjwvaDM+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPXtgdGV4dC1zbSAke3NjYW5SZXN1bHQuYXV0aGVudGljID8gJ3RleHQtZ3JlZW4tNTAwJyA6ICd0ZXh0LXJlZC01MDAnfWB9PlxuICAgICAgICAgICAgICAgICAge3NjYW5SZXN1bHQuYXV0aGVudGljID8gJ+KckyBBcHBlYXJzIEF1dGhlbnRpYycgOiAn4pqg77iPIEF1dGhlbnRpY2F0aW9uIFdhcm5pbmcnfVxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkIG1iLTJcIj5NYXJrZXQgVmFsdWUgRXN0aW1hdGU8L2gzPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZCB0ZXh0LXByaW1hcnlcIj4ke3NjYW5SZXN1bHQuZXN0aW1hdGVkVmFsdWUgfHwgJ04vQSd9PC9wPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtNFwiPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBvbkNsaWNrPXtyZXNldH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmxleC0xIGJnLXByaW1hcnkgaG92ZXI6YmctcHJpbWFyeS85MCB0ZXh0LXdoaXRlIHB5LTMgcm91bmRlZC1sZyBmb250LXNlbWlib2xkIHRyYW5zaXRpb25cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBTY2FuIEFub3RoZXIgQ2FyZFxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8TGlua1xuICAgICAgICAgICAgICBocmVmPVwiL2Rhc2hib2FyZFwiXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXgtMSBiZy1ncmF5LTcwMCBob3ZlcjpiZy1ncmF5LTYwMCB0ZXh0LXdoaXRlIHB5LTMgcm91bmRlZC1sZyBmb250LXNlbWlib2xkIHRyYW5zaXRpb24gdGV4dC1jZW50ZXJcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBWaWV3IERhc2hib2FyZFxuICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gYmctZ3JheS05MDAgdGV4dC13aGl0ZVwiPlxuICAgICAgey8qIEhlYWRlciAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctYmxhY2svNTAgYmFja2Ryb3AtYmx1ci1sZyBib3JkZXItYiBib3JkZXItd2hpdGUvMTAgcC00XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXctNHhsIG14LWF1dG8gZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgPExpbmsgaHJlZj1cIi9cIiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtYm9sZFwiPlZlcmlDYXJkIFNjYW4gUHJvPC9MaW5rPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1zbVwiPlxuICAgICAgICAgICAgU3RlcCB7Y3VycmVudFN0ZXAgIT09ICdjb21wbGV0ZScgPyBzdGVwTGFiZWxzW2N1cnJlbnRTdGVwXSA6ICdQcm9jZXNzaW5nJ31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIFNjYW5uZXIgSW50ZXJmYWNlICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBwLTQgbWluLWgtW2NhbGMoMTAwdmgtODBweCldXCI+XG4gICAgICAgIHtlcnJvciAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi00IHAtNCBiZy1yZWQtNTAwLzIwIGJvcmRlciBib3JkZXItcmVkLTUwMCByb3VuZGVkLWxnIG1heC13LW1kXCI+XG4gICAgICAgICAgICB7ZXJyb3J9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSB3LWZ1bGwgbWF4LXctMnhsIGFzcGVjdC1bNC8zXSBiZy1ibGFjayByb3VuZGVkLXhsIG92ZXJmbG93LWhpZGRlbiBtYi02XCI+XG4gICAgICAgICAge2lzUHJvY2Vzc2luZyA/IChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1ibGFjay84MFwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPExvYWRlcjIgY2xhc3NOYW1lPVwidy0xMiBoLTEyIGFuaW1hdGUtc3BpbiBteC1hdXRvIG1iLTRcIiAvPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtbGdcIj5Qcm9jZXNzaW5nIHNjYW4uLi48L3A+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNDAwXCI+VGhpcyBtYXkgdGFrZSBhIGZldyBzZWNvbmRzPC9wPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICA8V2ViY2FtXG4gICAgICAgICAgICAgICAgcmVmPXt3ZWJjYW1SZWZ9XG4gICAgICAgICAgICAgICAgYXVkaW89e2ZhbHNlfVxuICAgICAgICAgICAgICAgIHNjcmVlbnNob3RGb3JtYXQ9XCJpbWFnZS9qcGVnXCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIG9iamVjdC1jb3ZlclwiXG4gICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cz17e1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IDEyODAsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IDcyMCxcbiAgICAgICAgICAgICAgICAgIGZhY2luZ01vZGU6IFwiZW52aXJvbm1lbnRcIlxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB7LyogT3ZlcmxheSAqL31cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSBpbnNldC0wIHBvaW50ZXItZXZlbnRzLW5vbmVcIj5cbiAgICAgICAgICAgICAgICB7LyogU2NhbiBsaW5lIGFuaW1hdGlvbiAqL31cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNjYW4tbGluZVwiIC8+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgey8qIENvcm5lciBndWlkZXMgKi99XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtOCBsZWZ0LTggdy0xNiBoLTE2IGJvcmRlci1sLTIgYm9yZGVyLXQtMiBib3JkZXItcHJpbWFyeVwiIC8+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtOCByaWdodC04IHctMTYgaC0xNiBib3JkZXItci0yIGJvcmRlci10LTIgYm9yZGVyLXByaW1hcnlcIiAvPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgYm90dG9tLTggbGVmdC04IHctMTYgaC0xNiBib3JkZXItbC0yIGJvcmRlci1iLTIgYm9yZGVyLXByaW1hcnlcIiAvPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgYm90dG9tLTggcmlnaHQtOCB3LTE2IGgtMTYgYm9yZGVyLXItMiBib3JkZXItYi0yIGJvcmRlci1wcmltYXJ5XCIgLz5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB7LyogSW5zdHJ1Y3Rpb25zICovfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgYm90dG9tLTAgbGVmdC0wIHJpZ2h0LTAgYmctZ3JhZGllbnQtdG8tdCBmcm9tLWJsYWNrLzgwIHRvLXRyYW5zcGFyZW50IHAtNlwiPlxuICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgdGV4dC1sZyBmb250LXNlbWlib2xkXCI+XG4gICAgICAgICAgICAgICAgICAgIFBvc2l0aW9uIHtzdGVwTGFiZWxzW2N1cnJlbnRTdGVwXX1cbiAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHRleHQtc20gdGV4dC1ncmF5LTMwMCBtdC0xXCI+XG4gICAgICAgICAgICAgICAgICAgIEFsaWduIGNhcmQgd2l0aGluIHRoZSBndWlkZXMgYW5kIGhvbGQgc3RlYWR5XG4gICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgey8qIENhcHR1cmUgUHJvZ3Jlc3MgKi99XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtMiBtYi02XCI+XG4gICAgICAgICAge09iamVjdC5lbnRyaWVzKHN0ZXBMYWJlbHMpLmZpbHRlcigoW2tdKSA9PiBrICE9PSAnY29tcGxldGUnKS5tYXAoKFtzdGVwLCBsYWJlbF0pID0+IChcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAga2V5PXtzdGVwfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2BweC0zIHB5LTEgcm91bmRlZC1mdWxsIHRleHQtc20gJHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlc1tzdGVwXSBcbiAgICAgICAgICAgICAgICAgID8gJ2JnLWdyZWVuLTUwMCB0ZXh0LXdoaXRlJyBcbiAgICAgICAgICAgICAgICAgIDogc3RlcCA9PT0gY3VycmVudFN0ZXAgXG4gICAgICAgICAgICAgICAgICAgID8gJ2JnLXByaW1hcnkgdGV4dC13aGl0ZScgXG4gICAgICAgICAgICAgICAgICAgIDogJ2JnLWdyYXktNzAwIHRleHQtZ3JheS00MDAnXG4gICAgICAgICAgICAgIH1gfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7Y2FwdHVyZXNbc3RlcF0gPyAn4pyTJyA6ICcnfSB7bGFiZWx9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgey8qIENvbnRyb2xzICovfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZ2FwLTRcIj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXtjYXB0dXJlfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2lzUHJvY2Vzc2luZyB8fCBjdXJyZW50U3RlcCA9PT0gJ2NvbXBsZXRlJ31cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLXByaW1hcnkgaG92ZXI6YmctcHJpbWFyeS85MCBkaXNhYmxlZDpiZy1ncmF5LTcwMCBkaXNhYmxlZDpvcGFjaXR5LTUwIHRleHQtd2hpdGUgcHgtOCBweS0zIHJvdW5kZWQtbGcgZm9udC1zZW1pYm9sZCB0cmFuc2l0aW9uIGZsZXggaXRlbXMtY2VudGVyXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Q2FtZXJhIGNsYXNzTmFtZT1cInctNSBoLTUgbXItMlwiIC8+XG4gICAgICAgICAgICBDYXB0dXJlIHtzdGVwTGFiZWxzW2N1cnJlbnRTdGVwXX1cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICBcbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXtyZXNldH1cbiAgICAgICAgICAgIGRpc2FibGVkPXtpc1Byb2Nlc3Npbmd9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ncmF5LTcwMCBob3ZlcjpiZy1ncmF5LTYwMCBkaXNhYmxlZDpvcGFjaXR5LTUwIHRleHQtd2hpdGUgcHgtNiBweS0zIHJvdW5kZWQtbGcgZm9udC1zZW1pYm9sZCB0cmFuc2l0aW9uIGZsZXggaXRlbXMtY2VudGVyXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Um90YXRlQ3cgY2xhc3NOYW1lPVwidy01IGgtNSBtci0yXCIgLz5cbiAgICAgICAgICAgIFJlc2V0XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsIldlYmNhbSIsIkNhbWVyYSIsIlJvdGF0ZUN3IiwiQ2hlY2siLCJYIiwiTG9hZGVyMiIsIkxpbmsiLCJBSVNlcnZpY2UiLCJEYXRhYmFzZVNlcnZpY2UiLCJTY2FubmVyUGFnZSIsIndlYmNhbVJlZiIsImN1cnJlbnRTdGVwIiwic2V0Q3VycmVudFN0ZXAiLCJjYXB0dXJlcyIsInNldENhcHR1cmVzIiwiaXNQcm9jZXNzaW5nIiwic2V0SXNQcm9jZXNzaW5nIiwic2NhblJlc3VsdCIsInNldFNjYW5SZXN1bHQiLCJlcnJvciIsInNldEVycm9yIiwic3RlcExhYmVscyIsImNhcHR1cmUiLCJpbWFnZVNyYyIsImN1cnJlbnQiLCJnZXRTY3JlZW5zaG90IiwicHJldiIsInN0ZXBzIiwiY3VycmVudEluZGV4IiwiaW5kZXhPZiIsImxlbmd0aCIsInByb2Nlc3NTY2FuIiwiYWxsQ2FwdHVyZXMiLCJpbml0IiwicmVzdWx0IiwicHJvY2Vzc0NhcmQiLCJzY2FuIiwic2F2ZVNjYW4iLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwiZXJyIiwiRXJyb3IiLCJtZXNzYWdlIiwicmVzZXQiLCJkaXYiLCJjbGFzc05hbWUiLCJoMSIsImgzIiwicCIsImdyYWRlIiwiY29uZmlkZW5jZSIsInVsIiwiZGFtYWdlcyIsIm1hcCIsImRhbWFnZSIsImkiLCJsaSIsInR5cGUiLCJzZXZlcml0eSIsImxvY2F0aW9uIiwiYXV0aGVudGljIiwiZXN0aW1hdGVkVmFsdWUiLCJidXR0b24iLCJvbkNsaWNrIiwiaHJlZiIsInJlZiIsImF1ZGlvIiwic2NyZWVuc2hvdEZvcm1hdCIsInZpZGVvQ29uc3RyYWludHMiLCJ3aWR0aCIsImhlaWdodCIsImZhY2luZ01vZGUiLCJPYmplY3QiLCJlbnRyaWVzIiwiZmlsdGVyIiwiayIsInN0ZXAiLCJsYWJlbCIsImRpc2FibGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/scanner/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/AIService.ts":
/*!***********************************!*\
  !*** ./src/services/AIService.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIService: function() { return /* binding */ AIService; }\n/* harmony export */ });\nclass AIService {\n    static async processCard(captures) {\n        // Simulate AI processing delay\n        await new Promise((resolve)=>setTimeout(resolve, this.PROCESSING_DELAY));\n        // Mock AI analysis based on captures\n        const hasAllCaptures = [\n            \"front\",\n            \"back\",\n            \"edge-top\",\n            \"edge-bottom\",\n            \"edge-left\",\n            \"edge-right\"\n        ].every((key)=>captures[key]);\n        if (!hasAllCaptures) {\n            throw new Error(\"Missing required captures\");\n        }\n        // Simulate damage detection\n        const damages = this.detectDamages(captures);\n        const grade = this.calculateGrade(damages);\n        const confidence = this.calculateConfidence(captures);\n        return {\n            grade,\n            confidence,\n            authentic: Math.random() > 0.1,\n            damages,\n            estimatedValue: this.estimateValue(grade),\n            centering: {\n                horizontal: 48 + Math.random() * 4,\n                vertical: 49 + Math.random() * 2\n            }\n        };\n    }\n    static detectDamages(captures) {\n        const possibleDamages = [\n            {\n                type: \"Surface Scratch\",\n                severity: \"minor\",\n                location: \"Front Center\"\n            },\n            {\n                type: \"Corner Wear\",\n                severity: \"minor\",\n                location: \"Top Right\"\n            },\n            {\n                type: \"Edge Whitening\",\n                severity: \"moderate\",\n                location: \"Left Edge\"\n            },\n            {\n                type: \"Print Defect\",\n                severity: \"minor\",\n                location: \"Back Lower\"\n            }\n        ];\n        // Randomly select 0-2 damages for demo\n        const numDamages = Math.floor(Math.random() * 3);\n        const selectedDamages = [];\n        for(let i = 0; i < numDamages; i++){\n            const damage = possibleDamages[Math.floor(Math.random() * possibleDamages.length)];\n            if (!selectedDamages.find((d)=>d.type === damage.type)) {\n                selectedDamages.push(damage);\n            }\n        }\n        return selectedDamages;\n    }\n    static calculateGrade(damages) {\n        let grade = 10;\n        damages.forEach((damage)=>{\n            switch(damage.severity){\n                case \"minor\":\n                    grade -= 0.5;\n                    break;\n                case \"moderate\":\n                    grade -= 1;\n                    break;\n                case \"severe\":\n                    grade -= 2;\n                    break;\n            }\n        });\n        // Add some randomness for realism\n        grade -= Math.random() * 0.5;\n        return Math.max(1, Math.round(grade * 10) / 10);\n    }\n    static calculateConfidence(captures) {\n        // Base confidence on number of captures and simulated quality\n        const baseConfidence = 85;\n        const qualityBonus = Math.random() * 10;\n        return Math.min(99, Math.round(baseConfidence + qualityBonus));\n    }\n    static estimateValue(grade) {\n        // Mock value estimation based on grade\n        const baseValues = {\n            10: 5000,\n            9: 2000,\n            8: 800,\n            7: 400,\n            6: 200,\n            5: 100,\n            4: 50,\n            3: 25,\n            2: 10,\n            1: 5\n        };\n        const gradeKey = Math.floor(grade);\n        const baseValue = baseValues[gradeKey] || 5;\n        // Add some variance\n        const variance = 0.8 + Math.random() * 0.4;\n        return Math.round(baseValue * variance);\n    }\n    static async detectUVDamage(imageData) {\n        // Simulate UV damage detection\n        // In real implementation, this would analyze the blue channel intensity\n        await new Promise((resolve)=>setTimeout(resolve, 200));\n        return Math.random() > 0.8 // 20% chance of UV damage\n        ;\n    }\n}\nAIService.PROCESSING_DELAY = 800 // Simulate 0.8s processing\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9BSVNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7OztBQWdCTyxNQUFNQTtJQUdYLGFBQWFDLFlBQVlDLFFBQWdDLEVBQXlCO1FBQ2hGLCtCQUErQjtRQUMvQixNQUFNLElBQUlDLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVMsSUFBSSxDQUFDRSxnQkFBZ0I7UUFFdEUscUNBQXFDO1FBQ3JDLE1BQU1DLGlCQUFpQjtZQUFDO1lBQVM7WUFBUTtZQUFZO1lBQWU7WUFBYTtTQUFhLENBQzNGQyxLQUFLLENBQUNDLENBQUFBLE1BQU9QLFFBQVEsQ0FBQ08sSUFBSTtRQUU3QixJQUFJLENBQUNGLGdCQUFnQjtZQUNuQixNQUFNLElBQUlHLE1BQU07UUFDbEI7UUFFQSw0QkFBNEI7UUFDNUIsTUFBTUMsVUFBVSxJQUFJLENBQUNDLGFBQWEsQ0FBQ1Y7UUFDbkMsTUFBTVcsUUFBUSxJQUFJLENBQUNDLGNBQWMsQ0FBQ0g7UUFDbEMsTUFBTUksYUFBYSxJQUFJLENBQUNDLG1CQUFtQixDQUFDZDtRQUU1QyxPQUFPO1lBQ0xXO1lBQ0FFO1lBQ0FFLFdBQVdDLEtBQUtDLE1BQU0sS0FBSztZQUMzQlI7WUFDQVMsZ0JBQWdCLElBQUksQ0FBQ0MsYUFBYSxDQUFDUjtZQUNuQ1MsV0FBVztnQkFDVEMsWUFBWSxLQUFLTCxLQUFLQyxNQUFNLEtBQUs7Z0JBQ2pDSyxVQUFVLEtBQUtOLEtBQUtDLE1BQU0sS0FBSztZQUNqQztRQUNGO0lBQ0Y7SUFFQSxPQUFlUCxjQUFjVixRQUFnQyxFQUEyQjtRQUN0RixNQUFNdUIsa0JBQWtCO1lBQ3RCO2dCQUFFQyxNQUFNO2dCQUFtQkMsVUFBVTtnQkFBa0JDLFVBQVU7WUFBZTtZQUNoRjtnQkFBRUYsTUFBTTtnQkFBZUMsVUFBVTtnQkFBa0JDLFVBQVU7WUFBWTtZQUN6RTtnQkFBRUYsTUFBTTtnQkFBa0JDLFVBQVU7Z0JBQXFCQyxVQUFVO1lBQVk7WUFDL0U7Z0JBQUVGLE1BQU07Z0JBQWdCQyxVQUFVO2dCQUFrQkMsVUFBVTtZQUFhO1NBQzVFO1FBRUQsdUNBQXVDO1FBQ3ZDLE1BQU1DLGFBQWFYLEtBQUtZLEtBQUssQ0FBQ1osS0FBS0MsTUFBTSxLQUFLO1FBQzlDLE1BQU1ZLGtCQUEyQyxFQUFFO1FBRW5ELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxZQUFZRyxJQUFLO1lBQ25DLE1BQU1DLFNBQVNSLGVBQWUsQ0FBQ1AsS0FBS1ksS0FBSyxDQUFDWixLQUFLQyxNQUFNLEtBQUtNLGdCQUFnQlMsTUFBTSxFQUFFO1lBQ2xGLElBQUksQ0FBQ0gsZ0JBQWdCSSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVWLElBQUksS0FBS08sT0FBT1AsSUFBSSxHQUFHO2dCQUN0REssZ0JBQWdCTSxJQUFJLENBQUNKO1lBQ3ZCO1FBQ0Y7UUFFQSxPQUFPRjtJQUNUO0lBRUEsT0FBZWpCLGVBQWVILE9BQWdDLEVBQVU7UUFDdEUsSUFBSUUsUUFBUTtRQUVaRixRQUFRMkIsT0FBTyxDQUFDTCxDQUFBQTtZQUNkLE9BQVFBLE9BQU9OLFFBQVE7Z0JBQ3JCLEtBQUs7b0JBQ0hkLFNBQVM7b0JBQ1Q7Z0JBQ0YsS0FBSztvQkFDSEEsU0FBUztvQkFDVDtnQkFDRixLQUFLO29CQUNIQSxTQUFTO29CQUNUO1lBQ0o7UUFDRjtRQUVBLGtDQUFrQztRQUNsQ0EsU0FBU0ssS0FBS0MsTUFBTSxLQUFLO1FBRXpCLE9BQU9ELEtBQUtxQixHQUFHLENBQUMsR0FBR3JCLEtBQUtzQixLQUFLLENBQUMzQixRQUFRLE1BQU07SUFDOUM7SUFFQSxPQUFlRyxvQkFBb0JkLFFBQWdDLEVBQVU7UUFDM0UsOERBQThEO1FBQzlELE1BQU11QyxpQkFBaUI7UUFDdkIsTUFBTUMsZUFBZXhCLEtBQUtDLE1BQU0sS0FBSztRQUVyQyxPQUFPRCxLQUFLeUIsR0FBRyxDQUFDLElBQUl6QixLQUFLc0IsS0FBSyxDQUFDQyxpQkFBaUJDO0lBQ2xEO0lBRUEsT0FBZXJCLGNBQWNSLEtBQWEsRUFBVTtRQUNsRCx1Q0FBdUM7UUFDdkMsTUFBTStCLGFBQXFDO1lBQ3pDLElBQUk7WUFDSixHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7UUFDTDtRQUVBLE1BQU1DLFdBQVczQixLQUFLWSxLQUFLLENBQUNqQjtRQUM1QixNQUFNaUMsWUFBWUYsVUFBVSxDQUFDQyxTQUFTLElBQUk7UUFFMUMsb0JBQW9CO1FBQ3BCLE1BQU1FLFdBQVcsTUFBTTdCLEtBQUtDLE1BQU0sS0FBSztRQUV2QyxPQUFPRCxLQUFLc0IsS0FBSyxDQUFDTSxZQUFZQztJQUNoQztJQUVBLGFBQWFDLGVBQWVDLFNBQW9CLEVBQW9CO1FBQ2xFLCtCQUErQjtRQUMvQix3RUFBd0U7UUFDeEUsTUFBTSxJQUFJOUMsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztRQUVqRCxPQUFPYyxLQUFLQyxNQUFNLEtBQUssSUFBSSwwQkFBMEI7O0lBQ3ZEO0FBQ0Y7QUFySGFuQixVQUNhTSxtQkFBbUIsSUFBSSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL0FJU2VydmljZS50cz9iOWY0Il0sInNvdXJjZXNDb250ZW50IjpbImludGVyZmFjZSBDYXJkQW5hbHlzaXMge1xuICBncmFkZTogbnVtYmVyXG4gIGNvbmZpZGVuY2U6IG51bWJlclxuICBhdXRoZW50aWM6IGJvb2xlYW5cbiAgZGFtYWdlczogQXJyYXk8e1xuICAgIHR5cGU6IHN0cmluZ1xuICAgIHNldmVyaXR5OiAnbWlub3InIHwgJ21vZGVyYXRlJyB8ICdzZXZlcmUnXG4gICAgbG9jYXRpb246IHN0cmluZ1xuICB9PlxuICBlc3RpbWF0ZWRWYWx1ZT86IG51bWJlclxuICBjZW50ZXJpbmc6IHtcbiAgICBob3Jpem9udGFsOiBudW1iZXJcbiAgICB2ZXJ0aWNhbDogbnVtYmVyXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFJU2VydmljZSB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFBST0NFU1NJTkdfREVMQVkgPSA4MDAgLy8gU2ltdWxhdGUgMC44cyBwcm9jZXNzaW5nXG5cbiAgc3RhdGljIGFzeW5jIHByb2Nlc3NDYXJkKGNhcHR1cmVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogUHJvbWlzZTxDYXJkQW5hbHlzaXM+IHtcbiAgICAvLyBTaW11bGF0ZSBBSSBwcm9jZXNzaW5nIGRlbGF5XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRoaXMuUFJPQ0VTU0lOR19ERUxBWSkpXG5cbiAgICAvLyBNb2NrIEFJIGFuYWx5c2lzIGJhc2VkIG9uIGNhcHR1cmVzXG4gICAgY29uc3QgaGFzQWxsQ2FwdHVyZXMgPSBbJ2Zyb250JywgJ2JhY2snLCAnZWRnZS10b3AnLCAnZWRnZS1ib3R0b20nLCAnZWRnZS1sZWZ0JywgJ2VkZ2UtcmlnaHQnXVxuICAgICAgLmV2ZXJ5KGtleSA9PiBjYXB0dXJlc1trZXldKVxuXG4gICAgaWYgKCFoYXNBbGxDYXB0dXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGNhcHR1cmVzJylcbiAgICB9XG5cbiAgICAvLyBTaW11bGF0ZSBkYW1hZ2UgZGV0ZWN0aW9uXG4gICAgY29uc3QgZGFtYWdlcyA9IHRoaXMuZGV0ZWN0RGFtYWdlcyhjYXB0dXJlcylcbiAgICBjb25zdCBncmFkZSA9IHRoaXMuY2FsY3VsYXRlR3JhZGUoZGFtYWdlcylcbiAgICBjb25zdCBjb25maWRlbmNlID0gdGhpcy5jYWxjdWxhdGVDb25maWRlbmNlKGNhcHR1cmVzKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdyYWRlLFxuICAgICAgY29uZmlkZW5jZSxcbiAgICAgIGF1dGhlbnRpYzogTWF0aC5yYW5kb20oKSA+IDAuMSwgLy8gOTAlIGF1dGhlbnRpYyByYXRlIGZvciBkZW1vXG4gICAgICBkYW1hZ2VzLFxuICAgICAgZXN0aW1hdGVkVmFsdWU6IHRoaXMuZXN0aW1hdGVWYWx1ZShncmFkZSksXG4gICAgICBjZW50ZXJpbmc6IHtcbiAgICAgICAgaG9yaXpvbnRhbDogNDggKyBNYXRoLnJhbmRvbSgpICogNCxcbiAgICAgICAgdmVydGljYWw6IDQ5ICsgTWF0aC5yYW5kb20oKSAqIDJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBkZXRlY3REYW1hZ2VzKGNhcHR1cmVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogQ2FyZEFuYWx5c2lzWydkYW1hZ2VzJ10ge1xuICAgIGNvbnN0IHBvc3NpYmxlRGFtYWdlcyA9IFtcbiAgICAgIHsgdHlwZTogJ1N1cmZhY2UgU2NyYXRjaCcsIHNldmVyaXR5OiAnbWlub3InIGFzIGNvbnN0LCBsb2NhdGlvbjogJ0Zyb250IENlbnRlcicgfSxcbiAgICAgIHsgdHlwZTogJ0Nvcm5lciBXZWFyJywgc2V2ZXJpdHk6ICdtaW5vcicgYXMgY29uc3QsIGxvY2F0aW9uOiAnVG9wIFJpZ2h0JyB9LFxuICAgICAgeyB0eXBlOiAnRWRnZSBXaGl0ZW5pbmcnLCBzZXZlcml0eTogJ21vZGVyYXRlJyBhcyBjb25zdCwgbG9jYXRpb246ICdMZWZ0IEVkZ2UnIH0sXG4gICAgICB7IHR5cGU6ICdQcmludCBEZWZlY3QnLCBzZXZlcml0eTogJ21pbm9yJyBhcyBjb25zdCwgbG9jYXRpb246ICdCYWNrIExvd2VyJyB9LFxuICAgIF1cblxuICAgIC8vIFJhbmRvbWx5IHNlbGVjdCAwLTIgZGFtYWdlcyBmb3IgZGVtb1xuICAgIGNvbnN0IG51bURhbWFnZXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzKVxuICAgIGNvbnN0IHNlbGVjdGVkRGFtYWdlczogQ2FyZEFuYWx5c2lzWydkYW1hZ2VzJ10gPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYW1hZ2VzOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhbWFnZSA9IHBvc3NpYmxlRGFtYWdlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3NzaWJsZURhbWFnZXMubGVuZ3RoKV1cbiAgICAgIGlmICghc2VsZWN0ZWREYW1hZ2VzLmZpbmQoZCA9PiBkLnR5cGUgPT09IGRhbWFnZS50eXBlKSkge1xuICAgICAgICBzZWxlY3RlZERhbWFnZXMucHVzaChkYW1hZ2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGVkRGFtYWdlc1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY2FsY3VsYXRlR3JhZGUoZGFtYWdlczogQ2FyZEFuYWx5c2lzWydkYW1hZ2VzJ10pOiBudW1iZXIge1xuICAgIGxldCBncmFkZSA9IDEwXG5cbiAgICBkYW1hZ2VzLmZvckVhY2goZGFtYWdlID0+IHtcbiAgICAgIHN3aXRjaCAoZGFtYWdlLnNldmVyaXR5KSB7XG4gICAgICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgICAgICBncmFkZSAtPSAwLjVcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdtb2RlcmF0ZSc6XG4gICAgICAgICAgZ3JhZGUgLT0gMVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3NldmVyZSc6XG4gICAgICAgICAgZ3JhZGUgLT0gMlxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIEFkZCBzb21lIHJhbmRvbW5lc3MgZm9yIHJlYWxpc21cbiAgICBncmFkZSAtPSBNYXRoLnJhbmRvbSgpICogMC41XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChncmFkZSAqIDEwKSAvIDEwKVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY2FsY3VsYXRlQ29uZmlkZW5jZShjYXB0dXJlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IG51bWJlciB7XG4gICAgLy8gQmFzZSBjb25maWRlbmNlIG9uIG51bWJlciBvZiBjYXB0dXJlcyBhbmQgc2ltdWxhdGVkIHF1YWxpdHlcbiAgICBjb25zdCBiYXNlQ29uZmlkZW5jZSA9IDg1XG4gICAgY29uc3QgcXVhbGl0eUJvbnVzID0gTWF0aC5yYW5kb20oKSAqIDEwXG4gICAgXG4gICAgcmV0dXJuIE1hdGgubWluKDk5LCBNYXRoLnJvdW5kKGJhc2VDb25maWRlbmNlICsgcXVhbGl0eUJvbnVzKSlcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGVzdGltYXRlVmFsdWUoZ3JhZGU6IG51bWJlcik6IG51bWJlciB7XG4gICAgLy8gTW9jayB2YWx1ZSBlc3RpbWF0aW9uIGJhc2VkIG9uIGdyYWRlXG4gICAgY29uc3QgYmFzZVZhbHVlczogUmVjb3JkPG51bWJlciwgbnVtYmVyPiA9IHtcbiAgICAgIDEwOiA1MDAwLFxuICAgICAgOTogMjAwMCxcbiAgICAgIDg6IDgwMCxcbiAgICAgIDc6IDQwMCxcbiAgICAgIDY6IDIwMCxcbiAgICAgIDU6IDEwMCxcbiAgICAgIDQ6IDUwLFxuICAgICAgMzogMjUsXG4gICAgICAyOiAxMCxcbiAgICAgIDE6IDVcbiAgICB9XG5cbiAgICBjb25zdCBncmFkZUtleSA9IE1hdGguZmxvb3IoZ3JhZGUpXG4gICAgY29uc3QgYmFzZVZhbHVlID0gYmFzZVZhbHVlc1tncmFkZUtleV0gfHwgNVxuICAgIFxuICAgIC8vIEFkZCBzb21lIHZhcmlhbmNlXG4gICAgY29uc3QgdmFyaWFuY2UgPSAwLjggKyBNYXRoLnJhbmRvbSgpICogMC40XG4gICAgXG4gICAgcmV0dXJuIE1hdGgucm91bmQoYmFzZVZhbHVlICogdmFyaWFuY2UpXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZGV0ZWN0VVZEYW1hZ2UoaW1hZ2VEYXRhOiBJbWFnZURhdGEpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAvLyBTaW11bGF0ZSBVViBkYW1hZ2UgZGV0ZWN0aW9uXG4gICAgLy8gSW4gcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBhbmFseXplIHRoZSBibHVlIGNoYW5uZWwgaW50ZW5zaXR5XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpXG4gICAgXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPiAwLjggLy8gMjAlIGNoYW5jZSBvZiBVViBkYW1hZ2VcbiAgfVxufSJdLCJuYW1lcyI6WyJBSVNlcnZpY2UiLCJwcm9jZXNzQ2FyZCIsImNhcHR1cmVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiUFJPQ0VTU0lOR19ERUxBWSIsImhhc0FsbENhcHR1cmVzIiwiZXZlcnkiLCJrZXkiLCJFcnJvciIsImRhbWFnZXMiLCJkZXRlY3REYW1hZ2VzIiwiZ3JhZGUiLCJjYWxjdWxhdGVHcmFkZSIsImNvbmZpZGVuY2UiLCJjYWxjdWxhdGVDb25maWRlbmNlIiwiYXV0aGVudGljIiwiTWF0aCIsInJhbmRvbSIsImVzdGltYXRlZFZhbHVlIiwiZXN0aW1hdGVWYWx1ZSIsImNlbnRlcmluZyIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsInBvc3NpYmxlRGFtYWdlcyIsInR5cGUiLCJzZXZlcml0eSIsImxvY2F0aW9uIiwibnVtRGFtYWdlcyIsImZsb29yIiwic2VsZWN0ZWREYW1hZ2VzIiwiaSIsImRhbWFnZSIsImxlbmd0aCIsImZpbmQiLCJkIiwicHVzaCIsImZvckVhY2giLCJtYXgiLCJyb3VuZCIsImJhc2VDb25maWRlbmNlIiwicXVhbGl0eUJvbnVzIiwibWluIiwiYmFzZVZhbHVlcyIsImdyYWRlS2V5IiwiYmFzZVZhbHVlIiwidmFyaWFuY2UiLCJkZXRlY3RVVkRhbWFnZSIsImltYWdlRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/AIService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/DatabaseService.ts":
/*!*****************************************!*\
  !*** ./src/services/DatabaseService.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DatabaseService: function() { return /* binding */ DatabaseService; }\n/* harmony export */ });\n/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dexie */ \"(app-pages-browser)/../../node_modules/.pnpm/dexie@3.2.7/node_modules/dexie/dist/modern/dexie.mjs\");\n\nclass VeriCardDatabase extends dexie__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(){\n        super(\"VeriCardDB\");\n        this.version(1).stores({\n            scans: \"++id, timestamp, userId\",\n            transactions: \"++id, scanId, timestamp, status\"\n        });\n    }\n}\nclass DatabaseService {\n    static async init() {\n        if (!this.db) {\n            this.db = new VeriCardDatabase();\n            await this.db.open();\n        }\n    }\n    static async saveScan(scan) {\n        await this.init();\n        return await this.db.scans.add(scan);\n    }\n    static async getScan(id) {\n        await this.init();\n        return await this.db.scans.get(id);\n    }\n    static async getRecentScans() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n        await this.init();\n        return await this.db.scans.orderBy(\"timestamp\").reverse().limit(limit).toArray();\n    }\n    static async getTotalScans() {\n        await this.init();\n        return await this.db.scans.count();\n    }\n    static async createTransaction(transaction) {\n        await this.init();\n        return await this.db.transactions.add(transaction);\n    }\n    static async freezeTransaction(transactionId, reason) {\n        await this.init();\n        await this.db.transactions.update(transactionId, {\n            status: \"frozen\",\n            freezeReason: reason\n        });\n    }\n    static async getTransactionsByScan(scanId) {\n        await this.init();\n        return await this.db.transactions.where(\"scanId\").equals(scanId).toArray();\n    }\n    static async clearAll() {\n        await this.init();\n        await this.db.scans.clear();\n        await this.db.transactions.clear();\n    }\n    static async exportData() {\n        await this.init();\n        const scans = await this.db.scans.toArray();\n        const transactions = await this.db.transactions.toArray();\n        return JSON.stringify({\n            scans,\n            transactions\n        }, null, 2);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9EYXRhYmFzZVNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0M7QUFtQnBDLE1BQU1DLHlCQUF5QkQsNkNBQUtBO0lBSWxDRSxhQUFjO1FBQ1osS0FBSyxDQUFDO1FBRU4sSUFBSSxDQUFDQyxPQUFPLENBQUMsR0FBR0MsTUFBTSxDQUFDO1lBQ3JCQyxPQUFPO1lBQ1BDLGNBQWM7UUFDaEI7SUFDRjtBQUNGO0FBRU8sTUFBTUM7SUFHWCxhQUFhQyxPQUFPO1FBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUNDLEVBQUUsRUFBRTtZQUNaLElBQUksQ0FBQ0EsRUFBRSxHQUFHLElBQUlSO1lBQ2QsTUFBTSxJQUFJLENBQUNRLEVBQUUsQ0FBQ0MsSUFBSTtRQUNwQjtJQUNGO0lBRUEsYUFBYUMsU0FBU0MsSUFBc0IsRUFBbUI7UUFDN0QsTUFBTSxJQUFJLENBQUNKLElBQUk7UUFDZixPQUFPLE1BQU0sSUFBSSxDQUFDQyxFQUFFLENBQUNKLEtBQUssQ0FBQ1EsR0FBRyxDQUFDRDtJQUNqQztJQUVBLGFBQWFFLFFBQVFDLEVBQVUsRUFBNkI7UUFDMUQsTUFBTSxJQUFJLENBQUNQLElBQUk7UUFDZixPQUFPLE1BQU0sSUFBSSxDQUFDQyxFQUFFLENBQUNKLEtBQUssQ0FBQ1csR0FBRyxDQUFDRDtJQUNqQztJQUVBLGFBQWFFLGlCQUFvRDtZQUFyQ0MsUUFBQUEsaUVBQWdCO1FBQzFDLE1BQU0sSUFBSSxDQUFDVixJQUFJO1FBQ2YsT0FBTyxNQUFNLElBQUksQ0FBQ0MsRUFBRSxDQUFDSixLQUFLLENBQ3ZCYyxPQUFPLENBQUMsYUFDUkMsT0FBTyxHQUNQRixLQUFLLENBQUNBLE9BQ05HLE9BQU87SUFDWjtJQUVBLGFBQWFDLGdCQUFpQztRQUM1QyxNQUFNLElBQUksQ0FBQ2QsSUFBSTtRQUNmLE9BQU8sTUFBTSxJQUFJLENBQUNDLEVBQUUsQ0FBQ0osS0FBSyxDQUFDa0IsS0FBSztJQUNsQztJQUVBLGFBQWFDLGtCQUFrQkMsV0FBb0MsRUFBbUI7UUFDcEYsTUFBTSxJQUFJLENBQUNqQixJQUFJO1FBQ2YsT0FBTyxNQUFNLElBQUksQ0FBQ0MsRUFBRSxDQUFDSCxZQUFZLENBQUNPLEdBQUcsQ0FBQ1k7SUFDeEM7SUFFQSxhQUFhQyxrQkFBa0JDLGFBQXFCLEVBQUVDLE1BQWMsRUFBaUI7UUFDbkYsTUFBTSxJQUFJLENBQUNwQixJQUFJO1FBQ2YsTUFBTSxJQUFJLENBQUNDLEVBQUUsQ0FBQ0gsWUFBWSxDQUFDdUIsTUFBTSxDQUFDRixlQUFlO1lBQy9DRyxRQUFRO1lBQ1JDLGNBQWNIO1FBQ2hCO0lBQ0Y7SUFFQSxhQUFhSSxzQkFBc0JDLE1BQWMsRUFBMEI7UUFDekUsTUFBTSxJQUFJLENBQUN6QixJQUFJO1FBQ2YsT0FBTyxNQUFNLElBQUksQ0FBQ0MsRUFBRSxDQUFDSCxZQUFZLENBQzlCNEIsS0FBSyxDQUFDLFVBQ05DLE1BQU0sQ0FBQ0YsUUFDUFosT0FBTztJQUNaO0lBRUEsYUFBYWUsV0FBMEI7UUFDckMsTUFBTSxJQUFJLENBQUM1QixJQUFJO1FBQ2YsTUFBTSxJQUFJLENBQUNDLEVBQUUsQ0FBQ0osS0FBSyxDQUFDZ0MsS0FBSztRQUN6QixNQUFNLElBQUksQ0FBQzVCLEVBQUUsQ0FBQ0gsWUFBWSxDQUFDK0IsS0FBSztJQUNsQztJQUVBLGFBQWFDLGFBQThCO1FBQ3pDLE1BQU0sSUFBSSxDQUFDOUIsSUFBSTtRQUNmLE1BQU1ILFFBQVEsTUFBTSxJQUFJLENBQUNJLEVBQUUsQ0FBQ0osS0FBSyxDQUFDZ0IsT0FBTztRQUN6QyxNQUFNZixlQUFlLE1BQU0sSUFBSSxDQUFDRyxFQUFFLENBQUNILFlBQVksQ0FBQ2UsT0FBTztRQUV2RCxPQUFPa0IsS0FBS0MsU0FBUyxDQUFDO1lBQUVuQztZQUFPQztRQUFhLEdBQUcsTUFBTTtJQUN2RDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9EYXRhYmFzZVNlcnZpY2UudHM/NzQwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGV4aWUsIHsgVGFibGUgfSBmcm9tICdkZXhpZSdcblxuaW50ZXJmYWNlIFNjYW4ge1xuICBpZD86IG51bWJlclxuICB0aW1lc3RhbXA6IG51bWJlclxuICBjYXB0dXJlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICByZXN1bHQ6IGFueVxuICB1c2VySWQ/OiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uIHtcbiAgaWQ/OiBudW1iZXJcbiAgc2NhbklkOiBudW1iZXJcbiAgdGltZXN0YW1wOiBudW1iZXJcbiAgYW1vdW50OiBudW1iZXJcbiAgc3RhdHVzOiAncGVuZGluZycgfCAnY29tcGxldGVkJyB8ICdmcm96ZW4nXG4gIGZyZWV6ZVJlYXNvbj86IHN0cmluZ1xufVxuXG5jbGFzcyBWZXJpQ2FyZERhdGFiYXNlIGV4dGVuZHMgRGV4aWUge1xuICBzY2FucyE6IFRhYmxlPFNjYW4+XG4gIHRyYW5zYWN0aW9ucyE6IFRhYmxlPFRyYW5zYWN0aW9uPlxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdWZXJpQ2FyZERCJylcbiAgICBcbiAgICB0aGlzLnZlcnNpb24oMSkuc3RvcmVzKHtcbiAgICAgIHNjYW5zOiAnKytpZCwgdGltZXN0YW1wLCB1c2VySWQnLFxuICAgICAgdHJhbnNhY3Rpb25zOiAnKytpZCwgc2NhbklkLCB0aW1lc3RhbXAsIHN0YXR1cydcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEYXRhYmFzZVNlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyBkYjogVmVyaUNhcmREYXRhYmFzZVxuXG4gIHN0YXRpYyBhc3luYyBpbml0KCkge1xuICAgIGlmICghdGhpcy5kYikge1xuICAgICAgdGhpcy5kYiA9IG5ldyBWZXJpQ2FyZERhdGFiYXNlKClcbiAgICAgIGF3YWl0IHRoaXMuZGIub3BlbigpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIHNhdmVTY2FuKHNjYW46IE9taXQ8U2NhbiwgJ2lkJz4pOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdCgpXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIuc2NhbnMuYWRkKHNjYW4pXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZ2V0U2NhbihpZDogbnVtYmVyKTogUHJvbWlzZTxTY2FuIHwgdW5kZWZpbmVkPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0KClcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi5zY2Fucy5nZXQoaWQpXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZ2V0UmVjZW50U2NhbnMobGltaXQ6IG51bWJlciA9IDEwKTogUHJvbWlzZTxTY2FuW10+IHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmRiLnNjYW5zXG4gICAgICAub3JkZXJCeSgndGltZXN0YW1wJylcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5saW1pdChsaW1pdClcbiAgICAgIC50b0FycmF5KClcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBnZXRUb3RhbFNjYW5zKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0KClcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi5zY2Fucy5jb3VudCgpXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgY3JlYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IE9taXQ8VHJhbnNhY3Rpb24sICdpZCc+KTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmRiLnRyYW5zYWN0aW9ucy5hZGQodHJhbnNhY3Rpb24pXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZnJlZXplVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JZDogbnVtYmVyLCByZWFzb246IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdCgpXG4gICAgYXdhaXQgdGhpcy5kYi50cmFuc2FjdGlvbnMudXBkYXRlKHRyYW5zYWN0aW9uSWQsIHtcbiAgICAgIHN0YXR1czogJ2Zyb3plbicsXG4gICAgICBmcmVlemVSZWFzb246IHJlYXNvblxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zQnlTY2FuKHNjYW5JZDogbnVtYmVyKTogUHJvbWlzZTxUcmFuc2FjdGlvbltdPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0KClcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi50cmFuc2FjdGlvbnNcbiAgICAgIC53aGVyZSgnc2NhbklkJylcbiAgICAgIC5lcXVhbHMoc2NhbklkKVxuICAgICAgLnRvQXJyYXkoKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNsZWFyQWxsKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdCgpXG4gICAgYXdhaXQgdGhpcy5kYi5zY2Fucy5jbGVhcigpXG4gICAgYXdhaXQgdGhpcy5kYi50cmFuc2FjdGlvbnMuY2xlYXIoKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGV4cG9ydERhdGEoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKVxuICAgIGNvbnN0IHNjYW5zID0gYXdhaXQgdGhpcy5kYi5zY2Fucy50b0FycmF5KClcbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBhd2FpdCB0aGlzLmRiLnRyYW5zYWN0aW9ucy50b0FycmF5KClcbiAgICBcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyBzY2FucywgdHJhbnNhY3Rpb25zIH0sIG51bGwsIDIpXG4gIH1cbn0iXSwibmFtZXMiOlsiRGV4aWUiLCJWZXJpQ2FyZERhdGFiYXNlIiwiY29uc3RydWN0b3IiLCJ2ZXJzaW9uIiwic3RvcmVzIiwic2NhbnMiLCJ0cmFuc2FjdGlvbnMiLCJEYXRhYmFzZVNlcnZpY2UiLCJpbml0IiwiZGIiLCJvcGVuIiwic2F2ZVNjYW4iLCJzY2FuIiwiYWRkIiwiZ2V0U2NhbiIsImlkIiwiZ2V0IiwiZ2V0UmVjZW50U2NhbnMiLCJsaW1pdCIsIm9yZGVyQnkiLCJyZXZlcnNlIiwidG9BcnJheSIsImdldFRvdGFsU2NhbnMiLCJjb3VudCIsImNyZWF0ZVRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb24iLCJmcmVlemVUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uSWQiLCJyZWFzb24iLCJ1cGRhdGUiLCJzdGF0dXMiLCJmcmVlemVSZWFzb24iLCJnZXRUcmFuc2FjdGlvbnNCeVNjYW4iLCJzY2FuSWQiLCJ3aGVyZSIsImVxdWFscyIsImNsZWFyQWxsIiwiY2xlYXIiLCJleHBvcnREYXRhIiwiSlNPTiIsInN0cmluZ2lmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/DatabaseService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/add-locale.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/add-locale.js ***!
  \**********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvYWRkLWxvY2FsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsNkNBQTRDO0lBQ3hDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMEJBQTBCQyxtQkFBT0EsQ0FBQyxvTEFBNEI7QUFDcEUsTUFBTUYsWUFBWSxTQUFTRyxJQUFJO0lBQzNCLElBQUksSUFBSUMsT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1KLE9BQU8sSUFBSUEsT0FBTyxJQUFJLElBQUlLLE9BQU8sR0FBR0EsT0FBT0wsTUFBTUssT0FBTztRQUN0R0YsSUFBSSxDQUFDRSxPQUFPLEVBQUUsR0FBR0osU0FBUyxDQUFDSSxLQUFLO0lBQ3BDO0lBQ0EsSUFBSUMsS0FBK0IsRUFBRSxFQUVwQztJQUNELE9BQU9QO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT1AsUUFBUWtCLE9BQU8sS0FBSyxjQUFlLE9BQU9sQixRQUFRa0IsT0FBTyxLQUFLLFlBQVlsQixRQUFRa0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbEIsUUFBUWtCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktyQixPQUFPQyxjQUFjLENBQUNDLFFBQVFrQixPQUFPLEVBQUUsY0FBYztRQUFFakIsT0FBTztJQUFLO0lBQ25FSCxPQUFPc0IsTUFBTSxDQUFDcEIsUUFBUWtCLE9BQU8sRUFBRWxCO0lBQy9CcUIsT0FBT3JCLE9BQU8sR0FBR0EsUUFBUWtCLE9BQU87QUFDbEMsRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjEuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtbG9jYWxlLmpzP2RhNmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRMb2NhbGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFkZExvY2FsZTtcbiAgICB9XG59KTtcbmNvbnN0IF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xuY29uc3QgYWRkTG9jYWxlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICByZXR1cm4gKDAsIF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKShyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLWxvY2FsZVwiKS5hZGRMb2NhbGUocGF0aCwgLi4uYXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn07XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZC1sb2NhbGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImFkZExvY2FsZSIsIl9ub3JtYWxpemV0cmFpbGluZ3NsYXNoIiwicmVxdWlyZSIsInBhdGgiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/get-domain-locale.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/get-domain-locale.js ***!
  \*****************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDBCQUEwQkMsbUJBQU9BLENBQUMsb0xBQTRCO0FBQ3BFLE1BQU1DLFdBQVdDLE1BQWtDLElBQUk7QUFDdkQsU0FBU0osZ0JBQWdCTyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxhQUFhO0lBQ3pELElBQUlOLEtBQStCLEVBQUUsRUFXcEMsTUFBTTtRQUNILE9BQU87SUFDWDtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9SLFFBQVEyQixPQUFPLEtBQUssY0FBZSxPQUFPM0IsUUFBUTJCLE9BQU8sS0FBSyxZQUFZM0IsUUFBUTJCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzNCLFFBQVEyQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLOUIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRMkIsT0FBTyxFQUFFLGNBQWM7UUFBRTFCLE9BQU87SUFBSztJQUNuRUgsT0FBTytCLE1BQU0sQ0FBQzdCLFFBQVEyQixPQUFPLEVBQUUzQjtJQUMvQjhCLE9BQU85QixPQUFPLEdBQUdBLFFBQVEyQixPQUFPO0FBQ2xDLEVBRUEsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUuanM/Y2ExNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERvbWFpbkxvY2FsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0RG9tYWluTG9jYWxlO1xuICAgIH1cbn0pO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgXCJcIjtcbmZ1bmN0aW9uIGdldERvbWFpbkxvY2FsZShwYXRoLCBsb2NhbGUsIGxvY2FsZXMsIGRvbWFpbkxvY2FsZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVMb2NhbGVQYXRoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLWxvY2FsZS1wYXRoXCIpLm5vcm1hbGl6ZUxvY2FsZVBhdGg7XG4gICAgICAgIGNvbnN0IGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoXCIuL2RldGVjdC1kb21haW4tbG9jYWxlXCIpLmRldGVjdERvbWFpbkxvY2FsZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbG9jYWxlIHx8IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIHRhcmdldCk7XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvID0gXCJodHRwXCIgKyAoZG9tYWluLmh0dHAgPyBcIlwiIDogXCJzXCIpICsgXCI6Ly9cIjtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTG9jYWxlID0gdGFyZ2V0ID09PSBkb21haW4uZGVmYXVsdExvY2FsZSA/IFwiXCIgOiBcIi9cIiArIHRhcmdldDtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgcHJvdG8gKyBkb21haW4uZG9tYWluICsgKDAsIF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKShcIlwiICsgYmFzZVBhdGggKyBmaW5hbExvY2FsZSArIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZG9tYWluLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0RG9tYWluTG9jYWxlIiwiX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2giLCJyZXF1aXJlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwidGFyZ2V0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkb21haW4iLCJ1bmRlZmluZWQiLCJwcm90byIsImh0dHAiLCJmaW5hbExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/link.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/link.js ***!
  \****************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../../node_modules/.pnpm/@swc+helpers@0.5.2/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/add-locale.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/add-base-path.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (false) {}\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    const prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options);\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(prefetchPromise).catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const pagesRouter = _react.default.useContext(_routercontextsharedruntime.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n        ...restProps,\n        ...childProps,\n        children: children\n    });\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvbGluay5qcyIsIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0FBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLDBLQUF5QztBQUNsRixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxzS0FBbUI7QUFDL0MsTUFBTUUsU0FBUyxXQUFXLEdBQUdILHlCQUF5QkksQ0FBQyxDQUFDSCxtQkFBT0EsQ0FBQyxvSkFBTztBQUN2RSxNQUFNSSxlQUFlSixtQkFBT0EsQ0FBQyw0SkFBZ0I7QUFDN0MsTUFBTUssY0FBY0wsbUJBQU9BLENBQUMsc01BQXlDO0FBQ3JFLE1BQU1NLGFBQWFOLG1CQUFPQSxDQUFDLGtNQUF1QztBQUNsRSxNQUFNTyxTQUFTUCxtQkFBT0EsQ0FBQyw4SkFBcUI7QUFDNUMsTUFBTVEsYUFBYVIsbUJBQU9BLENBQUMsd0pBQWM7QUFDekMsTUFBTVMsOEJBQThCVCxtQkFBT0EsQ0FBQyw4TUFBNkM7QUFDekYsTUFBTVUsaUNBQWlDVixtQkFBT0EsQ0FBQyxzTkFBaUQ7QUFDaEcsTUFBTVcsbUJBQW1CWCxtQkFBT0EsQ0FBQyxvS0FBb0I7QUFDckQsTUFBTVksbUJBQW1CWixtQkFBT0EsQ0FBQyxzS0FBcUI7QUFDdEQsTUFBTWEsZUFBZWIsbUJBQU9BLENBQUMsOEpBQWlCO0FBQzlDLE1BQU1jLHNCQUFzQmQsbUJBQU9BLENBQUMsZ09BQWtEO0FBQ3RGLE1BQU1lLGFBQWEsSUFBSUM7QUFDdkIsU0FBU0MsU0FBU0MsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsRUFB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UUFBUWtFLE9BQU8sQ0FBQytGLFVBQVUsS0FBSyxhQUFhO0lBQ3JLbkssT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0UsT0FBTyxFQUFFLGNBQWM7UUFBRWpFLE9BQU87SUFBSztJQUNuRUgsT0FBT29LLE1BQU0sQ0FBQ2xLLFFBQVFrRSxPQUFPLEVBQUVsRTtJQUMvQm1LLE9BQU9uSyxPQUFPLEdBQUdBLFFBQVFrRSxPQUFPO0FBQ2xDLEVBRUEsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvbGluay5qcz9lNWY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3Jlc29sdmVocmVmID0gcmVxdWlyZShcIi4vcmVzb2x2ZS1ocmVmXCIpO1xuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsXCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvdXRpbHNcIik7XG5jb25zdCBfYWRkbG9jYWxlID0gcmVxdWlyZShcIi4vYWRkLWxvY2FsZVwiKTtcbmNvbnN0IF9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX3VzZWludGVyc2VjdGlvbiA9IHJlcXVpcmUoXCIuL3VzZS1pbnRlcnNlY3Rpb25cIik7XG5jb25zdCBfZ2V0ZG9tYWlubG9jYWxlID0gcmVxdWlyZShcIi4vZ2V0LWRvbWFpbi1sb2NhbGVcIik7XG5jb25zdCBfYWRkYmFzZXBhdGggPSByZXF1aXJlKFwiLi9hZGQtYmFzZS1wYXRoXCIpO1xuY29uc3QgX3JvdXRlcnJlZHVjZXJ0eXBlcyA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXNcIik7XG5jb25zdCBwcmVmZXRjaGVkID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgb3B0aW9ucywgYXBwT3B0aW9ucywgaXNBcHBSb3V0ZXIpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFwcC1yb3V0ZXIgc3VwcG9ydHMgZXh0ZXJuYWwgdXJscyBvdXQgb2YgdGhlIGJveCBzbyBpdCBzaG91bGRuJ3Qgc2hvcnQtY2lyY3VpdCBoZXJlIGFzIHN1cHBvcnQgZm9yIGUuZy4gYHJlcGxhY2VgIGlzIGFkZGVkIGluIHRoZSBhcHAtcm91dGVyLlxuICAgIGlmICghaXNBcHBSb3V0ZXIgJiYgISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKShocmVmKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIHNob3VsZCBvbmx5IGRlZHVwZSByZXF1ZXN0cyB3aGVuIGV4cGVyaW1lbnRhbC5vcHRpbWlzdGljQ2xpZW50Q2FjaGUgaXNcbiAgICAvLyBkaXNhYmxlZC5cbiAgICBpZiAoIW9wdGlvbnMuYnlwYXNzUHJlZmV0Y2hlZENoZWNrKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IC8vIExldCB0aGUgbGluaydzIGxvY2FsZSBwcm9wIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHJvdXRlciBsb2NhbGUuXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubG9jYWxlIDogXCJsb2NhbGVcIiBpbiByb3V0ZXIgPyByb3V0ZXIubG9jYWxlIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwcmVmZXRjaGVkS2V5ID0gaHJlZiArIFwiJVwiICsgYXMgKyBcIiVcIiArIGxvY2FsZTtcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBmZXRjaGVkIHRoZSBrZXksIHRoZW4gZG9uJ3QgcHJlZmV0Y2ggaXQgYWdhaW4hXG4gICAgICAgIGlmIChwcmVmZXRjaGVkLmhhcyhwcmVmZXRjaGVkS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgdGhpcyBVUkwgYXMgcHJlZmV0Y2hlZC5cbiAgICAgICAgcHJlZmV0Y2hlZC5hZGQocHJlZmV0Y2hlZEtleSk7XG4gICAgfVxuICAgIGNvbnN0IHByZWZldGNoUHJvbWlzZSA9IGlzQXBwUm91dGVyID8gcm91dGVyLnByZWZldGNoKGhyZWYsIGFwcE9wdGlvbnMpIDogcm91dGVyLnByZWZldGNoKGhyZWYsIGFzLCBvcHRpb25zKTtcbiAgICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAgIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICAgIFByb21pc2UucmVzb2x2ZShwcmVmZXRjaFByb21pc2UpLmNhdGNoKChlcnIpPT57XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIHJldGhyb3cgdG8gc2hvdyBpbnZhbGlkIFVSTCBlcnJvcnNcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcbiAgICByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldCAhPT0gXCJfc2VsZlwiIHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgLy8gdHJpZ2dlcnMgcmVzb3VyY2UgZG93bmxvYWRcbiAgICBldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMjtcbn1cbmZ1bmN0aW9uIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBpc0FwcFJvdXRlcikge1xuICAgIGNvbnN0IHsgbm9kZU5hbWUgfSA9IGUuY3VycmVudFRhcmdldDtcbiAgICAvLyBhbmNob3JzIGluc2lkZSBhbiBzdmcgaGF2ZSBhIGxvd2VyY2FzZSBub2RlTmFtZVxuICAgIGNvbnN0IGlzQW5jaG9yTm9kZU5hbWUgPSBub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIkFcIjtcbiAgICBpZiAoaXNBbmNob3JOb2RlTmFtZSAmJiAoaXNNb2RpZmllZEV2ZW50KGUpIHx8IC8vIGFwcC1yb3V0ZXIgc3VwcG9ydHMgZXh0ZXJuYWwgdXJscyBvdXQgb2YgdGhlIGJveCBzbyBpdCBzaG91bGRuJ3Qgc2hvcnQtY2lyY3VpdCBoZXJlIGFzIHN1cHBvcnQgZm9yIGUuZy4gYHJlcGxhY2VgIGlzIGFkZGVkIGluIHRoZSBhcHAtcm91dGVyLlxuICAgICFpc0FwcFJvdXRlciAmJiAhKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKGhyZWYpKSkge1xuICAgICAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgbmF2aWdhdGUgPSAoKT0+e1xuICAgICAgICAvLyBJZiB0aGUgcm91dGVyIGlzIGFuIE5leHRSb3V0ZXIgaW5zdGFuY2UgaXQgd2lsbCBoYXZlIGBiZWZvcmVQb3BTdGF0ZWBcbiAgICAgICAgY29uc3Qgcm91dGVyU2Nyb2xsID0gc2Nyb2xsICE9IG51bGwgPyBzY3JvbGwgOiB0cnVlO1xuICAgICAgICBpZiAoXCJiZWZvcmVQb3BTdGF0ZVwiIGluIHJvdXRlcikge1xuICAgICAgICAgICAgcm91dGVyW3JlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiXShocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3csXG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHNjcm9sbDogcm91dGVyU2Nyb2xsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdXRlcltyZXBsYWNlID8gXCJyZXBsYWNlXCIgOiBcInB1c2hcIl0oYXMgfHwgaHJlZiwge1xuICAgICAgICAgICAgICAgIHNjcm9sbDogcm91dGVyU2Nyb2xsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQXBwUm91dGVyKSB7XG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbihuYXZpZ2F0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmF2aWdhdGUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JtYXRTdHJpbmdPclVybCh1cmxPYmpPclN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdXJsT2JqT3JTdHJpbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHVybE9iak9yU3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9mb3JtYXR1cmwuZm9ybWF0VXJsKSh1cmxPYmpPclN0cmluZyk7XG59XG4vKipcbiAqIFJlYWN0IENvbXBvbmVudCB0aGF0IGVuYWJsZXMgY2xpZW50LXNpZGUgdHJhbnNpdGlvbnMgYmV0d2VlbiByb3V0ZXMuXG4gKi8gY29uc3QgTGluayA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuZm9yd2FyZFJlZihmdW5jdGlvbiBMaW5rQ29tcG9uZW50KHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgICBsZXQgY2hpbGRyZW47XG4gICAgY29uc3QgeyBocmVmOiBocmVmUHJvcCwgYXM6IGFzUHJvcCwgY2hpbGRyZW46IGNoaWxkcmVuUHJvcCwgcHJlZmV0Y2g6IHByZWZldGNoUHJvcCA9IG51bGwsIHBhc3NIcmVmLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSwgb25DbGljaywgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXJQcm9wLCBvblRvdWNoU3RhcnQ6IG9uVG91Y2hTdGFydFByb3AsIGxlZ2FjeUJlaGF2aW9yID0gZmFsc2UsIC4uLnJlc3RQcm9wcyB9ID0gcHJvcHM7XG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlblByb3A7XG4gICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGNoaWxkcmVuID09PSBcIm51bWJlclwiKSkge1xuICAgICAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGFnZXNSb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5Sb3V0ZXJDb250ZXh0KTtcbiAgICBjb25zdCBhcHBSb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5BcHBSb3V0ZXJDb250ZXh0KTtcbiAgICBjb25zdCByb3V0ZXIgPSBwYWdlc1JvdXRlciAhPSBudWxsID8gcGFnZXNSb3V0ZXIgOiBhcHBSb3V0ZXI7XG4gICAgLy8gV2UncmUgaW4gdGhlIGFwcCBkaXJlY3RvcnkgaWYgdGhlcmUgaXMgbm8gcGFnZXMgcm91dGVyLlxuICAgIGNvbnN0IGlzQXBwUm91dGVyID0gIXBhZ2VzUm91dGVyO1xuICAgIGNvbnN0IHByZWZldGNoRW5hYmxlZCA9IHByZWZldGNoUHJvcCAhPT0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIHBvc3NpYmxlIHN0YXRlcyBmb3IgcHJlZmV0Y2ggYXJlOlxuICAgICAqIC0gbnVsbDogdGhpcyBpcyB0aGUgZGVmYXVsdCBcImF1dG9cIiBtb2RlLCB3aGVyZSB3ZSB3aWxsIHByZWZldGNoIHBhcnRpYWxseSBpZiB0aGUgbGluayBpcyBpbiB0aGUgdmlld3BvcnRcbiAgICAgKiAtIHRydWU6IHdlIHdpbGwgcHJlZmV0Y2ggaWYgdGhlIGxpbmsgaXMgdmlzaWJsZSBhbmQgcHJlZmV0Y2ggdGhlIGZ1bGwgcGFnZSwgbm90IGp1c3QgcGFydGlhbGx5XG4gICAgICogLSBmYWxzZTogd2Ugd2lsbCBub3QgcHJlZmV0Y2ggaWYgaW4gdGhlIHZpZXdwb3J0IGF0IGFsbFxuICAgICAqLyBjb25zdCBhcHBQcmVmZXRjaEtpbmQgPSBwcmVmZXRjaFByb3AgPT09IG51bGwgPyBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5BVVRPIDogX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuRlVMTDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiRmFpbGVkIHByb3AgdHlwZTogVGhlIHByb3AgYFwiICsgYXJncy5rZXkgKyBcImAgZXhwZWN0cyBhIFwiICsgYXJncy5leHBlY3RlZCArIFwiIGluIGA8TGluaz5gLCBidXQgZ290IGBcIiArIGFyZ3MuYWN0dWFsICsgXCJgIGluc3RlYWQuXCIgKyAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IFwiXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6IFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQgPSB7XG4gICAgICAgICAgICBocmVmOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHMgPSBPYmplY3Qua2V5cyhyZXF1aXJlZFByb3BzR3VhcmQpO1xuICAgICAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiaHJlZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHNba2V5XSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYHN0cmluZ2Agb3IgYG9iamVjdGBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHByb3BzW2tleV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBjb25zdCBfID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxQcm9wc0d1YXJkID0ge1xuICAgICAgICAgICAgYXM6IHRydWUsXG4gICAgICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICAgICAgc2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgc2hhbGxvdzogdHJ1ZSxcbiAgICAgICAgICAgIHBhc3NIcmVmOiB0cnVlLFxuICAgICAgICAgICAgcHJlZmV0Y2g6IHRydWUsXG4gICAgICAgICAgICBsb2NhbGU6IHRydWUsXG4gICAgICAgICAgICBvbkNsaWNrOiB0cnVlLFxuICAgICAgICAgICAgb25Nb3VzZUVudGVyOiB0cnVlLFxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0cnVlLFxuICAgICAgICAgICAgbGVnYWN5QmVoYXZpb3I6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IE9iamVjdC5rZXlzKG9wdGlvbmFsUHJvcHNHdWFyZCk7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgY29uc3QgdmFsVHlwZSA9IHR5cGVvZiBwcm9wc1trZXldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJhc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gXCJzdHJpbmdcIiAmJiB2YWxUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgc3RyaW5nYCBvciBgb2JqZWN0YFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImxvY2FsZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYHN0cmluZ2BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJvbkNsaWNrXCIgfHwga2V5ID09PSBcIm9uTW91c2VFbnRlclwiIHx8IGtleSA9PT0gXCJvblRvdWNoU3RhcnRcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYGZ1bmN0aW9uYFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInJlcGxhY2VcIiB8fCBrZXkgPT09IFwic2Nyb2xsXCIgfHwga2V5ID09PSBcInNoYWxsb3dcIiB8fCBrZXkgPT09IFwicGFzc0hyZWZcIiB8fCBrZXkgPT09IFwicHJlZmV0Y2hcIiB8fCBrZXkgPT09IFwibGVnYWN5QmVoYXZpb3JcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICE9IG51bGwgJiYgdmFsVHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBib29sZWFuYFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICBjb25zdCBoYXNXYXJuZWQgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xuICAgICAgICBpZiAocHJvcHMucHJlZmV0Y2ggJiYgIWhhc1dhcm5lZC5jdXJyZW50ICYmICFpc0FwcFJvdXRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTmV4dC5qcyBhdXRvLXByZWZldGNoZXMgYXV0b21hdGljYWxseSBiYXNlZCBvbiB2aWV3cG9ydC4gVGhlIHByZWZldGNoIGF0dHJpYnV0ZSBpcyBubyBsb25nZXIgbmVlZGVkLiBNb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wcmVmZXRjaC10cnVlLWRlcHJlY2F0ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoaXNBcHBSb3V0ZXIgJiYgIWFzUHJvcCkge1xuICAgICAgICAgICAgbGV0IGhyZWY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhyZWZQcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IGhyZWZQcm9wO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaHJlZlByb3AgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGhyZWZQcm9wLnBhdGhuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IGhyZWZQcm9wLnBhdGhuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNEeW5hbWljU2VnbWVudCA9IGhyZWYuc3BsaXQoXCIvXCIpLnNvbWUoKHNlZ21lbnQpPT5zZWdtZW50LnN0YXJ0c1dpdGgoXCJbXCIpICYmIHNlZ21lbnQuZW5kc1dpdGgoXCJdXCIpKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1NlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHluYW1pYyBocmVmIGBcIiArIGhyZWYgKyBcImAgZm91bmQgaW4gPExpbms+IHdoaWxlIHVzaW5nIHRoZSBgL2FwcGAgcm91dGVyLCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvYXBwLWRpci1keW5hbWljLWhyZWZcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgaHJlZiwgYXMgfSA9IF9yZWFjdC5kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgaWYgKCFwYWdlc1JvdXRlcikge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZm9ybWF0U3RyaW5nT3JVcmwoaHJlZlByb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICAgICAgYXM6IGFzUHJvcCA/IGZvcm1hdFN0cmluZ09yVXJsKGFzUHJvcCkgOiByZXNvbHZlZEhyZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShwYWdlc1JvdXRlciwgaHJlZlByb3AsIHRydWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgYXM6IGFzUHJvcCA/ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHBhZ2VzUm91dGVyLCBhc1Byb3ApIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHBhZ2VzUm91dGVyLFxuICAgICAgICBocmVmUHJvcCxcbiAgICAgICAgYXNQcm9wXG4gICAgXSk7XG4gICAgY29uc3QgcHJldmlvdXNIcmVmID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGhyZWYpO1xuICAgIGNvbnN0IHByZXZpb3VzQXMgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoYXMpO1xuICAgIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgIGxldCBjaGlsZDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgJyArIGhyZWZQcm9wICsgJ2AgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlRW50ZXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdcIm9uTW91c2VFbnRlclwiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGAnICsgaHJlZlByb3AgKyAnYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25Nb3VzZUVudGVyIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgXCIgKyBocmVmUHJvcCArIFwiYCBidXQgb25lIGNoaWxkIGlzIHJlcXVpcmVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbm8tY2hpbGRyZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgXCIgKyBocmVmUHJvcCArIFwiYCBidXQgb25seSBvbmUgY2hpbGQgaXMgc3VwcG9ydGVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbXVsdGlwbGUtY2hpbGRyZW5cIiArICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gXCIgXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgaWYgKChjaGlsZHJlbiA9PSBudWxsID8gdm9pZCAwIDogY2hpbGRyZW4udHlwZSkgPT09IFwiYVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCA8TGluaz4gd2l0aCA8YT4gY2hpbGQuIFBsZWFzZSByZW1vdmUgPGE+IG9yIHVzZSA8TGluayBsZWdhY3lCZWhhdmlvcj4uXFxuTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1uZXctbGluay13aXRoLWV4dHJhLWFuY2hvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGlsZFJlZiA9IGxlZ2FjeUJlaGF2aW9yID8gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiICYmIGNoaWxkLnJlZiA6IGZvcndhcmRlZFJlZjtcbiAgICBjb25zdCBbc2V0SW50ZXJzZWN0aW9uUmVmLCBpc1Zpc2libGUsIHJlc2V0VmlzaWJsZV0gPSAoMCwgX3VzZWludGVyc2VjdGlvbi51c2VJbnRlcnNlY3Rpb24pKHtcbiAgICAgICAgcm9vdE1hcmdpbjogXCIyMDBweFwiXG4gICAgfSk7XG4gICAgY29uc3Qgc2V0UmVmID0gX3JlYWN0LmRlZmF1bHQudXNlQ2FsbGJhY2soKGVsKT0+e1xuICAgICAgICAvLyBCZWZvcmUgdGhlIGxpbmsgZ2V0dGluZyBvYnNlcnZlZCwgY2hlY2sgaWYgdmlzaWJsZSBzdGF0ZSBuZWVkIHRvIGJlIHJlc2V0XG4gICAgICAgIGlmIChwcmV2aW91c0FzLmN1cnJlbnQgIT09IGFzIHx8IHByZXZpb3VzSHJlZi5jdXJyZW50ICE9PSBocmVmKSB7XG4gICAgICAgICAgICByZXNldFZpc2libGUoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQXMuY3VycmVudCA9IGFzO1xuICAgICAgICAgICAgcHJldmlvdXNIcmVmLmN1cnJlbnQgPSBocmVmO1xuICAgICAgICB9XG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZihlbCk7XG4gICAgICAgIGlmIChjaGlsZFJlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gXCJmdW5jdGlvblwiKSBjaGlsZFJlZihlbCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFJlZi5jdXJyZW50ID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBjaGlsZFJlZixcbiAgICAgICAgaHJlZixcbiAgICAgICAgcmVzZXRWaXNpYmxlLFxuICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWZcbiAgICBdKTtcbiAgICAvLyBQcmVmZXRjaCB0aGUgVVJMIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBhbmQgaXQncyB2aXNpYmxlLlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBpbiBkZXYsIHdlIG9ubHkgcHJlZmV0Y2ggb24gaG92ZXIgdG8gYXZvaWQgd2FzdGluZyByZXNvdXJjZXMgYXMgdGhlIHByZWZldGNoIHdpbGwgdHJpZ2dlciBjb21waWxpbmcgdGhlIHBhZ2UuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IG5lZWQgdG8gcHJlZmV0Y2ggdGhlIFVSTCwgZG9uJ3QgZG8gcHJlZmV0Y2guXG4gICAgICAgIGlmICghaXNWaXNpYmxlIHx8ICFwcmVmZXRjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVmZXRjaCB0aGUgVVJMLlxuICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2luZDogYXBwUHJlZmV0Y2hLaW5kXG4gICAgICAgIH0sIGlzQXBwUm91dGVyKTtcbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBocmVmLFxuICAgICAgICBpc1Zpc2libGUsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgcHJlZmV0Y2hFbmFibGVkLFxuICAgICAgICBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlLFxuICAgICAgICByb3V0ZXIsXG4gICAgICAgIGlzQXBwUm91dGVyLFxuICAgICAgICBhcHBQcmVmZXRjaEtpbmRcbiAgICBdKTtcbiAgICBjb25zdCBjaGlsZFByb3BzID0ge1xuICAgICAgICByZWY6IHNldFJlZixcbiAgICAgICAgb25DbGljayAoZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCByZW5kZXJlZCBpbnNpZGUgbmV4dC9saW5rIGhhcyB0byBwYXNzIGNsaWNrIGV2ZW50IHRvIFwib25DbGlja1wiIHByb3AuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25DbGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBpc0FwcFJvdXRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VFbnRlciAoZSkge1xuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Nb3VzZUVudGVyUHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyUHJvcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoIXByZWZldGNoRW5hYmxlZCB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSAmJiBpc0FwcFJvdXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gQHNlZSB7aHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2Rpc2N1c3Npb25zLzQwMjY4P3NvcnQ9dG9wI2Rpc2N1c3Npb25jb21tZW50LTM1NzI2NDJ9XG4gICAgICAgICAgICAgICAgYnlwYXNzUHJlZmV0Y2hlZENoZWNrOiB0cnVlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2luZDogYXBwUHJlZmV0Y2hLaW5kXG4gICAgICAgICAgICB9LCBpc0FwcFJvdXRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVG91Y2hTdGFydCAoZSkge1xuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Ub3VjaFN0YXJ0UHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0UHJvcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vblRvdWNoU3RhcnQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJlZmV0Y2hFbmFibGVkICYmIGlzQXBwUm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBAc2VlIHtodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvZGlzY3Vzc2lvbnMvNDAyNjg/c29ydD10b3AjZGlzY3Vzc2lvbmNvbW1lbnQtMzU3MjY0Mn1cbiAgICAgICAgICAgICAgICBieXBhc3NQcmVmZXRjaGVkQ2hlY2s6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmRcbiAgICAgICAgICAgIH0sIGlzQXBwUm91dGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSWYgY2hpbGQgaXMgYW4gPGE+IHRhZyBhbmQgZG9lc24ndCBoYXZlIGEgaHJlZiBhdHRyaWJ1dGUsIG9yIGlmIHRoZSAncGFzc0hyZWYnIHByb3BlcnR5IGlzXG4gICAgLy8gZGVmaW5lZCwgd2Ugc3BlY2lmeSB0aGUgY3VycmVudCAnaHJlZicsIHNvIHRoYXQgcmVwZXRpdGlvbiBpcyBub3QgbmVlZGVkIGJ5IHRoZSB1c2VyLlxuICAgIC8vIElmIHRoZSB1cmwgaXMgYWJzb2x1dGUsIHdlIGNhbiBieXBhc3MgdGhlIGxvZ2ljIHRvIHByZXBlbmQgdGhlIGRvbWFpbiBhbmQgbG9jYWxlLlxuICAgIGlmICgoMCwgX3V0aWxzLmlzQWJzb2x1dGVVcmwpKGFzKSkge1xuICAgICAgICBjaGlsZFByb3BzLmhyZWYgPSBhcztcbiAgICB9IGVsc2UgaWYgKCFsZWdhY3lCZWhhdmlvciB8fCBwYXNzSHJlZiB8fCBjaGlsZC50eXBlID09PSBcImFcIiAmJiAhKFwiaHJlZlwiIGluIGNoaWxkLnByb3BzKSkge1xuICAgICAgICBjb25zdCBjdXJMb2NhbGUgPSB0eXBlb2YgbG9jYWxlICE9PSBcInVuZGVmaW5lZFwiID8gbG9jYWxlIDogcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmxvY2FsZTtcbiAgICAgICAgLy8gd2Ugb25seSByZW5kZXIgZG9tYWluIGxvY2FsZXMgaWYgd2UgYXJlIGN1cnJlbnRseSBvbiBhIGRvbWFpbiBsb2NhbGVcbiAgICAgICAgLy8gc28gdGhhdCBsb2NhbGUgbGlua3MgYXJlIHN0aWxsIHZpc2l0YWJsZSBpbiBkZXZlbG9wbWVudC9wcmV2aWV3IGVudnNcbiAgICAgICAgY29uc3QgbG9jYWxlRG9tYWluID0gKHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5pc0xvY2FsZURvbWFpbikgJiYgKDAsIF9nZXRkb21haW5sb2NhbGUuZ2V0RG9tYWluTG9jYWxlKShhcywgY3VyTG9jYWxlLCBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlcywgcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmRvbWFpbkxvY2FsZXMpO1xuICAgICAgICBjaGlsZFByb3BzLmhyZWYgPSBsb2NhbGVEb21haW4gfHwgKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhcywgY3VyTG9jYWxlLCBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuZGVmYXVsdExvY2FsZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbGVnYWN5QmVoYXZpb3IgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcykgOiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwiYVwiLCB7XG4gICAgICAgIC4uLnJlc3RQcm9wcyxcbiAgICAgICAgLi4uY2hpbGRQcm9wcyxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSk7XG59KTtcbmNvbnN0IF9kZWZhdWx0ID0gTGluaztcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX2pzeHJ1bnRpbWUiLCJfcmVhY3QiLCJfIiwiX3Jlc29sdmVocmVmIiwiX2lzbG9jYWx1cmwiLCJfZm9ybWF0dXJsIiwiX3V0aWxzIiwiX2FkZGxvY2FsZSIsIl9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl91c2VpbnRlcnNlY3Rpb24iLCJfZ2V0ZG9tYWlubG9jYWxlIiwiX2FkZGJhc2VwYXRoIiwiX3JvdXRlcnJlZHVjZXJ0eXBlcyIsInByZWZldGNoZWQiLCJTZXQiLCJwcmVmZXRjaCIsInJvdXRlciIsImhyZWYiLCJhcyIsIm9wdGlvbnMiLCJhcHBPcHRpb25zIiwiaXNBcHBSb3V0ZXIiLCJpc0xvY2FsVVJMIiwiYnlwYXNzUHJlZmV0Y2hlZENoZWNrIiwibG9jYWxlIiwidW5kZWZpbmVkIiwicHJlZmV0Y2hlZEtleSIsImhhcyIsImFkZCIsInByZWZldGNoUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2F0Y2giLCJlcnIiLCJwcm9jZXNzIiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJldmVudFRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJtZXRhS2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwibmF0aXZlRXZlbnQiLCJ3aGljaCIsImxpbmtDbGlja2VkIiwiZSIsInJlcGxhY2UiLCJzaGFsbG93Iiwic2Nyb2xsIiwibm9kZU5hbWUiLCJpc0FuY2hvck5vZGVOYW1lIiwidG9VcHBlckNhc2UiLCJwcmV2ZW50RGVmYXVsdCIsIm5hdmlnYXRlIiwicm91dGVyU2Nyb2xsIiwiZGVmYXVsdCIsInN0YXJ0VHJhbnNpdGlvbiIsImZvcm1hdFN0cmluZ09yVXJsIiwidXJsT2JqT3JTdHJpbmciLCJmb3JtYXRVcmwiLCJMaW5rIiwiZm9yd2FyZFJlZiIsIkxpbmtDb21wb25lbnQiLCJwcm9wcyIsImZvcndhcmRlZFJlZiIsImNoaWxkcmVuIiwiaHJlZlByb3AiLCJhc1Byb3AiLCJjaGlsZHJlblByb3AiLCJwcmVmZXRjaFByb3AiLCJwYXNzSHJlZiIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlRW50ZXJQcm9wIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaFN0YXJ0UHJvcCIsImxlZ2FjeUJlaGF2aW9yIiwicmVzdFByb3BzIiwianN4IiwicGFnZXNSb3V0ZXIiLCJ1c2VDb250ZXh0IiwiUm91dGVyQ29udGV4dCIsImFwcFJvdXRlciIsIkFwcFJvdXRlckNvbnRleHQiLCJwcmVmZXRjaEVuYWJsZWQiLCJhcHBQcmVmZXRjaEtpbmQiLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiRlVMTCIsImNyZWF0ZVByb3BFcnJvciIsImFyZ3MiLCJFcnJvciIsImtleSIsImV4cGVjdGVkIiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsImtleXMiLCJmb3JFYWNoIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJwYXRobmFtZSIsImhhc0R5bmFtaWNTZWdtZW50Iiwic3BsaXQiLCJzb21lIiwic2VnbWVudCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInVzZU1lbW8iLCJyZXNvbHZlZEhyZWYiLCJyZXNvbHZlZEFzIiwicmVzb2x2ZUhyZWYiLCJwcmV2aW91c0hyZWYiLCJwcmV2aW91c0FzIiwiY2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJ0eXBlIiwiY2hpbGRSZWYiLCJyZWYiLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJpc1Zpc2libGUiLCJyZXNldFZpc2libGUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJyb290TWFyZ2luIiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInVzZUVmZmVjdCIsImtpbmQiLCJjaGlsZFByb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsInByaW9yaXR5IiwiaXNBYnNvbHV0ZVVybCIsImN1ckxvY2FsZSIsImxvY2FsZURvbWFpbiIsImlzTG9jYWxlRG9tYWluIiwiZ2V0RG9tYWluTG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJjbG9uZUVsZW1lbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/request-idle-callback.js":
/*!*********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/request-idle-callback.js ***!
  \*********************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    },\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvcmVxdWVzdC1pZGxlLWNhbGxiYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBR047QUFDQSxTQUFTRyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVCxPQUFPQyxjQUFjLENBQUNPLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUUwsU0FBUztJQUNiRyxxQkFBcUI7UUFDakIsT0FBT0E7SUFDWDtJQUNBQyxvQkFBb0I7UUFDaEIsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTUQsc0JBQXNCLE9BQU9RLFNBQVMsZUFBZUEsS0FBS1IsbUJBQW1CLElBQUlRLEtBQUtSLG1CQUFtQixDQUFDUyxJQUFJLENBQUNDLFdBQVcsU0FBU0MsRUFBRTtJQUN2SSxJQUFJQyxRQUFRQyxLQUFLQyxHQUFHO0lBQ3BCLE9BQU9OLEtBQUtPLFVBQVUsQ0FBQztRQUNuQkosR0FBRztZQUNDSyxZQUFZO1lBQ1pDLGVBQWU7Z0JBQ1gsT0FBT0MsS0FBS0MsR0FBRyxDQUFDLEdBQUcsS0FBTU4sQ0FBQUEsS0FBS0MsR0FBRyxLQUFLRixLQUFJO1lBQzlDO1FBQ0o7SUFDSixHQUFHO0FBQ1A7QUFDQSxNQUFNWCxxQkFBcUIsT0FBT08sU0FBUyxlQUFlQSxLQUFLUCxrQkFBa0IsSUFBSU8sS0FBS1Asa0JBQWtCLENBQUNRLElBQUksQ0FBQ0MsV0FBVyxTQUFTVSxFQUFFO0lBQ3BJLE9BQU9DLGFBQWFEO0FBQ3hCO0FBRUEsSUFBSSxDQUFDLE9BQU92QixRQUFReUIsT0FBTyxLQUFLLGNBQWUsT0FBT3pCLFFBQVF5QixPQUFPLEtBQUssWUFBWXpCLFFBQVF5QixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU96QixRQUFReUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzVCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUXlCLE9BQU8sRUFBRSxjQUFjO1FBQUV4QixPQUFPO0lBQUs7SUFDbkVILE9BQU82QixNQUFNLENBQUMzQixRQUFReUIsT0FBTyxFQUFFekI7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUXlCLE9BQU87QUFDbEMsRUFFQSxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjEuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanM/ZDVmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2s6IG51bGwsXG4gICAgY2FuY2VsSWRsZUNhbGxiYWNrOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdElkbGVDYWxsYmFjaztcbiAgICB9LFxuICAgIGNhbmNlbElkbGVDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjYW5jZWxJZGxlQ2FsbGJhY2s7XG4gICAgfVxufSk7XG5jb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrID0gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrICYmIHNlbGYucmVxdWVzdElkbGVDYWxsYmFjay5iaW5kKHdpbmRvdykgfHwgZnVuY3Rpb24oY2IpIHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNiKHtcbiAgICAgICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCAxKTtcbn07XG5jb25zdCBjYW5jZWxJZGxlQ2FsbGJhY2sgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNhbmNlbElkbGVDYWxsYmFjayAmJiBzZWxmLmNhbmNlbElkbGVDYWxsYmFjay5iaW5kKHdpbmRvdykgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKTtcbn07XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QtaWRsZS1jYWxsYmFjay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2VsZiIsImJpbmQiLCJ3aW5kb3ciLCJjYiIsInN0YXJ0IiwiRGF0ZSIsIm5vdyIsInNldFRpbWVvdXQiLCJkaWRUaW1lb3V0IiwidGltZVJlbWFpbmluZyIsIk1hdGgiLCJtYXgiLCJpZCIsImNsZWFyVGltZW91dCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/resolve-href.js":
/*!************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/resolve-href.js ***!
  \************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n}));\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/utils.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/index.js\");\nconst _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\", 1);\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvcmVzb2x2ZS1ocmVmLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwrQ0FBOEM7SUFDMUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxlQUFlQyxtQkFBT0EsQ0FBQyxvTUFBd0M7QUFDckUsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsa01BQXVDO0FBQ2xFLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDLHNMQUFpQztBQUN2RCxNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQyw4SkFBcUI7QUFDNUMsTUFBTUksMEJBQTBCSixtQkFBT0EsQ0FBQyxvTEFBNEI7QUFDcEUsTUFBTUssY0FBY0wsbUJBQU9BLENBQUMsc01BQXlDO0FBQ3JFLE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDLGtMQUE0QjtBQUNwRCxNQUFNTyxpQkFBaUJQLG1CQUFPQSxDQUFDLDBNQUEyQztBQUMxRSxTQUFTRixZQUFZVSxNQUFNLEVBQUVDLElBQUksRUFBRUMsU0FBUztJQUN4Qyw0Q0FBNEM7SUFDNUMsSUFBSUM7SUFDSixJQUFJQyxjQUFjLE9BQU9ILFNBQVMsV0FBV0EsT0FBTyxDQUFDLEdBQUdSLFdBQVdZLG9CQUFvQixFQUFFSjtJQUN6Riw2REFBNkQ7SUFDN0QsbURBQW1EO0lBQ25ELE1BQU1LLGdCQUFnQkYsWUFBWUcsS0FBSyxDQUFDO0lBQ3hDLE1BQU1DLHFCQUFxQkYsZ0JBQWdCRixZQUFZSyxLQUFLLENBQUNILGFBQWEsQ0FBQyxFQUFFLENBQUNJLE1BQU0sSUFBSU47SUFDeEYsTUFBTU8sV0FBV0gsbUJBQW1CSSxLQUFLLENBQUMsS0FBSztJQUMvQyxJQUFJLENBQUNELFFBQVEsQ0FBQyxFQUFFLElBQUksRUFBQyxFQUFHSixLQUFLLENBQUMsY0FBYztRQUN4Q00sUUFBUUMsS0FBSyxDQUFDLG1CQUFtQlYsY0FBYyx1Q0FBdUNKLE9BQU9lLFFBQVEsR0FBRztRQUN4RyxNQUFNQyxnQkFBZ0IsQ0FBQyxHQUFHckIsT0FBT3NCLHdCQUF3QixFQUFFVDtRQUMzREosY0FBYyxDQUFDRSxnQkFBZ0JBLGFBQWEsQ0FBQyxFQUFFLEdBQUcsRUFBQyxJQUFLVTtJQUM1RDtJQUNBLDJEQUEyRDtJQUMzRCxJQUFJLENBQUMsQ0FBQyxHQUFHbkIsWUFBWXFCLFVBQVUsRUFBRWQsY0FBYztRQUMzQyxPQUFPRixZQUFZO1lBQ2ZFO1NBQ0gsR0FBR0E7SUFDUjtJQUNBLElBQUk7UUFDQUQsT0FBTyxJQUFJZ0IsSUFBSWYsWUFBWWdCLFVBQVUsQ0FBQyxPQUFPcEIsT0FBT3FCLE1BQU0sR0FBR3JCLE9BQU9lLFFBQVEsRUFBRTtJQUNsRixFQUFFLE9BQU9PLEdBQUc7UUFDUixrREFBa0Q7UUFDbERuQixPQUFPLElBQUlnQixJQUFJLEtBQUs7SUFDeEI7SUFDQSxJQUFJO1FBQ0EsTUFBTUksV0FBVyxJQUFJSixJQUFJZixhQUFhRDtRQUN0Q29CLFNBQVNSLFFBQVEsR0FBRyxDQUFDLEdBQUduQix3QkFBd0I0QiwwQkFBMEIsRUFBRUQsU0FBU1IsUUFBUTtRQUM3RixJQUFJVSxpQkFBaUI7UUFDckIsSUFBSSxDQUFDLEdBQUczQixRQUFRNEIsY0FBYyxFQUFFSCxTQUFTUixRQUFRLEtBQUtRLFNBQVNJLFlBQVksSUFBSXpCLFdBQVc7WUFDdEYsTUFBTTBCLFFBQVEsQ0FBQyxHQUFHckMsYUFBYXNDLHNCQUFzQixFQUFFTixTQUFTSSxZQUFZO1lBQzVFLE1BQU0sRUFBRUcsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUdoQyxlQUFlaUMsYUFBYSxFQUFFVCxTQUFTUixRQUFRLEVBQUVRLFNBQVNSLFFBQVEsRUFBRWE7WUFDbkcsSUFBSUUsUUFBUTtnQkFDUkwsaUJBQWlCLENBQUMsR0FBR2hDLFdBQVdZLG9CQUFvQixFQUFFO29CQUNsRFUsVUFBVWU7b0JBQ1ZHLE1BQU1WLFNBQVNVLElBQUk7b0JBQ25CTCxPQUFPLENBQUMsR0FBR2xDLE1BQU13QyxJQUFJLEVBQUVOLE9BQU9HO2dCQUNsQztZQUNKO1FBQ0o7UUFDQSxvRUFBb0U7UUFDcEUsTUFBTUksZUFBZVosU0FBU2EsTUFBTSxLQUFLakMsS0FBS2lDLE1BQU0sR0FBR2IsU0FBU3RCLElBQUksQ0FBQ1EsS0FBSyxDQUFDYyxTQUFTYSxNQUFNLENBQUMxQixNQUFNLElBQUlhLFNBQVN0QixJQUFJO1FBQ2xILE9BQU9DLFlBQVk7WUFDZmlDO1lBQ0FWLGtCQUFrQlU7U0FDckIsR0FBR0E7SUFDUixFQUFFLE9BQU9iLEdBQUc7UUFDUixPQUFPcEIsWUFBWTtZQUNmRTtTQUNILEdBQUdBO0lBQ1I7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPbEIsUUFBUW1ELE9BQU8sS0FBSyxjQUFlLE9BQU9uRCxRQUFRbUQsT0FBTyxLQUFLLFlBQVluRCxRQUFRbUQsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbkQsUUFBUW1ELE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt0RCxPQUFPQyxjQUFjLENBQUNDLFFBQVFtRCxPQUFPLEVBQUUsY0FBYztRQUFFbEQsT0FBTztJQUFLO0lBQ25FSCxPQUFPdUQsTUFBTSxDQUFDckQsUUFBUW1ELE9BQU8sRUFBRW5EO0lBQy9Cc0QsT0FBT3RELE9BQU8sR0FBR0EsUUFBUW1ELE9BQU87QUFDbEMsRUFFQSx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjEuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXNvbHZlLWhyZWYuanM/NDYyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc29sdmVIcmVmXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlSHJlZjtcbiAgICB9XG59KTtcbmNvbnN0IF9xdWVyeXN0cmluZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZ1wiKTtcbmNvbnN0IF9mb3JtYXR1cmwgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybFwiKTtcbmNvbnN0IF9vbWl0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL29taXRcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbmNvbnN0IF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsXCIpO1xuY29uc3QgX3V0aWxzMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlsc1wiKTtcbmNvbnN0IF9pbnRlcnBvbGF0ZWFzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVycG9sYXRlLWFzXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZUhyZWYocm91dGVyLCBocmVmLCByZXNvbHZlQXMpIHtcbiAgICAvLyB3ZSB1c2UgYSBkdW1teSBiYXNlIHVybCBmb3IgcmVsYXRpdmUgdXJsc1xuICAgIGxldCBiYXNlO1xuICAgIGxldCB1cmxBc1N0cmluZyA9IHR5cGVvZiBocmVmID09PSBcInN0cmluZ1wiID8gaHJlZiA6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShocmVmKTtcbiAgICAvLyByZXBlYXRlZCBzbGFzaGVzIGFuZCBiYWNrc2xhc2hlcyBpbiB0aGUgVVJMIGFyZSBjb25zaWRlcmVkXG4gICAgLy8gaW52YWxpZCBhbmQgd2lsbCBuZXZlciBtYXRjaCBhIE5leHQuanMgcGFnZS9maWxlXG4gICAgY29uc3QgdXJsUHJvdG9NYXRjaCA9IHVybEFzU3RyaW5nLm1hdGNoKC9eW2EtekEtWl17MSx9OlxcL1xcLy8pO1xuICAgIGNvbnN0IHVybEFzU3RyaW5nTm9Qcm90byA9IHVybFByb3RvTWF0Y2ggPyB1cmxBc1N0cmluZy5zbGljZSh1cmxQcm90b01hdGNoWzBdLmxlbmd0aCkgOiB1cmxBc1N0cmluZztcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybEFzU3RyaW5nTm9Qcm90by5zcGxpdChcIj9cIiwgMSk7XG4gICAgaWYgKCh1cmxQYXJ0c1swXSB8fCBcIlwiKS5tYXRjaCgvKFxcL1xcL3xcXFxcKS8pKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGhyZWYgJ1wiICsgdXJsQXNTdHJpbmcgKyBcIicgcGFzc2VkIHRvIG5leHQvcm91dGVyIGluIHBhZ2U6ICdcIiArIHJvdXRlci5wYXRobmFtZSArIFwiJy4gUmVwZWF0ZWQgZm9yd2FyZC1zbGFzaGVzICgvLykgb3IgYmFja3NsYXNoZXMgXFxcXCBhcmUgbm90IHZhbGlkIGluIHRoZSBocmVmLlwiKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFVybCA9ICgwLCBfdXRpbHMubm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKSh1cmxBc1N0cmluZ05vUHJvdG8pO1xuICAgICAgICB1cmxBc1N0cmluZyA9ICh1cmxQcm90b01hdGNoID8gdXJsUHJvdG9NYXRjaFswXSA6IFwiXCIpICsgbm9ybWFsaXplZFVybDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGJlY2F1c2UgaXQgY2Fubm90IGJlIHJvdXRlZCBieSB0aGUgTmV4dC5qcyByb3V0ZXJcbiAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKSh1cmxBc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcbiAgICAgICAgICAgIHVybEFzU3RyaW5nXG4gICAgICAgIF0gOiB1cmxBc1N0cmluZztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYmFzZSA9IG5ldyBVUkwodXJsQXNTdHJpbmcuc3RhcnRzV2l0aChcIiNcIikgPyByb3V0ZXIuYXNQYXRoIDogcm91dGVyLnBhdGhuYW1lLCBcImh0dHA6Ly9uXCIpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gLyBmb3IgaW52YWxpZCBhc1BhdGggdmFsdWVzIGUuZy4gLy9cbiAgICAgICAgYmFzZSA9IG5ldyBVUkwoXCIvXCIsIFwiaHR0cDovL25cIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSk7XG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKShmaW5hbFVybC5wYXRobmFtZSk7XG4gICAgICAgIGxldCBpbnRlcnBvbGF0ZWRBcyA9IFwiXCI7XG4gICAgICAgIGlmICgoMCwgX3V0aWxzMS5pc0R5bmFtaWNSb3V0ZSkoZmluYWxVcmwucGF0aG5hbWUpICYmIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJiByZXNvbHZlQXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gKDAsIF9xdWVyeXN0cmluZy5zZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KShmaW5hbFVybC5zZWFyY2hQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQsIHBhcmFtcyB9ID0gKDAsIF9pbnRlcnBvbGF0ZWFzLmludGVycG9sYXRlQXMpKGZpbmFsVXJsLnBhdGhuYW1lLCBmaW5hbFVybC5wYXRobmFtZSwgcXVlcnkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZEFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgaGFzaDogZmluYWxVcmwuaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6ICgwLCBfb21pdC5vbWl0KShxdWVyeSwgcGFyYW1zKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBvcmlnaW4gZGlkbid0IGNoYW5nZSwgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSByZWxhdGl2ZSBocmVmXG4gICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9IGZpbmFsVXJsLm9yaWdpbiA9PT0gYmFzZS5vcmlnaW4gPyBmaW5hbFVybC5ocmVmLnNsaWNlKGZpbmFsVXJsLm9yaWdpbi5sZW5ndGgpIDogZmluYWxVcmwuaHJlZjtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcbiAgICAgICAgICAgIHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgIGludGVycG9sYXRlZEFzIHx8IHJlc29sdmVkSHJlZlxuICAgICAgICBdIDogcmVzb2x2ZWRIcmVmO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcbiAgICAgICAgICAgIHVybEFzU3RyaW5nXG4gICAgICAgIF0gOiB1cmxBc1N0cmluZztcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUtaHJlZi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwicmVzb2x2ZUhyZWYiLCJfcXVlcnlzdHJpbmciLCJyZXF1aXJlIiwiX2Zvcm1hdHVybCIsIl9vbWl0IiwiX3V0aWxzIiwiX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2giLCJfaXNsb2NhbHVybCIsIl91dGlsczEiLCJfaW50ZXJwb2xhdGVhcyIsInJvdXRlciIsImhyZWYiLCJyZXNvbHZlQXMiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybFByb3RvTWF0Y2giLCJtYXRjaCIsInVybEFzU3RyaW5nTm9Qcm90byIsInNsaWNlIiwibGVuZ3RoIiwidXJsUGFydHMiLCJzcGxpdCIsImNvbnNvbGUiLCJlcnJvciIsInBhdGhuYW1lIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImlzTG9jYWxVUkwiLCJVUkwiLCJzdGFydHNXaXRoIiwiYXNQYXRoIiwiXyIsImZpbmFsVXJsIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJpbnRlcnBvbGF0ZWRBcyIsImlzRHluYW1pY1JvdXRlIiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwicmVzdWx0IiwicGFyYW1zIiwiaW50ZXJwb2xhdGVBcyIsImhhc2giLCJvbWl0IiwicmVzb2x2ZWRIcmVmIiwib3JpZ2luIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/use-intersection.js":
/*!****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/use-intersection.js ***!
  \****************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvdXNlLWludGVyc2VjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMsb0pBQU87QUFDOUIsTUFBTUMsdUJBQXVCRCxtQkFBT0EsQ0FBQyw4S0FBeUI7QUFDOUQsTUFBTUUsMEJBQTBCLE9BQU9DLHlCQUF5QjtBQUNoRSxNQUFNQyxZQUFZLElBQUlDO0FBQ3RCLE1BQU1DLFNBQVMsRUFBRTtBQUNqQixTQUFTQyxlQUFlQyxPQUFPO0lBQzNCLE1BQU1DLEtBQUs7UUFDUEMsTUFBTUYsUUFBUUUsSUFBSSxJQUFJO1FBQ3RCQyxRQUFRSCxRQUFRSSxVQUFVLElBQUk7SUFDbEM7SUFDQSxNQUFNQyxXQUFXUCxPQUFPUSxJQUFJLENBQUMsQ0FBQ0MsTUFBTUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtJQUNwRixJQUFJSztJQUNKLElBQUlILFVBQVU7UUFDVkcsV0FBV1osVUFBVVAsR0FBRyxDQUFDZ0I7UUFDekIsSUFBSUcsVUFBVTtZQUNWLE9BQU9BO1FBQ1g7SUFDSjtJQUNBLE1BQU1DLFdBQVcsSUFBSVo7SUFDckIsTUFBTWEsV0FBVyxJQUFJZixxQkFBcUIsQ0FBQ2dCO1FBQ3ZDQSxRQUFRQyxPQUFPLENBQUMsQ0FBQ0M7WUFDYixNQUFNQyxXQUFXTCxTQUFTcEIsR0FBRyxDQUFDd0IsTUFBTUUsTUFBTTtZQUMxQyxNQUFNQyxZQUFZSCxNQUFNSSxj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LFFBQVE4RCxPQUFPLEVBQUUsY0FBYztRQUFFN0QsT0FBTztJQUFLO0lBQ25FSCxPQUFPa0UsTUFBTSxDQUFDaEUsUUFBUThELE9BQU8sRUFBRTlEO0lBQy9CaUUsT0FBT2pFLE9BQU8sR0FBR0EsUUFBUThELE9BQU87QUFDbEMsRUFFQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjEuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzPzlmZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1c2VJbnRlcnNlY3Rpb25cIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZUludGVyc2VjdGlvbjtcbiAgICB9XG59KTtcbmNvbnN0IF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmNvbnN0IF9yZXF1ZXN0aWRsZWNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuY29uc3QgaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IG9ic2VydmVycyA9IG5ldyBNYXAoKTtcbmNvbnN0IGlkTGlzdCA9IFtdO1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucykge1xuICAgIGNvbnN0IGlkID0ge1xuICAgICAgICByb290OiBvcHRpb25zLnJvb3QgfHwgbnVsbCxcbiAgICAgICAgbWFyZ2luOiBvcHRpb25zLnJvb3RNYXJnaW4gfHwgXCJcIlxuICAgIH07XG4gICAgY29uc3QgZXhpc3RpbmcgPSBpZExpc3QuZmluZCgob2JqKT0+b2JqLnJvb3QgPT09IGlkLnJvb3QgJiYgb2JqLm1hcmdpbiA9PT0gaWQubWFyZ2luKTtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIGluc3RhbmNlID0gb2JzZXJ2ZXJzLmdldChleGlzdGluZyk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKT0+e1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KT0+e1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpbnN0YW5jZSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9ic2VydmVyLFxuICAgICAgICBlbGVtZW50c1xuICAgIH07XG4gICAgaWRMaXN0LnB1c2goaWQpO1xuICAgIG9ic2VydmVycy5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBvYnNlcnZlKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpZCwgb2JzZXJ2ZXIsIGVsZW1lbnRzIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKTtcbiAgICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpIHtcbiAgICAgICAgZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgIC8vIERlc3Ryb3kgb2JzZXJ2ZXIgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byB3YXRjaDpcbiAgICAgICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIG9ic2VydmVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpZExpc3QuZmluZEluZGV4KChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb24ocGFyYW0pIHtcbiAgICBsZXQgeyByb290UmVmLCByb290TWFyZ2luLCBkaXNhYmxlZCB9ID0gcGFyYW07XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8ICFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgZWxlbWVudFJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShudWxsKTtcbiAgICBjb25zdCBzZXRFbGVtZW50ID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKGVsZW1lbnQpPT57XG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgfSwgW10pO1xuICAgICgwLCBfcmVhY3QudXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bm9ic2VydmUgPSBvYnNlcnZlKGVsZW1lbnQsIChpc1Zpc2libGUpPT5pc1Zpc2libGUgJiYgc2V0VmlzaWJsZShpc1Zpc2libGUpLCB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3Q6IHJvb3RSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3RSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgcm9vdE1hcmdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bm9ic2VydmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlQ2FsbGJhY2sgPSAoMCwgX3JlcXVlc3RpZGxlY2FsbGJhY2sucmVxdWVzdElkbGVDYWxsYmFjaykoKCk9PnNldFZpc2libGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKT0+KDAsIF9yZXF1ZXN0aWRsZWNhbGxiYWNrLmNhbmNlbElkbGVDYWxsYmFjaykoaWRsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgIHJvb3RSZWYsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudFxuICAgIF0pO1xuICAgIGNvbnN0IHJlc2V0VmlzaWJsZSA9ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldFZpc2libGUoZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzZXRFbGVtZW50LFxuICAgICAgICB2aXNpYmxlLFxuICAgICAgICByZXNldFZpc2libGVcbiAgICBdO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtaW50ZXJzZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlcXVlc3RpZGxlY2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiTWFwIiwiaWRMaXN0IiwiY3JlYXRlT2JzZXJ2ZXIiLCJvcHRpb25zIiwiaWQiLCJyb290IiwibWFyZ2luIiwicm9vdE1hcmdpbiIsImV4aXN0aW5nIiwiZmluZCIsIm9iaiIsImluc3RhbmNlIiwiZWxlbWVudHMiLCJvYnNlcnZlciIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJjYWxsYmFjayIsInRhcmdldCIsImlzVmlzaWJsZSIsImlzSW50ZXJzZWN0aW5nIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJwdXNoIiwic2V0Iiwib2JzZXJ2ZSIsImVsZW1lbnQiLCJ1bm9ic2VydmUiLCJkZWxldGUiLCJzaXplIiwiZGlzY29ubmVjdCIsImluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwicGFyYW0iLCJyb290UmVmIiwiZGlzYWJsZWQiLCJpc0Rpc2FibGVkIiwidmlzaWJsZSIsInNldFZpc2libGUiLCJ1c2VTdGF0ZSIsImVsZW1lbnRSZWYiLCJ1c2VSZWYiLCJzZXRFbGVtZW50IiwidXNlQ2FsbGJhY2siLCJjdXJyZW50IiwidXNlRWZmZWN0IiwidGFnTmFtZSIsImlkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJyZXNldFZpc2libGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/escape-regexp.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \*****************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function() {\n        return escapeStringRegexp;\n    }\n}));\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2VzY2FwZS1yZWdleHAuanMiLCJtYXBwaW5ncyI6IkFBQUEsMEVBQTBFO0FBQzdEO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxzREFBcUQ7SUFDakRJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLGtCQUFrQjtBQUN4QixTQUFTRixtQkFBbUJHLEdBQUc7SUFDM0IsK0dBQStHO0lBQy9HLElBQUlGLFlBQVlHLElBQUksQ0FBQ0QsTUFBTTtRQUN2QixPQUFPQSxJQUFJRSxPQUFPLENBQUNILGlCQUFpQjtJQUN4QztJQUNBLE9BQU9DO0FBQ1gsRUFFQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjEuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZXNjYXBlLXJlZ2V4cC5qcz9lNjgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlZ2V4cCBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2VzY2FwZS1zdHJpbmctcmVnZXhwXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZVN0cmluZ1JlZ2V4cFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZXNjYXBlU3RyaW5nUmVnZXhwO1xuICAgIH1cbn0pO1xuY29uc3QgcmVIYXNSZWdFeHAgPSAvW3xcXFxce30oKVtcXF1eJCsqPy4tXS87XG5jb25zdCByZVJlcGxhY2VSZWdFeHAgPSAvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nO1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nUmVnZXhwKHN0cikge1xuICAgIC8vIHNlZSBhbHNvOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzJkYTAyNGMzYjRmOTk0N2E0ODUxNzYzOWRlNzU2MDQ1N2NkNGVjNmMvZXNjYXBlUmVnRXhwLmpzI0wyM1xuICAgIGlmIChyZUhhc1JlZ0V4cC50ZXN0KHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlUmVwbGFjZVJlZ0V4cCwgXCJcXFxcJCZcIik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzY2FwZS1yZWdleHAuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImVzY2FwZVN0cmluZ1JlZ2V4cCIsInJlSGFzUmVnRXhwIiwicmVSZXBsYWNlUmVnRXhwIiwic3RyIiwidGVzdCIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!*********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \*********************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../../node_modules/.pnpm/@swc+helpers@0.5.2/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxpREFBZ0Q7SUFDNUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLDBLQUF5QztBQUNsRixNQUFNQyxTQUFTLFdBQVcsR0FBR0YseUJBQXlCRyxDQUFDLENBQUNGLG1CQUFPQSxDQUFDLG9KQUFPO0FBQ3ZFLE1BQU1GLGdCQUFnQkcsT0FBT0UsT0FBTyxDQUFDQyxhQUFhLENBQUM7QUFDbkQsSUFBSUMsSUFBcUMsRUFBRTtJQUN2Q1AsY0FBY1EsV0FBVyxHQUFHO0FBQ2hDLEVBRUEseURBQXlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lLmpzPzI5NjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSb3V0ZXJDb250ZXh0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSb3V0ZXJDb250ZXh0O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IFJvdXRlckNvbnRleHQgPSBfcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlckNvbnRleHRcIjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIlJvdXRlckNvbnRleHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsImRlZmF1bHQiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \***************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/../../node_modules/.pnpm/@swc+helpers@0.5.2/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || \"\";\n    let pathname = urlObj.pathname || \"\";\n    let hash = urlObj.hash || \"\";\n    let query = urlObj.query || \"\";\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLmpzIiwibWFwcGluZ3MiOiJBQUFBLHVDQUF1QztBQUN2QyxzREFBc0Q7QUFDdEQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSxnRUFBZ0U7QUFDaEUsc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSw0RUFBNEU7QUFDNUUscUVBQXFFO0FBQ3JFLHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlEQUF5RDtBQUN6RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLDZEQUE2RDtBQUM3RCw0RUFBNEU7QUFDNUUsMkVBQTJFO0FBQzNFLHdFQUF3RTtBQUN4RSw0RUFBNEU7QUFDNUUseUNBQXlDO0FBQzVCO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBSU47QUFDQSxTQUFTSSxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVixPQUFPQyxjQUFjLENBQUNRLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUU4sU0FBUztJQUNiRyxXQUFXO1FBQ1AsT0FBT0E7SUFDWDtJQUNBQyxlQUFlO1FBQ1gsT0FBT0E7SUFDWDtJQUNBQyxzQkFBc0I7UUFDbEIsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU8sNEJBQTRCQyxtQkFBT0EsQ0FBQyw0S0FBMEM7QUFDcEYsTUFBTUMsZUFBZSxXQUFXLEdBQUdGLDBCQUEwQkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQywyS0FBZTtBQUN0RixNQUFNRyxtQkFBbUI7QUFDekIsU0FBU2IsVUFBVWMsTUFBTTtJQUNyQixJQUFJLEVBQUVDLElBQUksRUFBRUMsUUFBUSxFQUFFLEdBQUdGO0lBQ3pCLElBQUlHLFdBQVdILE9BQU9HLFFBQVEsSUFBSTtJQUNsQyxJQUFJQyxXQUFXSixPQUFPSSxRQUFRLElBQUk7SUFDbEMsSUFBSUMsT0FBT0wsT0FBT0ssSUFBSSxJQUFJO0lBQzFCLElBQUlDLFFBQVFOLE9BQU9NLEtBQUssSUFBSTtJQUM1QixJQUFJQyxPQUFPO0lBQ1hOLE9BQU9BLE9BQU9PLG1CQUFtQlAsTUFBTVEsT0FBTyxDQUFDLFFBQVEsT0FBTyxNQUFNO0lBQ3BFLElBQUlULE9BQU9PLElBQUksRUFBRTtRQUNiQSxPQUFPTixPQUFPRCxPQUFPTyxJQUFJO0lBQzdCLE9BQU8sSUFBSUwsVUFBVTtRQUNqQkssT0FBT04sT0FBUSxFQUFDQyxTQUFTUSxPQUFPLENBQUMsT0FBTyxNQUFNUixXQUFXLE1BQU1BLFFBQU87UUFDdEUsSUFBSUYsT0FBT1csSUFBSSxFQUFFO1lBQ2JKLFFBQVEsTUFBTVAsT0FBT1csSUFBSTtRQUM3QjtJQUNKO0lBQ0EsSUFBSUwsU0FBUyxPQUFPQSxVQUFVLFVBQVU7UUFDcENBLFFBQVFNLE9BQU9mLGFBQWFnQixzQkFBc0IsQ0FBQ1A7SUFDdkQ7SUFDQSxJQUFJUSxTQUFTZCxPQUFPYyxNQUFNLElBQUlSLFNBQVMsTUFBTUEsU0FBUztJQUN0RCxJQUFJSCxZQUFZLENBQUNBLFNBQVNZLFFBQVEsQ0FBQyxNQUFNWixZQUFZO0lBQ3JELElBQUlILE9BQU9nQixPQUFPLElBQUksQ0FBQyxDQUFDYixZQUFZSixpQkFBaUJrQixJQUFJLENBQUNkLFNBQVEsS0FBTUksU0FBUyxPQUFPO1FBQ3BGQSxPQUFPLE9BQVFBLENBQUFBLFFBQVEsRUFBQztRQUN4QixJQUFJSCxZQUFZQSxRQUFRLENBQUMsRUFBRSxLQUFLLEtBQUtBLFdBQVcsTUFBTUE7SUFDMUQsT0FBTyxJQUFJLENBQUNHLE1BQU07UUFDZEEsT0FBTztJQUNYO0lBQ0EsSUFBSUYsUUFBUUEsSUFBSSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxPQUFPLE1BQU1BO0lBQzFDLElBQUlTLFVBQVVBLE1BQU0sQ0FBQyxFQUFFLEtBQUssS0FBS0EsU0FBUyxNQUFNQTtJQUNoRFYsV0FBV0EsU0FBU0ssT0FBTyxDQUFDLFNBQVNEO0lBQ3JDTSxTQUFTQSxPQUFPTCxPQUFPLENBQUMsS0FBSztJQUM3QixPQUFPLEtBQUtOLFdBQVdJLE9BQU9ILFdBQVdVLFNBQVNUO0FBQ3REO0FBQ0EsTUFBTWxCLGdCQUFnQjtJQUNsQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELFNBQVNDLHFCQUFxQjhCLEdBQUc7SUFDN0IsSUFBSUMsSUFBc0MsRUFBRTtRQUN4QyxJQUFJRCxRQUFRLFFBQVEsT0FBT0EsUUFBUSxVQUFVO1lBQ3pDckMsT0FBT3VDLElBQUksQ0FBQ0YsS0FBS0csT0FBTyxDQUFDLENBQUNDO2dCQUN0QixJQUFJLENBQUNuQyxjQUFjb0MsUUFBUSxDQUFDRCxNQUFNO29CQUM5QkUsUUFBUUMsSUFBSSxDQUFDLHVEQUF1REg7Z0JBQ3hFO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT3BDLFVBQVVnQztBQUNyQixFQUVBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMS4wX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcz83Yjc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZvcm1hdCBmdW5jdGlvbiBtb2RpZmllZCBmcm9tIG5vZGVqc1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdFVybDogbnVsbCxcbiAgICB1cmxPYmplY3RLZXlzOiBudWxsLFxuICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGZvcm1hdFVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRVcmw7XG4gICAgfSxcbiAgICB1cmxPYmplY3RLZXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVybE9iamVjdEtleXM7XG4gICAgfSxcbiAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRXaXRoVmFsaWRhdGlvbjtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9xdWVyeXN0cmluZyA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCIuL3F1ZXJ5c3RyaW5nXCIpKTtcbmNvbnN0IHNsYXNoZWRQcm90b2NvbHMgPSAvaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87XG5mdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqKSB7XG4gICAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9iajtcbiAgICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgXCJcIjtcbiAgICBsZXQgcGF0aG5hbWUgPSB1cmxPYmoucGF0aG5hbWUgfHwgXCJcIjtcbiAgICBsZXQgaGFzaCA9IHVybE9iai5oYXNoIHx8IFwiXCI7XG4gICAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8IFwiXCI7XG4gICAgbGV0IGhvc3QgPSBmYWxzZTtcbiAgICBhdXRoID0gYXV0aCA/IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKS5yZXBsYWNlKC8lM0EvaSwgXCI6XCIpICsgXCJAXCIgOiBcIlwiO1xuICAgIGlmICh1cmxPYmouaG9zdCkge1xuICAgICAgICBob3N0ID0gYXV0aCArIHVybE9iai5ob3N0O1xuICAgIH0gZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICAgICAgaG9zdCA9IGF1dGggKyAofmhvc3RuYW1lLmluZGV4T2YoXCI6XCIpID8gXCJbXCIgKyBob3N0bmFtZSArIFwiXVwiIDogaG9zdG5hbWUpO1xuICAgICAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgICAgICAgIGhvc3QgKz0gXCI6XCIgKyB1cmxPYmoucG9ydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHF1ZXJ5ID0gU3RyaW5nKF9xdWVyeXN0cmluZy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHF1ZXJ5KSk7XG4gICAgfVxuICAgIGxldCBzZWFyY2ggPSB1cmxPYmouc2VhcmNoIHx8IHF1ZXJ5ICYmIFwiP1wiICsgcXVlcnkgfHwgXCJcIjtcbiAgICBpZiAocHJvdG9jb2wgJiYgIXByb3RvY29sLmVuZHNXaXRoKFwiOlwiKSkgcHJvdG9jb2wgKz0gXCI6XCI7XG4gICAgaWYgKHVybE9iai5zbGFzaGVzIHx8ICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29scy50ZXN0KHByb3RvY29sKSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgaG9zdCA9IFwiLy9cIiArIChob3N0IHx8IFwiXCIpO1xuICAgICAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWVbMF0gIT09IFwiL1wiKSBwYXRobmFtZSA9IFwiL1wiICsgcGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgICAgICBob3N0ID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gXCIjXCIpIGhhc2ggPSBcIiNcIiArIGhhc2g7XG4gICAgaWYgKHNlYXJjaCAmJiBzZWFyY2hbMF0gIT09IFwiP1wiKSBzZWFyY2ggPSBcIj9cIiArIHNlYXJjaDtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcbiAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZShcIiNcIiwgXCIlMjNcIik7XG4gICAgcmV0dXJuIFwiXCIgKyBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59XG5jb25zdCB1cmxPYmplY3RLZXlzID0gW1xuICAgIFwiYXV0aFwiLFxuICAgIFwiaGFzaFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwiaG9zdG5hbWVcIixcbiAgICBcImhyZWZcIixcbiAgICBcInBhdGhcIixcbiAgICBcInBhdGhuYW1lXCIsXG4gICAgXCJwb3J0XCIsXG4gICAgXCJwcm90b2NvbFwiLFxuICAgIFwicXVlcnlcIixcbiAgICBcInNlYXJjaFwiLFxuICAgIFwic2xhc2hlc1wiXG5dO1xuZnVuY3Rpb24gZm9ybWF0V2l0aFZhbGlkYXRpb24odXJsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh1cmwpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXVybE9iamVjdEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIGtleSBwYXNzZWQgdmlhIHVybE9iamVjdCBpbnRvIHVybC5mb3JtYXQ6IFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0VXJsKHVybCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC11cmwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZm9ybWF0VXJsIiwidXJsT2JqZWN0S2V5cyIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJfcXVlcnlzdHJpbmciLCJfIiwic2xhc2hlZFByb3RvY29scyIsInVybE9iaiIsImF1dGgiLCJob3N0bmFtZSIsInByb3RvY29sIiwicGF0aG5hbWUiLCJoYXNoIiwicXVlcnkiLCJob3N0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImluZGV4T2YiLCJwb3J0IiwiU3RyaW5nIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaCIsImVuZHNXaXRoIiwic2xhc2hlcyIsInRlc3QiLCJ1cmwiLCJwcm9jZXNzIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJpbmNsdWRlcyIsImNvbnNvbGUiLCJ3YXJuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/index.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \**********************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nconst _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nconst _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsaUJBQWlCO1FBQ2IsT0FBT1EsY0FBY1IsZUFBZTtJQUN4QztJQUNBQyxnQkFBZ0I7UUFDWixPQUFPUSxXQUFXUixjQUFjO0lBQ3BDO0FBQ0o7QUFDQSxNQUFNTyxnQkFBZ0JFLG1CQUFPQSxDQUFDLCtLQUFpQjtBQUMvQyxNQUFNRCxhQUFhQyxtQkFBT0EsQ0FBQyx5S0FBYyxHQUV6QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjEuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2luZGV4LmpzP2Y1YTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRTb3J0ZWRSb3V0ZXM6IG51bGwsXG4gICAgaXNEeW5hbWljUm91dGU6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZ2V0U29ydGVkUm91dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zb3J0ZWRyb3V0ZXMuZ2V0U29ydGVkUm91dGVzO1xuICAgIH0sXG4gICAgaXNEeW5hbWljUm91dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZTtcbiAgICB9XG59KTtcbmNvbnN0IF9zb3J0ZWRyb3V0ZXMgPSByZXF1aXJlKFwiLi9zb3J0ZWQtcm91dGVzXCIpO1xuY29uc3QgX2lzZHluYW1pYyA9IHJlcXVpcmUoXCIuL2lzLWR5bmFtaWNcIik7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImdldFNvcnRlZFJvdXRlcyIsImlzRHluYW1pY1JvdXRlIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3NvcnRlZHJvdXRlcyIsIl9pc2R5bmFtaWMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function() {\n        return interpolateAs;\n    }\n}));\nconst _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat, optional } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pbnRlcnBvbGF0ZS1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsaURBQWdEO0lBQzVDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsZ0JBQWdCQyxtQkFBT0EsQ0FBQywrS0FBaUI7QUFDL0MsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMktBQWU7QUFDM0MsU0FBU0YsY0FBY0ksS0FBSyxFQUFFQyxVQUFVLEVBQUVDLEtBQUs7SUFDM0MsSUFBSUMsb0JBQW9CO0lBQ3hCLE1BQU1DLGVBQWUsQ0FBQyxHQUFHTCxZQUFZTSxhQUFhLEVBQUVMO0lBQ3BELE1BQU1NLGdCQUFnQkYsYUFBYUcsTUFBTTtJQUN6QyxNQUFNQyxpQkFDTixDQUFDUCxlQUFlRCxRQUFRLENBQUMsR0FBR0gsY0FBY1ksZUFBZSxFQUFFTCxjQUFjSCxjQUFjLEVBQUMsS0FBTSxnREFBZ0Q7SUFDOUksc0VBQXNFO0lBQ3RFQztJQUNBQyxvQkFBb0JIO0lBQ3BCLE1BQU1VLFNBQVNwQixPQUFPcUIsSUFBSSxDQUFDTDtJQUMzQixJQUFJLENBQUNJLE9BQU9FLEtBQUssQ0FBQyxDQUFDQztRQUNmLElBQUlwQixRQUFRZSxjQUFjLENBQUNLLE1BQU0sSUFBSTtRQUNyQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdULGFBQWEsQ0FBQ08sTUFBTTtRQUNqRCxpQ0FBaUM7UUFDakMsMERBQTBEO1FBQzFELElBQUlHLFdBQVcsTUFBT0YsQ0FBQUEsU0FBUyxRQUFRLEVBQUMsSUFBS0QsUUFBUTtRQUNyRCxJQUFJRSxVQUFVO1lBQ1ZDLFdBQVcsQ0FBQyxDQUFDdkIsUUFBUSxNQUFNLEVBQUMsSUFBSyxNQUFNdUIsV0FBVztRQUN0RDtRQUNBLElBQUlGLFVBQVUsQ0FBQ0csTUFBTUMsT0FBTyxDQUFDekIsUUFBUUEsUUFBUTtZQUN6Q0E7U0FDSDtRQUNELE9BQU8sQ0FBQ3NCLFlBQVlGLFNBQVNMLGNBQWEsS0FBTSw2Q0FBNkM7UUFDNUZMLENBQUFBLG9CQUFvQkEsa0JBQWtCZ0IsT0FBTyxDQUFDSCxVQUFVRixTQUFTckIsTUFBTTJCLEdBQUcsQ0FDM0UsdURBQXVEO1FBQ3ZELGtEQUFrRDtRQUNsRCxvQ0FBb0M7UUFDcEMsQ0FBQ0MsVUFBVUMsbUJBQW1CRCxVQUFVRSxJQUFJLENBQUMsT0FBT0QsbUJBQW1CN0IsV0FBVyxHQUFFO0lBQ3hGLElBQUk7UUFDQVUsb0JBQW9CLEdBQUcsbUNBQW1DOztJQUU5RCx1RUFBdUU7SUFDdkUsa0RBQWtEO0lBQ2xEO0lBQ0EsT0FBTztRQUNITztRQUNBYyxRQUFRckI7SUFDWjtBQUNKLEVBRUEsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pbnRlcnBvbGF0ZS1hcy5qcz81MGJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW50ZXJwb2xhdGVBc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVBcztcbiAgICB9XG59KTtcbmNvbnN0IF9yb3V0ZW1hdGNoZXIgPSByZXF1aXJlKFwiLi9yb3V0ZS1tYXRjaGVyXCIpO1xuY29uc3QgX3JvdXRlcmVnZXggPSByZXF1aXJlKFwiLi9yb3V0ZS1yZWdleFwiKTtcbmZ1bmN0aW9uIGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSB7XG4gICAgbGV0IGludGVycG9sYXRlZFJvdXRlID0gXCJcIjtcbiAgICBjb25zdCBkeW5hbWljUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocm91dGUpO1xuICAgIGNvbnN0IGR5bmFtaWNHcm91cHMgPSBkeW5hbWljUmVnZXguZ3JvdXBzO1xuICAgIGNvbnN0IGR5bmFtaWNNYXRjaGVzID0gLy8gVHJ5IHRvIG1hdGNoIHRoZSBkeW5hbWljIHJvdXRlIGFnYWluc3QgdGhlIGFzUGF0aFxuICAgIChhc1BhdGhuYW1lICE9PSByb3V0ZSA/ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSA6IFwiXCIpIHx8IC8vIEZhbGwgYmFjayB0byByZWFkaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgaHJlZlxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cbiAgICBxdWVyeTtcbiAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9IHJvdXRlO1xuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5rZXlzKGR5bmFtaWNHcm91cHMpO1xuICAgIGlmICghcGFyYW1zLmV2ZXJ5KChwYXJhbSk9PntcbiAgICAgICAgbGV0IHZhbHVlID0gZHluYW1pY01hdGNoZXNbcGFyYW1dIHx8IFwiXCI7XG4gICAgICAgIGNvbnN0IHsgcmVwZWF0LCBvcHRpb25hbCB9ID0gZHluYW1pY0dyb3Vwc1twYXJhbV07XG4gICAgICAgIC8vIHN1cHBvcnQgc2luZ2xlLWxldmVsIGNhdGNoLWFsbFxuICAgICAgICAvLyBUT0RPOiBtb3JlIHJvYnVzdCBoYW5kbGluZyBmb3IgdXNlci1lcnJvciAocGFzc2luZyBgL2ApXG4gICAgICAgIGxldCByZXBsYWNlZCA9IFwiW1wiICsgKHJlcGVhdCA/IFwiLi4uXCIgOiBcIlwiKSArIHBhcmFtICsgXCJdXCI7XG4gICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgcmVwbGFjZWQgPSAoIXZhbHVlID8gXCIvXCIgOiBcIlwiKSArIFwiW1wiICsgcmVwbGFjZWQgKyBcIl1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwZWF0ICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKG9wdGlvbmFsIHx8IHBhcmFtIGluIGR5bmFtaWNNYXRjaGVzKSAmJiAvLyBJbnRlcnBvbGF0ZSBncm91cCBpbnRvIGRhdGEgVVJMIGlmIHByZXNlbnRcbiAgICAgICAgKGludGVycG9sYXRlZFJvdXRlID0gaW50ZXJwb2xhdGVkUm91dGUucmVwbGFjZShyZXBsYWNlZCwgcmVwZWF0ID8gdmFsdWUubWFwKC8vIHRoZXNlIHZhbHVlcyBzaG91bGQgYmUgZnVsbHkgZW5jb2RlZCBpbnN0ZWFkIG9mIGp1c3RcbiAgICAgICAgLy8gcGF0aCBkZWxpbWl0ZXIgZXNjYXBlZCBzaW5jZSB0aGV5IGFyZSBiZWluZyBpbnNlcnRlZFxuICAgICAgICAvLyBpbnRvIHRoZSBVUkwgYW5kIHdlIGV4cGVjdCBVUkwgZW5jb2RlZCBzZWdtZW50c1xuICAgICAgICAvLyB3aGVuIHBhcnNpbmcgZHluYW1pYyByb3V0ZSBwYXJhbXNcbiAgICAgICAgKHNlZ21lbnQpPT5lbmNvZGVVUklDb21wb25lbnQoc2VnbWVudCkpLmpvaW4oXCIvXCIpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSkgfHwgXCIvXCIpO1xuICAgIH0pKSB7XG4gICAgICAgIGludGVycG9sYXRlZFJvdXRlID0gXCJcIiAvLyBkaWQgbm90IHNhdGlzZnkgYWxsIHJlcXVpcmVtZW50c1xuICAgICAgICA7XG4gICAgLy8gbi5iLiBXZSBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHdlIGhhbmRsZSB3YXJuaW5nIGZvciB0aGlzIGNhc2UgaW5cbiAgICAvLyBkZXZlbG9wbWVudCBpbiB0aGUgYDxMaW5rPmAgY29tcG9uZW50IGRpcmVjdGx5LlxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHJlc3VsdDogaW50ZXJwb2xhdGVkUm91dGVcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnBvbGF0ZS1hcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaW50ZXJwb2xhdGVBcyIsIl9yb3V0ZW1hdGNoZXIiLCJyZXF1aXJlIiwiX3JvdXRlcmVnZXgiLCJyb3V0ZSIsImFzUGF0aG5hbWUiLCJxdWVyeSIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZ2V0Um91dGVSZWdleCIsImR5bmFtaWNHcm91cHMiLCJncm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInBhcmFtcyIsImtleXMiLCJldmVyeSIsInBhcmFtIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJyZXBsYWNlZCIsIkFycmF5IiwiaXNBcnJheSIsInJlcGxhY2UiLCJtYXAiLCJzZWdtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsInJlc3VsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function() {\n        return isDynamicRoute;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/server/future/helpers/interception-routes.js\");\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {\n        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;\n    }\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxrREFBaUQ7SUFDN0NJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxzQkFBc0JDLG1CQUFPQSxDQUFDLHlOQUF1RDtBQUMzRixxQ0FBcUM7QUFDckMsTUFBTUMsYUFBYTtBQUNuQixTQUFTSCxlQUFlSSxLQUFLO0lBQ3pCLElBQUksQ0FBQyxHQUFHSCxvQkFBb0JJLDBCQUEwQixFQUFFRCxRQUFRO1FBQzVEQSxRQUFRLENBQUMsR0FBR0gsb0JBQW9CSyxtQ0FBbUMsRUFBRUYsT0FBT0csZ0JBQWdCO0lBQ2hHO0lBQ0EsT0FBT0osV0FBV0ssSUFBSSxDQUFDSjtBQUMzQixFQUVBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMS4wX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcz9iZmNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNEeW5hbWljUm91dGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzRHluYW1pY1JvdXRlO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyY2VwdGlvbnJvdXRlcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9zZXJ2ZXIvZnV0dXJlL2hlbHBlcnMvaW50ZXJjZXB0aW9uLXJvdXRlc1wiKTtcbi8vIElkZW50aWZ5IC9bcGFyYW1dLyBpbiByb3V0ZSBzdHJpbmdcbmNvbnN0IFRFU1RfUk9VVEUgPSAvXFwvXFxbW14vXSs/XFxdKD89XFwvfCQpLztcbmZ1bmN0aW9uIGlzRHluYW1pY1JvdXRlKHJvdXRlKSB7XG4gICAgaWYgKCgwLCBfaW50ZXJjZXB0aW9ucm91dGVzLmlzSW50ZXJjZXB0aW9uUm91dGVBcHBQYXRoKShyb3V0ZSkpIHtcbiAgICAgICAgcm91dGUgPSAoMCwgX2ludGVyY2VwdGlvbnJvdXRlcy5leHRyYWN0SW50ZXJjZXB0aW9uUm91dGVJbmZvcm1hdGlvbikocm91dGUpLmludGVyY2VwdGVkUm91dGU7XG4gICAgfVxuICAgIHJldHVybiBURVNUX1JPVVRFLnRlc3Qocm91dGUpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1keW5hbWljLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJpc0R5bmFtaWNSb3V0ZSIsIl9pbnRlcmNlcHRpb25yb3V0ZXMiLCJyZXF1aXJlIiwiVEVTVF9ST1VURSIsInJvdXRlIiwiaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgiLCJleHRyYWN0SW50ZXJjZXB0aW9uUm91dGVJbmZvcm1hdGlvbiIsImludGVyY2VwdGVkUm91dGUiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \*****************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDhDQUE2QztJQUN6Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLHNKQUFhO0FBQ3BDLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLCtLQUFrQztBQUMvRCxTQUFTRixXQUFXSSxHQUFHO0lBQ25CLGdFQUFnRTtJQUNoRSxJQUFJLENBQUMsQ0FBQyxHQUFHSCxPQUFPSSxhQUFhLEVBQUVELE1BQU0sT0FBTztJQUM1QyxJQUFJO1FBQ0EsNERBQTREO1FBQzVELE1BQU1FLGlCQUFpQixDQUFDLEdBQUdMLE9BQU9NLGlCQUFpQjtRQUNuRCxNQUFNQyxXQUFXLElBQUlDLElBQUlMLEtBQUtFO1FBQzlCLE9BQU9FLFNBQVNFLE1BQU0sS0FBS0osa0JBQWtCLENBQUMsR0FBR0gsYUFBYVEsV0FBVyxFQUFFSCxTQUFTSSxRQUFRO0lBQ2hHLEVBQUUsT0FBT0MsR0FBRztRQUNSLE9BQU87SUFDWDtBQUNKLEVBRUEsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmwuanM/NjEyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzTG9jYWxVUkxcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzTG9jYWxVUkw7XG4gICAgfVxufSk7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBfaGFzYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGhcIik7XG5mdW5jdGlvbiBpc0xvY2FsVVJMKHVybCkge1xuICAgIC8vIHByZXZlbnQgYSBoeWRyYXRpb24gbWlzbWF0Y2ggb24gaHJlZiBmb3IgdXJsIHdpdGggYW5jaG9yIHJlZnNcbiAgICBpZiAoISgwLCBfdXRpbHMuaXNBYnNvbHV0ZVVybCkodXJsKSkgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uT3JpZ2luID0gKDAsIF91dGlscy5nZXRMb2NhdGlvbk9yaWdpbikoKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBuZXcgVVJMKHVybCwgbG9jYXRpb25PcmlnaW4pO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShyZXNvbHZlZC5wYXRobmFtZSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1sb2NhbC11cmwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImlzTG9jYWxVUkwiLCJfdXRpbHMiLCJyZXF1aXJlIiwiX2hhc2Jhc2VwYXRoIiwidXJsIiwiaXNBYnNvbHV0ZVVybCIsImxvY2F0aW9uT3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsIlVSTCIsIm9yaWdpbiIsImhhc0Jhc2VQYXRoIiwicGF0aG5hbWUiLCJfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!*********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \*********************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9vbWl0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCx3Q0FBdUM7SUFDbkNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixTQUFTQSxLQUFLQyxNQUFNLEVBQUVDLElBQUk7SUFDdEIsTUFBTUMsVUFBVSxDQUFDO0lBQ2pCVCxPQUFPUSxJQUFJLENBQUNELFFBQVFHLE9BQU8sQ0FBQyxDQUFDQztRQUN6QixJQUFJLENBQUNILEtBQUtJLFFBQVEsQ0FBQ0QsTUFBTTtZQUNyQkYsT0FBTyxDQUFDRSxJQUFJLEdBQUdKLE1BQU0sQ0FBQ0ksSUFBSTtRQUM5QjtJQUNKO0lBQ0EsT0FBT0Y7QUFDWCxFQUVBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMS4wX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC5qcz81NWE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwib21pdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gb21pdDtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIG9taXQob2JqZWN0LCBrZXlzKSB7XG4gICAgY29uc3Qgb21pdHRlZCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgb21pdHRlZFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb21pdHRlZDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b21pdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwib21pdCIsIm9iamVjdCIsImtleXMiLCJvbWl0dGVkIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!****************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \****************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    },\n    assign: function() {\n        return assign;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUlOO0FBQ0EsU0FBU0ksUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVYsT0FBT0MsY0FBYyxDQUFDUSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFOLFNBQVM7SUFDYkcsd0JBQXdCO1FBQ3BCLE9BQU9BO0lBQ1g7SUFDQUMsd0JBQXdCO1FBQ3BCLE9BQU9BO0lBQ1g7SUFDQUMsUUFBUTtRQUNKLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLFNBQVNGLHVCQUF1QlMsWUFBWTtJQUN4QyxNQUFNQyxRQUFRLENBQUM7SUFDZkQsYUFBYUUsT0FBTyxDQUFDLENBQUNiLE9BQU9jO1FBQ3pCLElBQUksT0FBT0YsS0FBSyxDQUFDRSxJQUFJLEtBQUssYUFBYTtZQUNuQ0YsS0FBSyxDQUFDRSxJQUFJLEdBQUdkO1FBQ2pCLE9BQU8sSUFBSWUsTUFBTUMsT0FBTyxDQUFDSixLQUFLLENBQUNFLElBQUksR0FBRztZQUNsQ0YsS0FBSyxDQUFDRSxJQUFJLENBQUNHLElBQUksQ0FBQ2pCO1FBQ3BCLE9BQU87WUFDSFksS0FBSyxDQUFDRSxJQUFJLEdBQUc7Z0JBQ1RGLEtBQUssQ0FBQ0UsSUFBSTtnQkFDVmQ7YUFDSDtRQUNMO0lBQ0o7SUFDQSxPQUFPWTtBQUNYO0FBQ0EsU0FBU00sdUJBQXVCQyxLQUFLO0lBQ2pDLElBQUksT0FBT0EsVUFBVSxZQUFZLE9BQU9BLFVBQVUsWUFBWSxDQUFDQyxNQUFNRCxVQUFVLE9BQU9BLFVBQVUsV0FBVztRQUN2RyxPQUFPRSxPQUFPRjtJQUNsQixPQUFPO1FBQ0gsT0FBTztJQUNYO0FBQ0o7QUFDQSxTQUFTaEIsdUJBQXVCbUIsUUFBUTtJQUNwQyxNQUFNQyxTQUFTLElBQUlDO0lBQ25CM0IsT0FBTzRCLE9BQU8sQ0FBQ0gsVUFBVVQsT0FBTyxDQUFDLENBQUNNO1FBQzlCLElBQUksQ0FBQ0wsS0FBS2QsTUFBTSxHQUFHbUI7UUFDbkIsSUFBSUosTUFBTUMsT0FBTyxDQUFDaEIsUUFBUTtZQUN0QkEsTUFBTWEsT0FBTyxDQUFDLENBQUNhLE9BQU9ILE9BQU9JLE1BQU0sQ0FBQ2IsS0FBS0ksdUJBQXVCUTtRQUNwRSxPQUFPO1lBQ0hILE9BQU9LLEdBQUcsQ0FBQ2QsS0FBS0ksdUJBQXVCbEI7UUFDM0M7SUFDSjtJQUNBLE9BQU91QjtBQUNYO0FBQ0EsU0FBU25CLE9BQU9FLE1BQU07SUFDbEIsSUFBSSxJQUFJdUIsT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyxtQkFBbUIsSUFBSWpCLE1BQU1jLE9BQU8sSUFBSUEsT0FBTyxJQUFJLElBQUlJLE9BQU8sR0FBR0EsT0FBT0osTUFBTUksT0FBTztRQUNsSEQsZ0JBQWdCLENBQUNDLE9BQU8sRUFBRSxHQUFHSCxTQUFTLENBQUNHLEtBQUs7SUFDaEQ7SUFDQUQsaUJBQWlCbkIsT0FBTyxDQUFDLENBQUNGO1FBQ3RCSSxNQUFNbUIsSUFBSSxDQUFDdkIsYUFBYXdCLElBQUksSUFBSXRCLE9BQU8sQ0FBQyxDQUFDQyxNQUFNUixPQUFPOEIsTUFBTSxDQUFDdEI7UUFDN0RILGFBQWFFLE9BQU8sQ0FBQyxDQUFDYixPQUFPYyxNQUFNUixPQUFPcUIsTUFBTSxDQUFDYixLQUFLZDtJQUMxRDtJQUNBLE9BQU9NO0FBQ1gsRUFFQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjEuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLmpzPzdhMDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5OiBudWxsLFxuICAgIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXM6IG51bGwsXG4gICAgYXNzaWduOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VhcmNoUGFyYW1zVG9VcmxRdWVyeTtcbiAgICB9LFxuICAgIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcztcbiAgICB9LFxuICAgIGFzc2lnbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhc3NpZ247XG4gICAgfVxufSk7XG5mdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcykge1xuICAgIGNvbnN0IHF1ZXJ5ID0ge307XG4gICAgc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpPT57XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcXVlcnlba2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlba2V5XSkpIHtcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gW1xuICAgICAgICAgICAgICAgIHF1ZXJ5W2tleV0sXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcXVlcnk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcGFyYW0gPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHBhcmFtKSB8fCB0eXBlb2YgcGFyYW0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcocGFyYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXModXJsUXVlcnkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgT2JqZWN0LmVudHJpZXModXJsUXVlcnkpLmZvckVhY2goKHBhcmFtKT0+e1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gcGFyYW07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSk9PnJlc3VsdC5hcHBlbmQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKGl0ZW0pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzZWFyY2hQYXJhbXNMaXN0ID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICBzZWFyY2hQYXJhbXNMaXN0W19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgc2VhcmNoUGFyYW1zTGlzdC5mb3JFYWNoKChzZWFyY2hQYXJhbXMpPT57XG4gICAgICAgIEFycmF5LmZyb20oc2VhcmNoUGFyYW1zLmtleXMoKSkuZm9yRWFjaCgoa2V5KT0+dGFyZ2V0LmRlbGV0ZShrZXkpKTtcbiAgICAgICAgc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpPT50YXJnZXQuYXBwZW5kKGtleSwgdmFsdWUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeXN0cmluZy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsImFzc2lnbiIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsInNlYXJjaFBhcmFtcyIsInF1ZXJ5IiwiZm9yRWFjaCIsImtleSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJzdHJpbmdpZnlVcmxRdWVyeVBhcmFtIiwicGFyYW0iLCJpc05hTiIsIlN0cmluZyIsInVybFF1ZXJ5IiwicmVzdWx0IiwiVVJMU2VhcmNoUGFyYW1zIiwiZW50cmllcyIsIml0ZW0iLCJhcHBlbmQiLCJzZXQiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic2VhcmNoUGFyYW1zTGlzdCIsIl9rZXkiLCJmcm9tIiwia2V5cyIsImRlbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \******************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function() {\n        return getRouteMatcher;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    let { re, groups } = param;\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxzSkFBYTtBQUNwQyxTQUFTRixnQkFBZ0JHLEtBQUs7SUFDMUIsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLE1BQU0sRUFBRSxHQUFHRjtJQUNyQixPQUFPLENBQUNHO1FBQ0osTUFBTUMsYUFBYUgsR0FBR0ksSUFBSSxDQUFDRjtRQUMzQixJQUFJLENBQUNDLFlBQVk7WUFDYixPQUFPO1FBQ1g7UUFDQSxNQUFNRSxTQUFTLENBQUNOO1lBQ1osSUFBSTtnQkFDQSxPQUFPTyxtQkFBbUJQO1lBQzlCLEVBQUUsT0FBT1EsR0FBRztnQkFDUixNQUFNLElBQUlWLE9BQU9XLFdBQVcsQ0FBQztZQUNqQztRQUNKO1FBQ0EsTUFBTUMsU0FBUyxDQUFDO1FBQ2hCbkIsT0FBT29CLElBQUksQ0FBQ1QsUUFBUVUsT0FBTyxDQUFDLENBQUNDO1lBQ3pCLE1BQU1DLElBQUlaLE1BQU0sQ0FBQ1csU0FBUztZQUMxQixNQUFNRSxJQUFJWCxVQUFVLENBQUNVLEVBQUVFLEdBQUcsQ0FBQztZQUMzQixJQUFJRCxNQUFNRSxXQUFXO2dCQUNqQlAsTUFBTSxDQUFDRyxTQUFTLEdBQUcsQ0FBQ0UsRUFBRUcsT0FBTyxDQUFDLE9BQU9ILEVBQUVJLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0MsUUFBUWYsT0FBT2UsVUFBVVAsRUFBRVEsTUFBTSxHQUFHO29CQUN2RmhCLE9BQU9TO2lCQUNWLEdBQUdULE9BQU9TO1lBQ2Y7UUFDSjtRQUNBLE9BQU9MO0lBQ1g7QUFDSixFQUVBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMS4wX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcz9kZDVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Um91dGVNYXRjaGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRSb3V0ZU1hdGNoZXI7XG4gICAgfVxufSk7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5mdW5jdGlvbiBnZXRSb3V0ZU1hdGNoZXIocGFyYW0pIHtcbiAgICBsZXQgeyByZSwgZ3JvdXBzIH0gPSBwYXJhbTtcbiAgICByZXR1cm4gKHBhdGhuYW1lKT0+e1xuICAgICAgICBjb25zdCByb3V0ZU1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSk7XG4gICAgICAgIGlmICghcm91dGVNYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY29kZSA9IChwYXJhbSk9PntcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSk7XG4gICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IF91dGlscy5EZWNvZGVFcnJvcihcImZhaWxlZCB0byBkZWNvZGUgcGFyYW1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKHNsdWdOYW1lKT0+e1xuICAgICAgICAgICAgY29uc3QgZyA9IGdyb3Vwc1tzbHVnTmFtZV07XG4gICAgICAgICAgICBjb25zdCBtID0gcm91dGVNYXRjaFtnLnBvc107XG4gICAgICAgICAgICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IH5tLmluZGV4T2YoXCIvXCIpID8gbS5zcGxpdChcIi9cIikubWFwKChlbnRyeSk9PmRlY29kZShlbnRyeSkpIDogZy5yZXBlYXQgPyBbXG4gICAgICAgICAgICAgICAgICAgIGRlY29kZShtKVxuICAgICAgICAgICAgICAgIF0gOiBkZWNvZGUobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlLW1hdGNoZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldFJvdXRlTWF0Y2hlciIsIl91dGlscyIsInJlcXVpcmUiLCJwYXJhbSIsInJlIiwiZ3JvdXBzIiwicGF0aG5hbWUiLCJyb3V0ZU1hdGNoIiwiZXhlYyIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsIl8iLCJEZWNvZGVFcnJvciIsInBhcmFtcyIsImtleXMiLCJmb3JFYWNoIiwic2x1Z05hbWUiLCJnIiwibSIsInBvcyIsInVuZGVmaW5lZCIsImluZGV4T2YiLCJzcGxpdCIsIm1hcCIsImVudHJ5IiwicmVwZWF0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!****************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \****************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRouteRegex: function() {\n        return getRouteRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/server/future/helpers/interception-routes.js\");\nconst _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/escape-regexp.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                const [usedMarker] = segment.split(paramMatches[0]);\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUlOO0FBQ0EsU0FBU0ksUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVYsT0FBT0MsY0FBYyxDQUFDUSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFOLFNBQVM7SUFDYkcsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUMseUJBQXlCO1FBQ3JCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLHNCQUFzQkMsbUJBQU9BLENBQUMseU5BQXVEO0FBQzNGLE1BQU1DLGdCQUFnQkQsbUJBQU9BLENBQUMsc0tBQXFCO0FBQ25ELE1BQU1FLHVCQUF1QkYsbUJBQU9BLENBQUMsK0xBQXlCO0FBQzlELE1BQU1HLDBCQUEwQjtBQUNoQyxNQUFNQyxrQ0FBa0M7QUFDeEM7Ozs7Ozs7Q0FPQyxHQUFHLFNBQVNDLGVBQWVDLEtBQUs7SUFDN0IsTUFBTUMsV0FBV0QsTUFBTUUsVUFBVSxDQUFDLFFBQVFGLE1BQU1HLFFBQVEsQ0FBQztJQUN6RCxJQUFJRixVQUFVO1FBQ1ZELFFBQVFBLE1BQU1JLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDNUI7SUFDQSxNQUFNQyxTQUFTTCxNQUFNRSxVQUFVLENBQUM7SUFDaEMsSUFBSUcsUUFBUTtRQUNSTCxRQUFRQSxNQUFNSSxLQUFLLENBQUM7SUFDeEI7SUFDQSxP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QUFZLENBQUMsRUFBRTtvQkFDeEJtQjtvQkFDQUMsV0FBV1Msa0JBQWtCckQsMEJBQTBCMEQ7Z0JBQzNEO1lBQ0osT0FBTztnQkFDSCxPQUFPLE1BQU0sQ0FBQyxHQUFHNUQsY0FBYzZCLGtCQUFrQixFQUFFUjtZQUN2RDtRQUNKLEdBQUdTLElBQUksQ0FBQztRQUNSZTtJQUNKO0FBQ0o7QUFDQSxTQUFTdkQsbUJBQW1CeUMsZUFBZSxFQUFFOEIsY0FBYztJQUN2RCxNQUFNQyxTQUFTUiwwQkFBMEJ2QixpQkFBaUI4QjtJQUMxRCxPQUFPO1FBQ0gsR0FBR3hFLGNBQWMwQyxnQkFBZ0I7UUFDakNnQyxZQUFZLE1BQU1ELE9BQU9OLHVCQUF1QixHQUFHO1FBQ25EWCxXQUFXaUIsT0FBT2pCLFNBQVM7SUFDL0I7QUFDSjtBQUNBLFNBQVN0RCx3QkFBd0J3QyxlQUFlLEVBQUVpQyxPQUFPO0lBQ3JELE1BQU0sRUFBRTdDLGtCQUFrQixFQUFFLEdBQUdQLHFCQUFxQm1CO0lBQ3BELE1BQU0sRUFBRWtDLFdBQVcsSUFBSSxFQUFFLEdBQUdEO0lBQzVCLElBQUk3Qyx1QkFBdUIsS0FBSztRQUM1QixJQUFJK0MsZ0JBQWdCRCxXQUFXLE9BQU87UUFDdEMsT0FBTztZQUNIRixZQUFZLE9BQU9HLGdCQUFnQjtRQUN2QztJQUNKO0lBQ0EsTUFBTSxFQUFFVix1QkFBdUIsRUFBRSxHQUFHRiwwQkFBMEJ2QixpQkFBaUI7SUFDL0UsSUFBSW9DLHVCQUF1QkYsV0FBVyxlQUFlO0lBQ3JELE9BQU87UUFDSEYsWUFBWSxNQUFNUCwwQkFBMEJXLHVCQUF1QjtJQUN2RTtBQUNKLEVBRUEsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC5qcz8yMDU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZ2V0Um91dGVSZWdleDogbnVsbCxcbiAgICBnZXROYW1lZFJvdXRlUmVnZXg6IG51bGwsXG4gICAgZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZ2V0Um91dGVSZWdleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRSb3V0ZVJlZ2V4O1xuICAgIH0sXG4gICAgZ2V0TmFtZWRSb3V0ZVJlZ2V4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldE5hbWVkUm91dGVSZWdleDtcbiAgICB9LFxuICAgIGdldE5hbWVkTWlkZGxld2FyZVJlZ2V4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldE5hbWVkTWlkZGxld2FyZVJlZ2V4O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyY2VwdGlvbnJvdXRlcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9zZXJ2ZXIvZnV0dXJlL2hlbHBlcnMvaW50ZXJjZXB0aW9uLXJvdXRlc1wiKTtcbmNvbnN0IF9lc2NhcGVyZWdleHAgPSByZXF1aXJlKFwiLi4vLi4vZXNjYXBlLXJlZ2V4cFwiKTtcbmNvbnN0IF9yZW1vdmV0cmFpbGluZ3NsYXNoID0gcmVxdWlyZShcIi4vcmVtb3ZlLXRyYWlsaW5nLXNsYXNoXCIpO1xuY29uc3QgTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVggPSBcIm54dFBcIjtcbmNvbnN0IE5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVggPSBcIm54dElcIjtcbi8qKlxuICogUGFyc2VzIGEgZ2l2ZW4gcGFyYW1ldGVyIGZyb20gYSByb3V0ZSB0byBhIGRhdGEgc3RydWN0dXJlIHRoYXQgY2FuIGJlIHVzZWRcbiAqIHRvIGdlbmVyYXRlIHRoZSBwYXJhbWV0cml6ZWQgcm91dGUuIEV4YW1wbGVzOlxuICogICAtIGBbLi4uc2x1Z11gIC0+IGB7IGtleTogJ3NsdWcnLCByZXBlYXQ6IHRydWUsIG9wdGlvbmFsOiB0cnVlIH1gXG4gKiAgIC0gYC4uLnNsdWdgIC0+IGB7IGtleTogJ3NsdWcnLCByZXBlYXQ6IHRydWUsIG9wdGlvbmFsOiBmYWxzZSB9YFxuICogICAtIGBbZm9vXWAgLT4gYHsga2V5OiAnZm9vJywgcmVwZWF0OiBmYWxzZSwgb3B0aW9uYWw6IHRydWUgfWBcbiAqICAgLSBgYmFyYCAtPiBgeyBrZXk6ICdiYXInLCByZXBlYXQ6IGZhbHNlLCBvcHRpb25hbDogZmFsc2UgfWBcbiAqLyBmdW5jdGlvbiBwYXJzZVBhcmFtZXRlcihwYXJhbSkge1xuICAgIGNvbnN0IG9wdGlvbmFsID0gcGFyYW0uc3RhcnRzV2l0aChcIltcIikgJiYgcGFyYW0uZW5kc1dpdGgoXCJdXCIpO1xuICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgY29uc3QgcmVwZWF0ID0gcGFyYW0uc3RhcnRzV2l0aChcIi4uLlwiKTtcbiAgICBpZiAocmVwZWF0KSB7XG4gICAgICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGtleTogcGFyYW0sXG4gICAgICAgIHJlcGVhdCxcbiAgICAgICAgb3B0aW9uYWxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0UGFyYW1ldHJpemVkUm91dGUocm91dGUpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShyb3V0ZSkuc2xpY2UoMSkuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuICAgIGxldCBncm91cEluZGV4ID0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbWV0ZXJpemVkUm91dGU6IHNlZ21lbnRzLm1hcCgoc2VnbWVudCk9PntcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlck1hdGNoID0gX2ludGVyY2VwdGlvbnJvdXRlcy5JTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5maW5kKChtKT0+c2VnbWVudC5zdGFydHNXaXRoKG0pKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtTWF0Y2hlcyA9IHNlZ21lbnQubWF0Y2goL1xcWygoPzpcXFsuKlxcXSl8LispXFxdLykgLy8gQ2hlY2sgZm9yIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmIChtYXJrZXJNYXRjaCAmJiBwYXJhbU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleSwgb3B0aW9uYWwsIHJlcGVhdCB9ID0gcGFyc2VQYXJhbWV0ZXIocGFyYW1NYXRjaGVzWzFdKTtcbiAgICAgICAgICAgICAgICBncm91cHNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBncm91cEluZGV4KyssXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIiArICgwLCBfZXNjYXBlcmVnZXhwLmVzY2FwZVN0cmluZ1JlZ2V4cCkobWFya2VyTWF0Y2gpICsgXCIoW14vXSs/KVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleSwgcmVwZWF0LCBvcHRpb25hbCB9ID0gcGFyc2VQYXJhbWV0ZXIocGFyYW1NYXRjaGVzWzFdKTtcbiAgICAgICAgICAgICAgICBncm91cHNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBncm91cEluZGV4KyssXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBlYXQgPyBvcHRpb25hbCA/IFwiKD86LyguKz8pKT9cIiA6IFwiLyguKz8pXCIgOiBcIi8oW14vXSs/KVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCIgKyAoMCwgX2VzY2FwZXJlZ2V4cC5lc2NhcGVTdHJpbmdSZWdleHApKHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICBncm91cHNcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Um91dGVSZWdleChub3JtYWxpemVkUm91dGUpIHtcbiAgICBjb25zdCB7IHBhcmFtZXRlcml6ZWRSb3V0ZSwgZ3JvdXBzIH0gPSBnZXRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlOiBuZXcgUmVnRXhwKFwiXlwiICsgcGFyYW1ldGVyaXplZFJvdXRlICsgXCIoPzovKT8kXCIpLFxuICAgICAgICBncm91cHM6IGdyb3Vwc1xuICAgIH07XG59XG4vKipcbiAqIEJ1aWxkcyBhIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgbWluaW1hbCByb3V0ZUtleSB1c2luZyBvbmx5IGEteiBhbmQgbWluaW1hbFxuICogbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gKi8gZnVuY3Rpb24gYnVpbGRHZXRTYWZlUm91dGVLZXkoKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBsZXQgcm91dGVLZXkgPSBcIlwiO1xuICAgICAgICBsZXQgaiA9ICsraTtcbiAgICAgICAgd2hpbGUoaiA+IDApe1xuICAgICAgICAgICAgcm91dGVLZXkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArIChqIC0gMSkgJSAyNik7XG4gICAgICAgICAgICBqID0gTWF0aC5mbG9vcigoaiAtIDEpIC8gMjYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3V0ZUtleTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2FmZUtleUZyb21TZWdtZW50KHBhcmFtKSB7XG4gICAgbGV0IHsgaW50ZXJjZXB0aW9uTWFya2VyLCBnZXRTYWZlUm91dGVLZXksIHNlZ21lbnQsIHJvdXRlS2V5cywga2V5UHJlZml4IH0gPSBwYXJhbTtcbiAgICBjb25zdCB7IGtleSwgb3B0aW9uYWwsIHJlcGVhdCB9ID0gcGFyc2VQYXJhbWV0ZXIoc2VnbWVudCk7XG4gICAgLy8gcmVwbGFjZSBhbnkgbm9uLXdvcmQgY2hhcmFjdGVycyBzaW5jZSB0aGV5IGNhbiBicmVha1xuICAgIC8vIHRoZSBuYW1lZCByZWdleFxuICAgIGxldCBjbGVhbmVkS2V5ID0ga2V5LnJlcGxhY2UoL1xcVy9nLCBcIlwiKTtcbiAgICBpZiAoa2V5UHJlZml4KSB7XG4gICAgICAgIGNsZWFuZWRLZXkgPSBcIlwiICsga2V5UHJlZml4ICsgY2xlYW5lZEtleTtcbiAgICB9XG4gICAgbGV0IGludmFsaWRLZXkgPSBmYWxzZTtcbiAgICAvLyBjaGVjayBpZiB0aGUga2V5IGlzIHN0aWxsIGludmFsaWQgYW5kIGZhbGxiYWNrIHRvIHVzaW5nIGEga25vd25cbiAgICAvLyBzYWZlIGtleVxuICAgIGlmIChjbGVhbmVkS2V5Lmxlbmd0aCA9PT0gMCB8fCBjbGVhbmVkS2V5Lmxlbmd0aCA+IDMwKSB7XG4gICAgICAgIGludmFsaWRLZXkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKHBhcnNlSW50KGNsZWFuZWRLZXkuc2xpY2UoMCwgMSkpKSkge1xuICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGludmFsaWRLZXkpIHtcbiAgICAgICAgY2xlYW5lZEtleSA9IGdldFNhZmVSb3V0ZUtleSgpO1xuICAgIH1cbiAgICBpZiAoa2V5UHJlZml4KSB7XG4gICAgICAgIHJvdXRlS2V5c1tjbGVhbmVkS2V5XSA9IFwiXCIgKyBrZXlQcmVmaXggKyBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0ga2V5O1xuICAgIH1cbiAgICAvLyBpZiB0aGUgc2VnbWVudCBoYXMgYW4gaW50ZXJjZXB0aW9uIG1hcmtlciwgbWFrZSBzdXJlIHRoYXQncyBwYXJ0IG9mIHRoZSByZWdleCBwYXR0ZXJuXG4gICAgLy8gdGhpcyBpcyB0byBlbnN1cmUgdGhhdCB0aGUgcm91dGUgd2l0aCB0aGUgaW50ZXJjZXB0aW9uIG1hcmtlciBkb2Vzbid0IGluY29ycmVjdGx5IG1hdGNoXG4gICAgLy8gdGhlIG5vbi1pbnRlcmNlcHRlZCByb3V0ZSAoaWUgL2FwcC8oLilbdXNlcm5hbWVdIHNob3VsZCBub3QgbWF0Y2ggL2FwcC9bdXNlcm5hbWVdKVxuICAgIGNvbnN0IGludGVyY2VwdGlvblByZWZpeCA9IGludGVyY2VwdGlvbk1hcmtlciA/ICgwLCBfZXNjYXBlcmVnZXhwLmVzY2FwZVN0cmluZ1JlZ2V4cCkoaW50ZXJjZXB0aW9uTWFya2VyKSA6IFwiXCI7XG4gICAgcmV0dXJuIHJlcGVhdCA/IG9wdGlvbmFsID8gXCIoPzovXCIgKyBpbnRlcmNlcHRpb25QcmVmaXggKyBcIig/PFwiICsgY2xlYW5lZEtleSArIFwiPi4rPykpP1wiIDogXCIvXCIgKyBpbnRlcmNlcHRpb25QcmVmaXggKyBcIig/PFwiICsgY2xlYW5lZEtleSArIFwiPi4rPylcIiA6IFwiL1wiICsgaW50ZXJjZXB0aW9uUHJlZml4ICsgXCIoPzxcIiArIGNsZWFuZWRLZXkgKyBcIj5bXi9dKz8pXCI7XG59XG5mdW5jdGlvbiBnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlKHJvdXRlLCBwcmVmaXhSb3V0ZUtleXMpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShyb3V0ZSkuc2xpY2UoMSkuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IGdldFNhZmVSb3V0ZUtleSA9IGJ1aWxkR2V0U2FmZVJvdXRlS2V5KCk7XG4gICAgY29uc3Qgcm91dGVLZXlzID0ge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGU6IHNlZ21lbnRzLm1hcCgoc2VnbWVudCk9PntcbiAgICAgICAgICAgIGNvbnN0IGhhc0ludGVyY2VwdGlvbk1hcmtlciA9IF9pbnRlcmNlcHRpb25yb3V0ZXMuSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMuc29tZSgobSk9PnNlZ21lbnQuc3RhcnRzV2l0aChtKSk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbU1hdGNoZXMgPSBzZWdtZW50Lm1hdGNoKC9cXFsoKD86XFxbLipcXF0pfC4rKVxcXS8pIC8vIENoZWNrIGZvciBwYXJhbWV0ZXJzXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBpZiAoaGFzSW50ZXJjZXB0aW9uTWFya2VyICYmIHBhcmFtTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt1c2VkTWFya2VyXSA9IHNlZ21lbnQuc3BsaXQocGFyYW1NYXRjaGVzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2FmZUtleUZyb21TZWdtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2FmZVJvdXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmNlcHRpb25NYXJrZXI6IHVzZWRNYXJrZXIsXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHBhcmFtTWF0Y2hlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVLZXlzLFxuICAgICAgICAgICAgICAgICAgICBrZXlQcmVmaXg6IHByZWZpeFJvdXRlS2V5cyA/IE5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVggOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1NYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNhZmVLZXlGcm9tU2VnbWVudCh7XG4gICAgICAgICAgICAgICAgICAgIGdldFNhZmVSb3V0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudDogcGFyYW1NYXRjaGVzWzFdLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgIGtleVByZWZpeDogcHJlZml4Um91dGVLZXlzID8gTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVggOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShzZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuam9pbihcIlwiKSxcbiAgICAgICAgcm91dGVLZXlzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkUm91dGVSZWdleChub3JtYWxpemVkUm91dGUsIHByZWZpeFJvdXRlS2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0TmFtZWRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUsIHByZWZpeFJvdXRlS2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5nZXRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSksXG4gICAgICAgIG5hbWVkUmVnZXg6IFwiXlwiICsgcmVzdWx0Lm5hbWVkUGFyYW1ldGVyaXplZFJvdXRlICsgXCIoPzovKT8kXCIsXG4gICAgICAgIHJvdXRlS2V5czogcmVzdWx0LnJvdXRlS2V5c1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXROYW1lZE1pZGRsZXdhcmVSZWdleChub3JtYWxpemVkUm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHBhcmFtZXRlcml6ZWRSb3V0ZSB9ID0gZ2V0UGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlKTtcbiAgICBjb25zdCB7IGNhdGNoQWxsID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAocGFyYW1ldGVyaXplZFJvdXRlID09PSBcIi9cIikge1xuICAgICAgICBsZXQgY2F0Y2hBbGxSZWdleCA9IGNhdGNoQWxsID8gXCIuKlwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWVkUmVnZXg6IFwiXi9cIiArIGNhdGNoQWxsUmVnZXggKyBcIiRcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlIH0gPSBnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSwgZmFsc2UpO1xuICAgIGxldCBjYXRjaEFsbEdyb3VwZWRSZWdleCA9IGNhdGNoQWxsID8gXCIoPzooLy4qKT8pXCIgOiBcIlwiO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWVkUmVnZXg6IFwiXlwiICsgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgKyBjYXRjaEFsbEdyb3VwZWRSZWdleCArIFwiJFwiXG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtcmVnZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0Um91dGVSZWdleCIsImdldE5hbWVkUm91dGVSZWdleCIsImdldE5hbWVkTWlkZGxld2FyZVJlZ2V4IiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2ludGVyY2VwdGlvbnJvdXRlcyIsInJlcXVpcmUiLCJfZXNjYXBlcmVnZXhwIiwiX3JlbW92ZXRyYWlsaW5nc2xhc2giLCJORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCIsIk5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVgiLCJwYXJzZVBhcmFtZXRlciIsInBhcmFtIiwib3B0aW9uYWwiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzbGljZSIsInJlcGVhdCIsImtleSIsImdldFBhcmFtZXRyaXplZFJvdXRlIiwicm91dGUiLCJzZWdtZW50cyIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJzcGxpdCIsImdyb3VwcyIsImdyb3VwSW5kZXgiLCJwYXJhbWV0ZXJpemVkUm91dGUiLCJtYXAiLCJzZWdtZW50IiwibWFya2VyTWF0Y2giLCJJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyIsImZpbmQiLCJtIiwicGFyYW1NYXRjaGVzIiwibWF0Y2giLCJwb3MiLCJlc2NhcGVTdHJpbmdSZWdleHAiLCJqb2luIiwibm9ybWFsaXplZFJvdXRlIiwicmUiLCJSZWdFeHAiLCJidWlsZEdldFNhZmVSb3V0ZUtleSIsImkiLCJyb3V0ZUtleSIsImoiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJNYXRoIiwiZmxvb3IiLCJnZXRTYWZlS2V5RnJvbVNlZ21lbnQiLCJpbnRlcmNlcHRpb25NYXJrZXIiLCJnZXRTYWZlUm91dGVLZXkiLCJyb3V0ZUtleXMiLCJrZXlQcmVmaXgiLCJjbGVhbmVkS2V5IiwicmVwbGFjZSIsImludmFsaWRLZXkiLCJsZW5ndGgiLCJpc05hTiIsInBhcnNlSW50IiwiaW50ZXJjZXB0aW9uUHJlZml4IiwiZ2V0TmFtZWRQYXJhbWV0cml6ZWRSb3V0ZSIsInByZWZpeFJvdXRlS2V5cyIsIm5hbWVkUGFyYW1ldGVyaXplZFJvdXRlIiwiaGFzSW50ZXJjZXB0aW9uTWFya2VyIiwic29tZSIsInVzZWRNYXJrZXIiLCJ1bmRlZmluZWQiLCJwcmVmaXhSb3V0ZUtleSIsInJlc3VsdCIsIm5hbWVkUmVnZXgiLCJvcHRpb25zIiwiY2F0Y2hBbGwiLCJjYXRjaEFsbFJlZ2V4IiwiY2F0Y2hBbGxHcm91cGVkUmVnZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \******************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function() {\n        return getSortedRoutes;\n    }\n}));\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix) {\n        if (prefix === void 0) prefix = \"/\";\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\" + prefix + c + \"/\")).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\"));\n        }\n        if (!this.placeholder) {\n            const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\"));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\"));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(\"Catch-all must be the last part of the URL.\");\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith(\"...\")) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n            }\n            if (segmentName.startsWith(\".\")) {\n                throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                    }\n                    if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                        throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = \"[[...]]\";\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = \"[...]\";\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = \"[]\";\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9zb3J0ZWQtcm91dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQztJQUNGQyxPQUFPQyxPQUFPLEVBQUU7UUFDWixJQUFJLENBQUNDLE9BQU8sQ0FBQ0QsUUFBUUUsS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQ0MsVUFBVSxFQUFFLEVBQUU7SUFDekQ7SUFDQUMsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDQyxPQUFPO0lBQ3ZCO0lBQ0FBLFFBQVFDLE1BQU0sRUFBRTtRQUNaLElBQUlBLFdBQVcsS0FBSyxHQUFHQSxTQUFTO1FBQ2hDLE1BQU1DLGdCQUFnQjtlQUNmLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJO1NBQ3hCLENBQUNDLElBQUk7UUFDTixJQUFJLElBQUksQ0FBQ0MsUUFBUSxLQUFLLE1BQU07WUFDeEJKLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLE9BQU87UUFDdEQ7UUFDQSxJQUFJLElBQUksQ0FBQ0MsWUFBWSxLQUFLLE1BQU07WUFDNUJQLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLFVBQVU7UUFDekQ7UUFDQSxJQUFJLElBQUksQ0FBQ0Usb0JBQW9CLEtBQUssTUFBTTtZQUNwQ1IsY0FBY0ssTUFBTSxDQUFDTCxjQUFjTSxPQUFPLENBQUMsWUFBWTtRQUMzRDtRQUNBLE1BQU1HLFNBQVNULGNBQWNVLEdBQUcsQ0FBQyxDQUFDQyxJQUFJLElBQUksQ0FBQ1YsUUFBUSxD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SSxDQUFDeEIsUUFBUSxHQUFHd0I7Z0JBQ2hCLCtFQUErRTtnQkFDL0VILGNBQWM7WUFDbEI7UUFDSjtRQUNBLGlGQUFpRjtRQUNqRixJQUFJLENBQUMsSUFBSSxDQUFDeEIsUUFBUSxDQUFDb0MsR0FBRyxDQUFDWixjQUFjO1lBQ2pDLElBQUksQ0FBQ3hCLFFBQVEsQ0FBQ3FDLEdBQUcsQ0FBQ2IsYUFBYSxJQUFJbkM7UUFDdkM7UUFDQSxJQUFJLENBQUNXLFFBQVEsQ0FBQ2IsR0FBRyxDQUFDcUMsYUFBYWhDLE9BQU8sQ0FBQzRCLFNBQVNILEtBQUssQ0FBQyxJQUFJSSxXQUFXQztJQUN6RTtJQUNBZ0IsYUFBYTtRQUNULElBQUksQ0FBQ3ZCLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNmLFFBQVEsR0FBRyxJQUFJdUM7UUFDcEIsSUFBSSxDQUFDcEMsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0csWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7SUFDaEM7QUFDSjtBQUNBLFNBQVNuQixnQkFBZ0JvRCxlQUFlO0lBQ3BDLGtGQUFrRjtJQUNsRiw0RUFBNEU7SUFDNUUsMkNBQTJDO0lBQzNDLHlFQUF5RTtJQUN6RSwyQkFBMkI7SUFDM0Isb0NBQW9DO0lBQ3BDLDhFQUE4RTtJQUM5RSx3RUFBd0U7SUFDeEUsZ0hBQWdIO0lBQ2hILDRFQUE0RTtJQUM1RSxNQUFNQyxPQUFPLElBQUlwRDtJQUNqQiw2RkFBNkY7SUFDN0ZtRCxnQkFBZ0JQLE9BQU8sQ0FBQyxDQUFDUyxXQUFXRCxLQUFLbkQsTUFBTSxDQUFDb0Q7SUFDaEQsNEdBQTRHO0lBQzVHLE9BQU9ELEtBQUs3QyxNQUFNO0FBQ3RCLEVBRUEseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9zb3J0ZWQtcm91dGVzLmpzP2FkMDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRTb3J0ZWRSb3V0ZXNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFNvcnRlZFJvdXRlcztcbiAgICB9XG59KTtcbmNsYXNzIFVybE5vZGUge1xuICAgIGluc2VydCh1cmxQYXRoKSB7XG4gICAgICAgIHRoaXMuX2luc2VydCh1cmxQYXRoLnNwbGl0KFwiL1wiKS5maWx0ZXIoQm9vbGVhbiksIFtdLCBmYWxzZSk7XG4gICAgfVxuICAgIHNtb29zaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Ntb29zaCgpO1xuICAgIH1cbiAgICBfc21vb3NoKHByZWZpeCkge1xuICAgICAgICBpZiAocHJlZml4ID09PSB2b2lkIDApIHByZWZpeCA9IFwiL1wiO1xuICAgICAgICBjb25zdCBjaGlsZHJlblBhdGhzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5jaGlsZHJlbi5rZXlzKClcbiAgICAgICAgXS5zb3J0KCk7XG4gICAgICAgIGlmICh0aGlzLnNsdWdOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjaGlsZHJlblBhdGhzLnNwbGljZShjaGlsZHJlblBhdGhzLmluZGV4T2YoXCJbXVwiKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVzdFNsdWdOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjaGlsZHJlblBhdGhzLnNwbGljZShjaGlsZHJlblBhdGhzLmluZGV4T2YoXCJbLi4uXVwiKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIltbLi4uXV1cIiksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlcyA9IGNoaWxkcmVuUGF0aHMubWFwKChjKT0+dGhpcy5jaGlsZHJlbi5nZXQoYykuX3Ntb29zaChcIlwiICsgcHJlZml4ICsgYyArIFwiL1wiKSkucmVkdWNlKChwcmV2LCBjdXJyKT0+W1xuICAgICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgICAgLi4uY3VyclxuICAgICAgICAgICAgXSwgW10pO1xuICAgICAgICBpZiAodGhpcy5zbHVnTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcm91dGVzLnB1c2goLi4udGhpcy5jaGlsZHJlbi5nZXQoXCJbXVwiKS5fc21vb3NoKHByZWZpeCArIFwiW1wiICsgdGhpcy5zbHVnTmFtZSArIFwiXS9cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgY29uc3QgciA9IHByZWZpeCA9PT0gXCIvXCIgPyBcIi9cIiA6IHByZWZpeC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IGRlZmluZSBhIHJvdXRlIHdpdGggdGhlIHNhbWUgc3BlY2lmaWNpdHkgYXMgYSBvcHRpb25hbCBjYXRjaC1hbGwgcm91dGUgKFwiJyArIHIgKyAnXCIgYW5kIFwiJyArIHIgKyBcIltbLi4uXCIgKyB0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICsgJ11dXCIpLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm91dGVzLnVuc2hpZnQocik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVzdFNsdWdOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICByb3V0ZXMucHVzaCguLi50aGlzLmNoaWxkcmVuLmdldChcIlsuLi5dXCIpLl9zbW9vc2gocHJlZml4ICsgXCJbLi4uXCIgKyB0aGlzLnJlc3RTbHVnTmFtZSArIFwiXS9cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICByb3V0ZXMucHVzaCguLi50aGlzLmNoaWxkcmVuLmdldChcIltbLi4uXV1cIikuX3Ntb29zaChwcmVmaXggKyBcIltbLi4uXCIgKyB0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICsgXCJdXS9cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3V0ZXM7XG4gICAgfVxuICAgIF9pbnNlcnQodXJsUGF0aHMsIHNsdWdOYW1lcywgaXNDYXRjaEFsbCkge1xuICAgICAgICBpZiAodXJsUGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2F0Y2hBbGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhdGNoLWFsbCBtdXN0IGJlIHRoZSBsYXN0IHBhcnQgb2YgdGhlIFVSTC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIG5leHQgc2VnbWVudCBpbiB0aGUgdXJsUGF0aHMgbGlzdFxuICAgICAgICBsZXQgbmV4dFNlZ21lbnQgPSB1cmxQYXRoc1swXTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNlZ21lbnQgbWF0Y2hlcyBgW3NvbWV0aGluZ11gXG4gICAgICAgIGlmIChuZXh0U2VnbWVudC5zdGFydHNXaXRoKFwiW1wiKSAmJiBuZXh0U2VnbWVudC5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgIC8vIFN0cmlwIGBbYCBhbmQgYF1gLCBsZWF2aW5nIG9ubHkgYHNvbWV0aGluZ2BcbiAgICAgICAgICAgIGxldCBzZWdtZW50TmFtZSA9IG5leHRTZWdtZW50LnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgIGxldCBpc09wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIltcIikgJiYgc2VnbWVudE5hbWUuZW5kc1dpdGgoXCJdXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgb3B0aW9uYWwgYFtgIGFuZCBgXWAsIGxlYXZpbmcgb25seSBgc29tZXRoaW5nYFxuICAgICAgICAgICAgICAgIHNlZ21lbnROYW1lID0gc2VnbWVudE5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZ21lbnROYW1lLnN0YXJ0c1dpdGgoXCIuLi5cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBgLi4uYCwgbGVhdmluZyBvbmx5IGBzb21ldGhpbmdgXG4gICAgICAgICAgICAgICAgc2VnbWVudE5hbWUgPSBzZWdtZW50TmFtZS5zdWJzdHJpbmcoMyk7XG4gICAgICAgICAgICAgICAgaXNDYXRjaEFsbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIltcIikgfHwgc2VnbWVudE5hbWUuZW5kc1dpdGgoXCJdXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VnbWVudCBuYW1lcyBtYXkgbm90IHN0YXJ0IG9yIGVuZCB3aXRoIGV4dHJhIGJyYWNrZXRzICgnXCIgKyBzZWdtZW50TmFtZSArIFwiJykuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZ21lbnROYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VnbWVudCBuYW1lcyBtYXkgbm90IHN0YXJ0IHdpdGggZXJyb25lb3VzIHBlcmlvZHMgKCdcIiArIHNlZ21lbnROYW1lICsgXCInKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVTbHVnKHByZXZpb3VzU2x1ZywgbmV4dFNsdWcpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNTbHVnICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzcGVjaWZpYyBzZWdtZW50IGFscmVhZHkgaGFzIGEgc2x1ZyBidXQgdGhlIHNsdWcgaXMgbm90IGBzb21ldGhpbmdgXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgY29sbGlzaW9ucyBsaWtlOlxuICAgICAgICAgICAgICAgICAgICAvLyBwYWdlcy9bcG9zdF0vaW5kZXguanNcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFnZXMvW2lkXS9pbmRleC5qc1xuICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGN1cnJlbnRseSBtdWx0aXBsZSBkeW5hbWljIHBhcmFtcyBvbiB0aGUgc2FtZSBzZWdtZW50IGxldmVsIGFyZSBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1NsdWcgIT09IG5leHRTbHVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGVycm9yIHNlZW1zIHRvIGJlIGNvbmZ1c2luZyBmb3IgdXNlcnMsIG5lZWRzIGFuIGVycm9yIGxpbmssIHRoZSBkZXNjcmlwdGlvbiBjYW4gYmUgYmFzZWQgb24gYWJvdmUgY29tbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgdXNlIGRpZmZlcmVudCBzbHVnIG5hbWVzIGZvciB0aGUgc2FtZSBkeW5hbWljIHBhdGggKCdcIiArIHByZXZpb3VzU2x1ZyArIFwiJyAhPT0gJ1wiICsgbmV4dFNsdWcgKyBcIicpLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzbHVnTmFtZXMuZm9yRWFjaCgoc2x1Zyk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsdWcgPT09IG5leHRTbHVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBzbHVnIG5hbWUgXCInICsgbmV4dFNsdWcgKyAnXCIgcmVwZWF0IHdpdGhpbiBhIHNpbmdsZSBkeW5hbWljIHBhdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2x1Zy5yZXBsYWNlKC9cXFcvZywgXCJcIikgPT09IG5leHRTZWdtZW50LnJlcGxhY2UoL1xcVy9nLCBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IGhhdmUgdGhlIHNsdWcgbmFtZXMgXCInICsgc2x1ZyArICdcIiBhbmQgXCInICsgbmV4dFNsdWcgKyAnXCIgZGlmZmVyIG9ubHkgYnkgbm9uLXdvcmQgc3ltYm9scyB3aXRoaW4gYSBzaW5nbGUgZHluYW1pYyBwYXRoJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzbHVnTmFtZXMucHVzaChuZXh0U2x1Zyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDYXRjaEFsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3RTbHVnTmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgdXNlIGJvdGggYW4gcmVxdWlyZWQgYW5kIG9wdGlvbmFsIGNhdGNoLWFsbCByb3V0ZSBhdCB0aGUgc2FtZSBsZXZlbCAoXCJbLi4uJyArIHRoaXMucmVzdFNsdWdOYW1lICsgJ11cIiBhbmQgXCInICsgdXJsUGF0aHNbMF0gKyAnXCIgKS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTbHVnKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUsIHNlZ21lbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2x1Z05hbWUgaXMga2VwdCBhcyBpdCBjYW4gb25seSBiZSBvbmUgcGFydGljdWxhciBzbHVnTmFtZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHRTZWdtZW50IGlzIG92ZXJ3cml0dGVuIHRvIFtbLi4uXV0gc28gdGhhdCBpdCBjYW4gbGF0ZXIgYmUgc29ydGVkIHNwZWNpZmljYWxseVxuICAgICAgICAgICAgICAgICAgICBuZXh0U2VnbWVudCA9IFwiW1suLi5dXVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCB1c2UgYm90aCBhbiBvcHRpb25hbCBhbmQgcmVxdWlyZWQgY2F0Y2gtYWxsIHJvdXRlIGF0IHRoZSBzYW1lIGxldmVsIChcIltbLi4uJyArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyAnXV1cIiBhbmQgXCInICsgdXJsUGF0aHNbMF0gKyAnXCIpLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5yZXN0U2x1Z05hbWUsIHNlZ21lbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2x1Z05hbWUgaXMga2VwdCBhcyBpdCBjYW4gb25seSBiZSBvbmUgcGFydGljdWxhciBzbHVnTmFtZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RTbHVnTmFtZSA9IHNlZ21lbnROYW1lO1xuICAgICAgICAgICAgICAgICAgICAvLyBuZXh0U2VnbWVudCBpcyBvdmVyd3JpdHRlbiB0byBbLi4uXSBzbyB0aGF0IGl0IGNhbiBsYXRlciBiZSBzb3J0ZWQgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbLi4uXVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25hbCByb3V0ZSBwYXJhbWV0ZXJzIGFyZSBub3QgeWV0IHN1cHBvcnRlZCAoXCInICsgdXJsUGF0aHNbMF0gKyAnXCIpLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVTbHVnKHRoaXMuc2x1Z05hbWUsIHNlZ21lbnROYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgdGhpcy5zbHVnTmFtZSA9IHNlZ21lbnROYW1lO1xuICAgICAgICAgICAgICAgIC8vIG5leHRTZWdtZW50IGlzIG92ZXJ3cml0dGVuIHRvIFtdIHNvIHRoYXQgaXQgY2FuIGxhdGVyIGJlIHNvcnRlZCBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAgICAgICBuZXh0U2VnbWVudCA9IFwiW11cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIFVybE5vZGUgZG9lc24ndCBoYXZlIHRoZSBuZXh0U2VnbWVudCB5ZXQgd2UgY3JlYXRlIGEgbmV3IGNoaWxkIFVybE5vZGVcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuLmhhcyhuZXh0U2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc2V0KG5leHRTZWdtZW50LCBuZXcgVXJsTm9kZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLmdldChuZXh0U2VnbWVudCkuX2luc2VydCh1cmxQYXRocy5zbGljZSgxKSwgc2x1Z05hbWVzLCBpc0NhdGNoQWxsKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2x1Z05hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc3RTbHVnTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNvcnRlZFJvdXRlcyhub3JtYWxpemVkUGFnZXMpIHtcbiAgICAvLyBGaXJzdCB0aGUgVXJsTm9kZSBpcyBjcmVhdGVkLCBhbmQgZXZlcnkgVXJsTm9kZSBjYW4gaGF2ZSBvbmx5IDEgZHluYW1pYyBzZWdtZW50XG4gICAgLy8gRWcgeW91IGNhbid0IGhhdmUgcGFnZXMvW3Bvc3RdL2FiYy5qcyBhbmQgcGFnZXMvW2hlbGxvXS9zb21ldGhpbmctZWxzZS5qc1xuICAgIC8vIE9ubHkgMSBkeW5hbWljIHNlZ21lbnQgcGVyIG5lc3RpbmcgbGV2ZWxcbiAgICAvLyBTbyBpbiB0aGUgY2FzZSB0aGF0IGlzIHRlc3QvaW50ZWdyYXRpb24vZHluYW1pYy1yb3V0aW5nIGl0J2xsIGJlIHRoaXM6XG4gICAgLy8gcGFnZXMvW3Bvc3RdL2NvbW1lbnRzLmpzXG4gICAgLy8gcGFnZXMvYmxvZy9bcG9zdF0vY29tbWVudC9baWRdLmpzXG4gICAgLy8gQm90aCBhcmUgZmluZSBiZWNhdXNlIGBwYWdlcy9bcG9zdF1gIGFuZCBgcGFnZXMvYmxvZ2AgYXJlIG9uIHRoZSBzYW1lIGxldmVsXG4gICAgLy8gU28gaW4gdGhpcyBjYXNlIGBVcmxOb2RlYCBjcmVhdGVkIGhlcmUgaGFzIGB0aGlzLnNsdWdOYW1lID09PSAncG9zdCdgXG4gICAgLy8gQW5kIHNpbmNlIHlvdXIgUFIgcGFzc2VkIHRocm91Z2ggYHNsdWdOYW1lYCBhcyBhbiBhcnJheSBiYXNpY2FsbHkgaXQnZCBpbmNsdWRpbmcgaXQgaW4gdG9vIG1hbnkgcG9zc2liaWxpdGllc1xuICAgIC8vIEluc3RlYWQgd2hhdCBoYXMgdG8gYmUgcGFzc2VkIHRocm91Z2ggaXMgdGhlIHVwd2FyZHMgcGF0aCdzIGR5bmFtaWMgbmFtZXNcbiAgICBjb25zdCByb290ID0gbmV3IFVybE5vZGUoKTtcbiAgICAvLyBIZXJlIHRoZSBgcm9vdGAgZ2V0cyBpbmplY3RlZCBtdWx0aXBsZSBwYXRocywgYW5kIGluc2VydCB3aWxsIGJyZWFrIHRoZW0gdXAgaW50byBzdWJsZXZlbHNcbiAgICBub3JtYWxpemVkUGFnZXMuZm9yRWFjaCgocGFnZVBhdGgpPT5yb290Lmluc2VydChwYWdlUGF0aCkpO1xuICAgIC8vIFNtb29zaCB3aWxsIHRoZW4gc29ydCB0aG9zZSBzdWJsZXZlbHMgdXAgdG8gdGhlIHBvaW50IHdoZXJlIHlvdSBnZXQgdGhlIGNvcnJlY3Qgcm91dGUgZGVmaW5pdGlvbiBwcmlvcml0eVxuICAgIHJldHVybiByb290LnNtb29zaCgpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3J0ZWQtcm91dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJnZXRTb3J0ZWRSb3V0ZXMiLCJVcmxOb2RlIiwiaW5zZXJ0IiwidXJsUGF0aCIsIl9pbnNlcnQiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJzbW9vc2giLCJfc21vb3NoIiwicHJlZml4IiwiY2hpbGRyZW5QYXRocyIsImNoaWxkcmVuIiwia2V5cyIsInNvcnQiLCJzbHVnTmFtZSIsInNwbGljZSIsImluZGV4T2YiLCJyZXN0U2x1Z05hbWUiLCJvcHRpb25hbFJlc3RTbHVnTmFtZSIsInJvdXRlcyIsIm1hcCIsImMiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyciIsInB1c2giLCJwbGFjZWhvbGRlciIsInIiLCJzbGljZSIsIkVycm9yIiwidW5zaGlmdCIsInVybFBhdGhzIiwic2x1Z05hbWVzIiwiaXNDYXRjaEFsbCIsImxlbmd0aCIsIm5leHRTZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic2VnbWVudE5hbWUiLCJpc09wdGlvbmFsIiwic3Vic3RyaW5nIiwiaGFuZGxlU2x1ZyIsInByZXZpb3VzU2x1ZyIsIm5leHRTbHVnIiwiZm9yRWFjaCIsInNsdWciLCJyZXBsYWNlIiwiaGFzIiwic2V0IiwiY29uc3RydWN0b3IiLCJNYXAiLCJub3JtYWxpemVkUGFnZXMiLCJyb290IiwicGFnZVBhdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/utils.js":
/*!*********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/utils.js ***!
  \*********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    DecodeError: function() {\n        return DecodeError;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== \"undefined\";\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.name = \"PageNotFoundError\";\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4xLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBa0JOO0FBQ0EsU0FBU2tCLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUl4QixPQUFPQyxjQUFjLENBQUNzQixRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFwQixTQUFTO0lBQ2JHLFlBQVk7UUFDUixPQUFPQTtJQUNYO0lBQ0FDLFVBQVU7UUFDTixPQUFPQTtJQUNYO0lBQ0FDLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLG1CQUFtQjtRQUNmLE9BQU9BO0lBQ1g7SUFDQUMsUUFBUTtRQUNKLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxXQUFXO1FBQ1AsT0FBT0E7SUFDWDtJQUNBQywwQkFBMEI7UUFDdEIsT0FBT0E7SUFDWDtJQUNBQyxxQkFBcUI7UUFDakIsT0FBT0E7SUFDWDtJQUNBQyxJQUFJO1FBQ0EsT0FBT0E7SUFDWDtJQUNBQyxJQUFJO1FBQ0EsT0FBT0E7SUFDWDtJQUNBQyxhQUFhO1FBQ1QsT0FBT0E7SUFDWDtJQUNBQyxnQkFBZ0I7UUFDWixPQUFPQTtJQUNYO0lBQ0FDLG1CQUFtQjtRQUNmLE9BQU9BO0lBQ1g7SUFDQUMsbUJBQW1CO1FBQ2YsT0FBT0E7SUFDWDtJQUNBQyx5QkFBeUI7UUFDckIsT0FBT0E7SUFDWDtJQUNBQyxnQkFBZ0I7UUFDWixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNaEIsYUFBYTtJQUNm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QUFJN0QsT0FBT3FFLElBQUksQ0FBQ0QsT0FBT25DLE1BQU0sS0FBSyxLQUFLLENBQUMyQixJQUFJQSxHQUFHLEVBQUU7WUFDN0NVLFFBQVFDLElBQUksQ0FBQyxLQUFLN0QsZUFBZWlELE9BQU87UUFDNUM7SUFDSjtJQUNBLE9BQU9TO0FBQ1g7QUFDQSxNQUFNdEQsS0FBSyxPQUFPMEQsZ0JBQWdCO0FBQ2xDLE1BQU16RCxLQUFLRCxNQUFNO0lBQ2I7SUFDQTtJQUNBO0NBQ0gsQ0FBQzJELEtBQUssQ0FBQyxDQUFDQyxTQUFTLE9BQU9GLFdBQVcsQ0FBQ0UsT0FBTyxLQUFLO0FBQ2pELE1BQU0xRCxvQkFBb0JrRDtBQUMxQjtBQUNBLE1BQU1qRCx1QkFBdUJpRDtBQUM3QjtBQUNBLE1BQU1oRCwwQkFBMEJnRDtJQUM1QlMsWUFBWUMsSUFBSSxDQUFDO1FBQ2IsS0FBSztRQUNMLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDcEQsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDd0MsT0FBTyxHQUFHLGtDQUFrQ1c7SUFDckQ7QUFDSjtBQUNBLE1BQU16RCwwQkFBMEIrQztJQUM1QlMsWUFBWUMsSUFBSSxFQUFFWCxPQUFPLENBQUM7UUFDdEIsS0FBSztRQUNMLElBQUksQ0FBQ0EsT0FBTyxHQUFHLDBDQUEwQ1csT0FBTyxNQUFNWDtJQUMxRTtBQUNKO0FBQ0EsTUFBTTdDLGdDQUFnQzhDO0lBQ2xDUyxhQUFhO1FBQ1QsS0FBSztRQUNMLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDWixPQUFPLEdBQUc7SUFDbkI7QUFDSjtBQUNBLFNBQVM1QyxlQUFleUQsS0FBSztJQUN6QixPQUFPQyxLQUFLQyxTQUFTLENBQUM7UUFDbEJmLFNBQVNhLE1BQU1iLE9BQU87UUFDdEJnQixPQUFPSCxNQUFNRyxLQUFLO0lBQ3RCO0FBQ0osRUFFQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjEuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanM/ZTZlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIFdFQl9WSVRBTFM6IG51bGwsXG4gICAgZXhlY09uY2U6IG51bGwsXG4gICAgaXNBYnNvbHV0ZVVybDogbnVsbCxcbiAgICBnZXRMb2NhdGlvbk9yaWdpbjogbnVsbCxcbiAgICBnZXRVUkw6IG51bGwsXG4gICAgZ2V0RGlzcGxheU5hbWU6IG51bGwsXG4gICAgaXNSZXNTZW50OiBudWxsLFxuICAgIG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlczogbnVsbCxcbiAgICBsb2FkR2V0SW5pdGlhbFByb3BzOiBudWxsLFxuICAgIFNQOiBudWxsLFxuICAgIFNUOiBudWxsLFxuICAgIERlY29kZUVycm9yOiBudWxsLFxuICAgIE5vcm1hbGl6ZUVycm9yOiBudWxsLFxuICAgIFBhZ2VOb3RGb3VuZEVycm9yOiBudWxsLFxuICAgIE1pc3NpbmdTdGF0aWNQYWdlOiBudWxsLFxuICAgIE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yOiBudWxsLFxuICAgIHN0cmluZ2lmeUVycm9yOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIFdFQl9WSVRBTFM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gV0VCX1ZJVEFMUztcbiAgICB9LFxuICAgIGV4ZWNPbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWNPbmNlO1xuICAgIH0sXG4gICAgaXNBYnNvbHV0ZVVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc0Fic29sdXRlVXJsO1xuICAgIH0sXG4gICAgZ2V0TG9jYXRpb25PcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0TG9jYXRpb25PcmlnaW47XG4gICAgfSxcbiAgICBnZXRVUkw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0VVJMO1xuICAgIH0sXG4gICAgZ2V0RGlzcGxheU5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWU7XG4gICAgfSxcbiAgICBpc1Jlc1NlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNSZXNTZW50O1xuICAgIH0sXG4gICAgbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcztcbiAgICB9LFxuICAgIGxvYWRHZXRJbml0aWFsUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbG9hZEdldEluaXRpYWxQcm9wcztcbiAgICB9LFxuICAgIFNQOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFNQO1xuICAgIH0sXG4gICAgU1Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU1Q7XG4gICAgfSxcbiAgICBEZWNvZGVFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBEZWNvZGVFcnJvcjtcbiAgICB9LFxuICAgIE5vcm1hbGl6ZUVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5vcm1hbGl6ZUVycm9yO1xuICAgIH0sXG4gICAgUGFnZU5vdEZvdW5kRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGFnZU5vdEZvdW5kRXJyb3I7XG4gICAgfSxcbiAgICBNaXNzaW5nU3RhdGljUGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNaXNzaW5nU3RhdGljUGFnZTtcbiAgICB9LFxuICAgIE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5RXJyb3I7XG4gICAgfVxufSk7XG5jb25zdCBXRUJfVklUQUxTID0gW1xuICAgIFwiQ0xTXCIsXG4gICAgXCJGQ1BcIixcbiAgICBcIkZJRFwiLFxuICAgIFwiSU5QXCIsXG4gICAgXCJMQ1BcIixcbiAgICBcIlRURkJcIlxuXTtcbmZ1bmN0aW9uIGV4ZWNPbmNlKGZuKSB7XG4gICAgbGV0IHVzZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVzZWQpIHtcbiAgICAgICAgICAgIHVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4oLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuLy8gU2NoZW1lOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMVxuLy8gQWJzb2x1dGUgVVJMOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTQuM1xuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVpcXGQrXFwtLl0qPzovO1xuY29uc3QgaXNBYnNvbHV0ZVVybCA9ICh1cmwpPT5BQlNPTFVURV9VUkxfUkVHRVgudGVzdCh1cmwpO1xuZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gICAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICByZXR1cm4gcHJvdG9jb2wgKyBcIi8vXCIgKyBob3N0bmFtZSArIChwb3J0ID8gXCI6XCIgKyBwb3J0IDogXCJcIik7XG59XG5mdW5jdGlvbiBnZXRVUkwoKSB7XG4gICAgY29uc3QgeyBocmVmIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKTtcbiAgICByZXR1cm4gaHJlZi5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gXCJzdHJpbmdcIiA/IENvbXBvbmVudCA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCBcIlVua25vd25cIjtcbn1cbmZ1bmN0aW9uIGlzUmVzU2VudChyZXMpIHtcbiAgICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyh1cmwpIHtcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybC5zcGxpdChcIj9cIik7XG4gICAgY29uc3QgdXJsTm9RdWVyeSA9IHVybFBhcnRzWzBdO1xuICAgIHJldHVybiB1cmxOb1F1ZXJ5Ly8gZmlyc3Qgd2UgcmVwbGFjZSBhbnkgbm9uLWVuY29kZWQgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkXG4gICAgLy8gdGhlbiBub3JtYWxpemUgcmVwZWF0ZWQgZm9yd2FyZCBzbGFzaGVzXG4gICAgLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpICsgKHVybFBhcnRzWzFdID8gXCI/XCIgKyB1cmxQYXJ0cy5zbGljZSgxKS5qb2luKFwiP1wiKSA6IFwiXCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIGN0eCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFyIF9BcHBfcHJvdG90eXBlO1xuICAgICAgICBpZiAoKF9BcHBfcHJvdG90eXBlID0gQXBwLnByb3RvdHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9BcHBfcHJvdG90eXBlLmdldEluaXRpYWxQcm9wcykge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdcIicgKyBnZXREaXNwbGF5TmFtZShBcHApICsgJy5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZ2V0LWluaXRpYWwtcHJvcHMtYXMtYW4taW5zdGFuY2UtbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLic7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICAgIGNvbnN0IHJlcyA9IGN0eC5yZXMgfHwgY3R4LmN0eCAmJiBjdHguY3R4LnJlcztcbiAgICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgICAgaWYgKGN0eC5jdHggJiYgY3R4LkNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBwYWdlUHJvcHMgZGVmYXVsdFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KTtcbiAgICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1wiJyArIGdldERpc3BsYXlOYW1lKEFwcCkgKyAnLmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCInICsgcHJvcHMgKyAnXCIgaW5zdGVhZC4nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlwiICsgZ2V0RGlzcGxheU5hbWUoQXBwKSArIFwiIHJldHVybmVkIGFuIGVtcHR5IG9iamVjdCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufVxuY29uc3QgU1AgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBTVCA9IFNQICYmIFtcbiAgICBcIm1hcmtcIixcbiAgICBcIm1lYXN1cmVcIixcbiAgICBcImdldEVudHJpZXNCeU5hbWVcIlxuXS5ldmVyeSgobWV0aG9kKT0+dHlwZW9mIHBlcmZvcm1hbmNlW21ldGhvZF0gPT09IFwiZnVuY3Rpb25cIik7XG5jbGFzcyBEZWNvZGVFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmNsYXNzIE5vcm1hbGl6ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuY2xhc3MgUGFnZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocGFnZSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiRU5PRU5UXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUGFnZU5vdEZvdW5kRXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJDYW5ub3QgZmluZCBtb2R1bGUgZm9yIHBhZ2U6IFwiICsgcGFnZTtcbiAgICB9XG59XG5jbGFzcyBNaXNzaW5nU3RhdGljUGFnZSBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYWdlLCBtZXNzYWdlKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJGYWlsZWQgdG8gbG9hZCBzdGF0aWMgZmlsZSBmb3IgcGFnZTogXCIgKyBwYWdlICsgXCIgXCIgKyBtZXNzYWdlO1xuICAgIH1cbn1cbmNsYXNzIE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiRU5PRU5UXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IFwiQ2Fubm90IGZpbmQgdGhlIG1pZGRsZXdhcmUgbW9kdWxlXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiV0VCX1ZJVEFMUyIsImV4ZWNPbmNlIiwiaXNBYnNvbHV0ZVVybCIsImdldExvY2F0aW9uT3JpZ2luIiwiZ2V0VVJMIiwiZ2V0RGlzcGxheU5hbWUiLCJpc1Jlc1NlbnQiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiU1AiLCJTVCIsIkRlY29kZUVycm9yIiwiTm9ybWFsaXplRXJyb3IiLCJQYWdlTm90Rm91bmRFcnJvciIsIk1pc3NpbmdTdGF0aWNQYWdlIiwiTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IiLCJzdHJpbmdpZnlFcnJvciIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsImZuIiwidXNlZCIsInJlc3VsdCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwidXJsIiwidGVzdCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwib3JpZ2luIiwic3Vic3RyaW5nIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJyZXMiLCJmaW5pc2hlZCIsImhlYWRlcnNTZW50IiwidXJsUGFydHMiLCJzcGxpdCIsInVybE5vUXVlcnkiLCJyZXBsYWNlIiwic2xpY2UiLCJqb2luIiwiQXBwIiwiY3R4IiwicHJvY2VzcyIsIl9BcHBfcHJvdG90eXBlIiwicHJvdG90eXBlIiwiZ2V0SW5pdGlhbFByb3BzIiwibWVzc2FnZSIsIkVycm9yIiwicGFnZVByb3BzIiwicHJvcHMiLCJrZXlzIiwiY29uc29sZSIsIndhcm4iLCJwZXJmb3JtYW5jZSIsImV2ZXJ5IiwibWV0aG9kIiwiY29uc3RydWN0b3IiLCJwYWdlIiwiY29kZSIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/dexie@3.2.7/node_modules/dexie/dist/modern/dexie.mjs":
/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/dexie@3.2.7/node_modules/dexie/dist/modern/dexie.mjs ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dexie: function() { return /* binding */ Dexie$1; },\n/* harmony export */   RangeSet: function() { return /* binding */ RangeSet; },\n/* harmony export */   \"default\": function() { return /* binding */ Dexie$1; },\n/* harmony export */   liveQuery: function() { return /* binding */ liveQuery; },\n/* harmony export */   mergeRanges: function() { return /* binding */ mergeRanges; },\n/* harmony export */   rangesOverlap: function() { return /* binding */ rangesOverlap; }\n/* harmony export */ });\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.7, Wed Mar 20 2024\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */ var _s = $RefreshSig$();\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self :  true ? window : 0;\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== \"undefined\" && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== \"object\") return obj;\n    keys(extension).forEach(function(key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === \"function\") extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach((key)=>{\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === \"function\" ? {\n        get: functionOrGetSet.get,\n        set: functionOrGetSet.set,\n        configurable: true\n    } : {\n        value: functionOrGetSet,\n        configurable: true,\n        writable: true\n    }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function(Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b) throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate) setImmediate(fn);\n    else setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i)=>{\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    } catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (typeof keyPath === \"string\" && hasOwn(obj, keyPath)) return obj[keyPath];\n    if (!keyPath) return obj;\n    if (typeof keyPath !== \"string\") {\n        var rv = [];\n        for(var i = 0, l = keyPath.length; i < l; ++i){\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf(\".\");\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined) return;\n    if (\"isFrozen\" in Object && Object.isFrozen(obj)) return;\n    if (typeof keyPath !== \"string\" && \"length\" in keyPath) {\n        assert(typeof value !== \"string\" && \"length\" in value);\n        for(var i = 0, l = keyPath.length; i < l; ++i){\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    } else {\n        var period = keyPath.indexOf(\".\");\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\") if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);\n                else delete obj[currentKeyPath];\n            } else obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = obj[currentKeyPath] = {};\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        } else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);\n                else delete obj[keyPath];\n            } else obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === \"string\") setByKeyPath(obj, keyPath, undefined);\n    else if (\"length\" in keyPath) [].map.call(keyPath, function(kp) {\n        setByKeyPath(obj, kp, undefined);\n    });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for(var m in obj){\n        if (hasOwn(obj, m)) rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(\",\").concat(flatten([\n    8,\n    16,\n    32,\n    64\n].map((num)=>[\n        \"Int\",\n        \"Uint\",\n        \"Float\"\n    ].map((t)=>t + num + \"Array\")))).filter((t)=>_global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map((t)=>_global[t]);\narrayToObject(intrinsicTypeNames, (x)=>[\n        x,\n        true\n    ]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== \"undefined\" && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== \"object\") return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv) return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for(var i = 0, l = any.length; i < l; ++i){\n            rv.push(innerDeepClone(any[i]));\n        }\n    } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    } else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for(var prop in any){\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function(x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function() {\n    return null;\n};\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike)) return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === \"string\") return [\n            arrayLike\n        ];\n        if (it = getIteratorOf(arrayLike)) {\n            a = [];\n            while(x = it.next(), !x.done)a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null) return [\n            arrayLike\n        ];\n        i = arrayLike.length;\n        if (typeof i === \"number\") {\n            a = new Array(i);\n            while(i--)a[i] = arrayLike[i];\n            return a;\n        }\n        return [\n            arrayLike\n        ];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while(i--)a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== \"undefined\" ? (fn)=>fn[Symbol.toStringTag] === \"AsyncFunction\" : ()=>false;\nvar debug = typeof location !== \"undefined\" && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = ()=>true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK) try {\n        getErrorWithStack.arguments;\n        throw new Error();\n    } catch (e) {\n        return e;\n    }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack) return \"\";\n    numIgnoredFrames = numIgnoredFrames || 0;\n    if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split(\"\\n\").length;\n    return stack.split(\"\\n\").slice(numIgnoredFrames).filter(libraryFilter).map((frame)=>\"\\n\" + frame).join(\"\");\n}\nvar dexieErrorNames = [\n    \"Modify\",\n    \"Bulk\",\n    \"OpenFailed\",\n    \"VersionChange\",\n    \"Schema\",\n    \"Upgrade\",\n    \"InvalidTable\",\n    \"MissingAPI\",\n    \"NoSuchDatabase\",\n    \"InvalidArgument\",\n    \"SubTransaction\",\n    \"Unsupported\",\n    \"Internal\",\n    \"DatabaseClosed\",\n    \"PrematureCommit\",\n    \"ForeignAwait\"\n];\nvar idbDomErrorNames = [\n    \"Unknown\",\n    \"Constraint\",\n    \"Data\",\n    \"TransactionInactive\",\n    \"ReadOnly\",\n    \"Version\",\n    \"NotFound\",\n    \"InvalidState\",\n    \"InvalidAccess\",\n    \"Abort\",\n    \"Timeout\",\n    \"QuotaExceeded\",\n    \"Syntax\",\n    \"DataClone\"\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\n_c = DexieError;\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function() {\n            return this._stack || (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function() {\n        return this.name + \": \" + this.message;\n    }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures).map((key)=>failures[key].toString()).filter((v, i, s)=>s.indexOf(v) === i).join(\"\\n\");\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\n_c1 = ModifyError;\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map((pos)=>failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\n_c2 = BulkError;\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name)=>(obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name)=>{\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        } else if (typeof msgOrInner === \"string\") {\n            this.message = \"\".concat(msgOrInner).concat(!inner ? \"\" : \"\\n \" + inner);\n            this.inner = inner || null;\n        } else if (typeof msgOrInner === \"object\") {\n            this.message = \"\".concat(msgOrInner.name, \" \").concat(msgOrInner.message);\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name)=>{\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", {\n            get: function() {\n                return this.inner.stack;\n            }\n        });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name)=>{\n    if ([\n        \"Syntax\",\n        \"Type\",\n        \"Range\"\n    ].indexOf(name) === -1) obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\nfunction nop() {}\nfunction mirror(val) {\n    return val;\n}\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror) return f2;\n    return function(val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function() {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined) arguments[0] = res;\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function(modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        if (f2.apply(this, arguments) === false) return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === \"function\") {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while(i--)args[i] = arguments[i];\n            return res.then(function() {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100, MAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === \"undefined\" ? [] : (()=>{\n    let globalP = Promise.resolve();\n    if (typeof crypto === \"undefined\" || !crypto.subtle) return [\n        globalP,\n        getProto(globalP),\n        globalP\n    ];\n    const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([\n        0\n    ]));\n    return [\n        nativeP,\n        getProto(nativeP),\n        globalP\n    ];\n})(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ? ()=>{\n    resolvedGlobalPromise.then(physicalTick);\n} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? ()=>{\n    var hiddenDiv = document.createElement(\"div\");\n    new MutationObserver(()=>{\n        physicalTick();\n        hiddenDiv = null;\n    }).observe(hiddenDiv, {\n        attributes: true\n    });\n    hiddenDiv.setAttribute(\"i\", \"1\");\n} : ()=>{\n    setTimeout(physicalTick, 0);\n};\nvar asap = function(callback, args) {\n    microtickQueue.push([\n        callback,\n        args\n    ]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], currentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: \"global\",\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function() {\n        this.unhandleds.forEach((uh)=>{\n            try {\n                globalError(uh[0], uh[1]);\n            } catch (e) {}\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== \"object\") throw new TypeError(\"Promises must be constructed via new\");\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = this._PSD = PSD;\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== \"function\") {\n        if (fn !== INTERNAL) throw new TypeError(\"Not a function\");\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false) handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\n_c3 = DexiePromise;\nconst thenProp = {\n    get: function() {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject)=>{\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function(value) {\n        setProp(this, \"then\", value && value.prototype === INTERNAL ? thenProp : {\n            get: function() {\n                return value;\n            },\n            set: thenProp.set\n        });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function(onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function(onRejected) {\n        if (arguments.length === 1) return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === \"function\" ? this.then(null, (err)=>err instanceof type ? handler(err) : PromiseReject(err)) : this.then(null, (err)=>err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function(onFinally) {\n        return this.then((value)=>{\n            onFinally();\n            return value;\n        }, (err)=>{\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function() {\n            if (this._stack) return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null) this._stack = stack;\n                return stack;\n            } finally{\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function(ms, msg) {\n        return ms < Infinity ? new DexiePromise((resolve, reject)=>{\n            var handle = setTimeout(()=>reject(new exceptions.Timeout(msg)), ms);\n            this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n        }) : this;\n    }\n});\nif (typeof Symbol !== \"undefined\" && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, \"Dexie.Promise\");\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : null;\n    this.onRejected = typeof onRejected === \"function\" ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\n_c4 = Listener;\nprops(DexiePromise, {\n    all: function() {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise(function(resolve, reject) {\n            if (values.length === 0) resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i)=>DexiePromise.resolve(a).then((x)=>{\n                    values[i] = x;\n                    if (!--remaining) resolve(values);\n                }, reject));\n        });\n    },\n    resolve: (value)=>{\n        if (value instanceof DexiePromise) return value;\n        if (value && typeof value.then === \"function\") return new DexiePromise((resolve, reject)=>{\n            value.then(resolve, reject);\n        });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function() {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject)=>{\n            values.map((value)=>DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: ()=>PSD,\n        set: (value)=>PSD = value\n    },\n    totalEchoes: {\n        get: ()=>totalEchoes\n    },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: ()=>asap,\n        set: (value)=>{\n            asap = value;\n        }\n    },\n    rejectionMapper: {\n        get: ()=>rejectionMapper,\n        set: (value)=>{\n            rejectionMapper = value;\n        }\n    },\n    follow: (fn, zoneProps)=>{\n        return new DexiePromise((resolve, reject)=>{\n            return newScope((resolve, reject)=>{\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function() {\n                    run_at_end_of_this_or_next_physical_tick(()=>{\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled) setProp(DexiePromise, \"allSettled\", function() {\n        const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve)=>{\n            if (possiblePromises.length === 0) resolve([]);\n            let remaining = possiblePromises.length;\n            const results = new Array(remaining);\n            possiblePromises.forEach((p, i)=>DexiePromise.resolve(p).then((value)=>results[i] = {\n                        status: \"fulfilled\",\n                        value\n                    }, (reason)=>results[i] = {\n                        status: \"rejected\",\n                        reason\n                    }).then(()=>--remaining || resolve(results)));\n        });\n    });\n    if (NativePromise.any && typeof AggregateError !== \"undefined\") setProp(DexiePromise, \"any\", function() {\n        const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject)=>{\n            if (possiblePromises.length === 0) reject(new AggregateError([]));\n            let remaining = possiblePromises.length;\n            const failures = new Array(remaining);\n            possiblePromises.forEach((p, i)=>DexiePromise.resolve(p).then((value)=>resolve(value), (failure)=>{\n                    failures[i] = failure;\n                    if (!--remaining) reject(new AggregateError(failures));\n                }));\n        });\n    });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn((value)=>{\n            if (promise._state !== null) return;\n            if (value === promise) throw new TypeError(\"A promise cannot be resolved with itself.\");\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === \"function\") {\n                executePromiseTask(promise, (resolve, reject)=>{\n                    value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);\n                });\n            } else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick) endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    } catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null) return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === \"object\" && !reason._promise && tryCatch(()=>{\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: ()=>stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick) endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for(var i = 0, len = listeners.length; i < len; ++i){\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(()=>{\n            if (--numScheduledCalls === 0) finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [\n        cb,\n        promise,\n        listener\n    ]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        } else {\n            if (rejectingErrors.length) rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    } catch (e) {\n        listener.reject(e);\n    } finally{\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit) return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        } else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);\n        if (promise._prev) getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while(microtickQueue.length > 0){\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for(i = 0; i < l; ++i){\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    }while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach((p)=>{\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while(i)finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(()=>{\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some((p)=>p._value === promise._value)) unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while(i)if (unhandledErrors[--i]._value === promise._value) {\n        unhandledErrors.splice(i, 1);\n        return;\n    }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\n_c5 = PromiseReject;\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function() {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        } catch (e) {\n            errorCatcher && errorCatcher(e);\n        } finally{\n            switchToZone(outerScope, false);\n            if (wasRootExec) endMicroTickScope();\n        }\n    };\n}\nconst task = {\n    awaits: 0,\n    echoes: 0,\n    id: 0\n};\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    _s();\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: {\n            value: DexiePromise,\n            configurable: true,\n            writable: true\n        },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props) extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function() {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0) psd.finalize();\n    return rv;\n}\n_s(newScope, \"9BeIUoipyQKbAN7K2H4o5kkvZsk=\", false, function() {\n    return [\n        usePSD\n    ];\n});\nfunction incrementExpectedAwaits() {\n    if (!task.id) task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits) return false;\n    if (--task.awaits === 0) task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif ((\"\" + nativePromiseThen).indexOf(\"[native code]\") === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then((x)=>{\n            decrementExpectedAwaits();\n            return x;\n        }, (e)=>{\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD) return;\n    PSD = targetZone;\n    if (currentZone === globalPSD) globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, \"Promise\", targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled) GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any) GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    } finally{\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== \"function\" ? fn : function() {\n        var outerZone = PSD;\n        if (possibleAwait) incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        } finally{\n            switchToZone(outerZone, false);\n            if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function(onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    } catch (e) {}\n    if (rv !== false) try {\n        var event, eventData = {\n            promise: promise,\n            reason: err\n        };\n        if (_global.document && document.createEvent) {\n            event = document.createEvent(\"Event\");\n            event.initEvent(UNHANDLEDREJECTION, true, true);\n            extend(event, eventData);\n        } else if (_global.CustomEvent) {\n            event = new CustomEvent(UNHANDLEDREJECTION, {\n                detail: eventData\n            });\n            extend(event, eventData);\n        }\n        if (event && _global.dispatchEvent) {\n            dispatchEvent(event);\n            if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {\n                _global.onunhandledrejection(event);\n            } catch (_) {}\n        }\n        if (debug && event && !event.defaultPrevented) {\n            console.warn(\"Unhandled rejection: \".concat(err.stack || err));\n        }\n    } catch (e) {}\n}\nvar rejection = DexiePromise.reject;\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(()=>tempTransaction(db, mode, storeNames, fn));\n    } else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n            db._state.PR1398_maxLoop = 3;\n        } catch (ex) {\n            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                console.warn(\"Dexie: Need to reopen db\");\n                db._close();\n                return db.open().then(()=>tempTransaction(db, mode, storeNames, fn));\n            }\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject)=>{\n            return newScope(()=>{\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then((result)=>{\n            return trans._completion.then(()=>result);\n        });\n    }\n}\nconst DEXIE_VERSION = \"3.2.7\";\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== \"undefined\" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = (frame)=>!/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = \"__dbnames\";\nconst READONLY = \"readonly\";\nconst READWRITE = \"readwrite\";\nfunction combine(filter1, filter2) {\n    return filter1 ? filter2 ? function() {\n        return filter1.apply(this, arguments) && filter2.apply(this, arguments);\n    } : filter1 : filter2;\n}\nconst AnyRange = {\n    type: 3,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [\n        []\n    ],\n    upperOpen: false\n};\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath) ? (obj)=>{\n        if (obj[keyPath] === undefined && keyPath in obj) {\n            obj = deepClone(obj);\n            delete obj[keyPath];\n        }\n        return obj;\n    } : (obj)=>obj;\n}\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName]) throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(()=>trans._promise(mode, checkTableInTransaction, writeLocked), {\n                trans: trans,\n                transless: PSD.transless || PSD\n            }) : tempTransaction(this.db, mode, [\n                this.name\n            ], checkTableInTransaction);\n        } finally{\n            if (wasRootExec) endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);\n        return this._trans(\"readonly\", (trans)=>{\n            return this.core.get({\n                trans,\n                key: keyOrCrit\n            }).then((res)=>this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === \"string\") return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit)) return new this.db.WhereClause(this, \"[\".concat(indexOrCrit.join(\"+\"), \"]\"));\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter((ix)=>{\n            if (ix.compound && keyPaths.every((keyPath)=>ix.keyPath.indexOf(keyPath) >= 0)) {\n                for(let i = 0; i < keyPaths.length; ++i){\n                    if (keyPaths.indexOf(ix.keyPath[i]) === -1) return false;\n                }\n                return true;\n            }\n            return false;\n        }).sort((a, b)=>a.keyPath.length - b.keyPath.length)[0];\n        if (compoundIndex && this.db._maxKey !== maxString) {\n            const keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n            return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map((kp)=>indexOrCrit[kp]));\n        }\n        if (!compoundIndex && debug) console.warn(\"The query \".concat(JSON.stringify(indexOrCrit), \" on \").concat(this.name, \" would benefit of a \") + \"compound index [\".concat(keyPaths.join(\"+\"), \"]\"));\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            } catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce((param, keyPath)=>{\n            let [prevIndex, prevFilterFn] = param;\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ? combine(prevFilterFn, index && index.multi ? (x)=>{\n                    const prop = getByKeyPath(x, keyPath);\n                    return isArray(prop) && prop.some((item)=>equals(value, item));\n                } : (x)=>equals(value, getByKeyPath(x, keyPath))) : prevFilterFn\n            ];\n        }, [\n            null,\n            null\n        ]);\n        return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals(\"\");\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? \"[\".concat(index.join(\"+\"), \"]\") : index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = (obj)=>{\n            if (!obj) return obj;\n            const res = Object.create(constructor.prototype);\n            for(var m in obj)if (hasOwn(obj, m)) try {\n                res[m] = obj[m];\n            } catch (_) {}\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans(\"readwrite\", (trans)=>{\n            return this.core.mutate({\n                trans,\n                type: \"add\",\n                keys: key != null ? [\n                    key\n                ] : null,\n                values: [\n                    objToAdd\n                ]\n            });\n        }).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult)=>{\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                } catch (_) {}\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === \"object\" && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined) return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach((keyPath)=>{\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                } else {\n                    modifications(keyOrObject, {\n                        value: keyOrObject,\n                        primKey: key\n                    });\n                }\n            } catch (_a) {}\n            return this.where(\":id\").equals(key).modify(modifications);\n        } else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"put\",\n                values: [\n                    objToAdd\n                ],\n                keys: key != null ? [\n                    key\n                ] : null\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult)=>{\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                } catch (_) {}\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"delete\",\n                keys: [\n                    key\n                ]\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"deleteRange\",\n                range: AnyRange\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans(\"readonly\", (trans)=>{\n            return this.core.getMany({\n                keys,\n                trans\n            }).then((result)=>result.map((res)=>this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans(\"readwrite\", (trans)=>{\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n            return this.core.mutate({\n                trans,\n                type: \"add\",\n                keys: keys,\n                values: objectsToAdd,\n                wantResults\n            }).then((param)=>{\n                let { numFailures, results, lastResult, failures } = param;\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0) return result;\n                throw new BulkError(\"\".concat(this.name, \".bulkAdd(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans(\"readwrite\", (trans)=>{\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n            return this.core.mutate({\n                trans,\n                type: \"put\",\n                keys: keys,\n                values: objectsToPut,\n                wantResults\n            }).then((param)=>{\n                let { numFailures, results, lastResult, failures } = param;\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0) return result;\n                throw new BulkError(\"\".concat(this.name, \".bulkPut(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans(\"readwrite\", (trans)=>{\n            return this.core.mutate({\n                trans,\n                type: \"delete\",\n                keys: keys\n            });\n        }).then((param)=>{\n            let { numFailures, lastResult, failures } = param;\n            if (numFailures === 0) return lastResult;\n            throw new BulkError(\"\".concat(this.name, \".bulkDelete(): \").concat(numFailures, \" of \").concat(numKeys, \" operations failed\"), failures);\n        });\n    }\n}\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function(eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while(--i)args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        } else if (typeof eventName === \"string\") {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for(var i = 1, l = arguments.length; i < l; ++i){\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === \"object\") return addConfiguredEvents(eventName);\n        if (!chainFunction) chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction) defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function(cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function(cb) {\n                context.subscribers = context.subscribers.filter(function(fn) {\n                    return fn !== cb;\n                });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function(eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            } else if (args === \"asap\") {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while(i--)args[i] = arguments[i];\n                    context.subscribers.forEach(function(fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            } else throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n_c6 = Events;\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({\n        prototype\n    });\n    return constructor;\n}\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [\n                hookCreatingChain,\n                nop\n            ],\n            \"reading\": [\n                pureFunctionChain,\n                mirror\n            ],\n            \"updating\": [\n                hookUpdatingChain,\n                nop\n            ],\n            \"deleting\": [\n                hookDeletingChain,\n                nop\n            ]\n        });\n    });\n}\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? ()=>combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey) return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index) throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === \"prev\",\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    } else {\n        const set = {};\n        const union = (item, cursor, advance)=>{\n            if (!filter || filter(cursor, advance, (result)=>cursor.stop(result), (err)=>cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = \"\" + primaryKey;\n                if (key === \"[object ArrayBuffer]\") key = \"\" + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a)=>fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then((cursor)=>{\n        if (cursor) {\n            return cursor.start(()=>{\n                var c = ()=>cursor.continue();\n                if (!filter || filter(cursor, (advancer)=>c = advancer, (val)=>{\n                    cursor.stop(val);\n                    c = nop;\n                }, (e)=>{\n                    cursor.fail(e);\n                    c = nop;\n                })) wrappedFn(cursor.value, cursor, (advancer)=>c = advancer);\n                c();\n            });\n        }\n    });\n}\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === \"Array\") return 1;\n            if (tb === \"Array\") return -1;\n            if (ta === \"binary\") return 1;\n            if (tb === \"binary\") return -1;\n            if (ta === \"string\") return 1;\n            if (tb === \"string\") return -1;\n            if (ta === \"Date\") return 1;\n            if (tb !== \"Date\") return NaN;\n            return -1;\n        }\n        switch(ta){\n            case \"number\":\n            case \"Date\":\n            case \"string\":\n                return a > b ? 1 : a < b ? -1 : 0;\n            case \"binary\":\n                {\n                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n                }\n            case \"Array\":\n                return compareArrays(a, b);\n        }\n    } catch (_a) {}\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for(let i = 0; i < l; ++i){\n        const res = cmp(a[i], b[i]);\n        if (res !== 0) return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for(let i = 0; i < l; ++i){\n        if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== \"object\") return t;\n    if (ArrayBuffer.isView(x)) return \"binary\";\n    const tsTag = toStringTag(x);\n    return tsTag === \"ArrayBuffer\" ? \"binary\" : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array) return a;\n    if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans(\"readonly\", fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans(\"readwrite\", fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props) extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read((trans)=>iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read((trans)=>{\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then((count)=>Math.min(count, ctx.limit));\n            } else {\n                var count = 0;\n                return iter(ctx, ()=>{\n                    ++count;\n                    return false;\n                }, trans, coreTable).then(()=>count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split(\".\").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i) return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function(a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read((trans)=>{\n            var ctx = this._ctx;\n            if (ctx.dir === \"next\" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then((param)=>{\n                    let { result } = param;\n                    return valueMapper ? result.map(valueMapper) : result;\n                });\n            } else {\n                const a = [];\n                return iter(ctx, (item)=>a.push(item), trans, ctx.table.core).then(()=>a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0) return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, ()=>{\n                var offsetLeft = offset;\n                return (cursor, advance)=>{\n                    if (offsetLeft === 0) return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(()=>{\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        } else {\n            addReplayFilter(ctx, ()=>{\n                var offsetLeft = offset;\n                return ()=>--offsetLeft < 0;\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, ()=>{\n            var rowsLeft = numRows;\n            return function(cursor, advance, resolve) {\n                if (--rowsLeft <= 0) advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function(cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            } else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function(a) {\n            return a[0];\n        }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function(cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = this._ctx.dir === \"prev\" ? \"next\" : \"prev\";\n        if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function(val, cursor) {\n            cb(cursor.key, cursor);\n        });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function(val, cursor) {\n            cb(cursor.primaryKey, cursor);\n        });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function(item, cursor) {\n            a.push(cursor.key);\n        }).then(function() {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === \"next\" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read((trans)=>{\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then((param)=>{\n                let { result } = param;\n                return result;\n            }).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function(item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function() {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function(a) {\n            return a[0];\n        }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi) return this;\n        var set = {};\n        addFilter(this._ctx, function(cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write((trans)=>{\n            var modifyer;\n            if (typeof changes === \"function\") {\n                modifyer = changes;\n            } else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function(item) {\n                    var anythingModified = false;\n                    for(var i = 0; i < numKeys; ++i){\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res)=>{\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)){\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then((keys)=>{\n                const nextChunk = (offset)=>{\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then((values)=>{\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for(let i = 0; i < count; ++i){\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                } else {\n                                    putValues.push(ctx.value);\n                                    if (outbound) putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== \"function\" || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 && coreTable.mutate({\n                            trans,\n                            type: \"add\",\n                            values: addValues\n                        }).then((res)=>{\n                            for(let pos in res.failures){\n                                deleteKeys.splice(parseInt(pos), 1);\n                            }\n                            applyMutateResult(addValues.length, res);\n                        })).then(()=>(putValues.length > 0 || criteria && typeof changes === \"object\") && coreTable.mutate({\n                                trans,\n                                type: \"put\",\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== \"function\" && changes\n                            }).then((res)=>applyMutateResult(putValues.length, res))).then(()=>(deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({\n                                trans,\n                                type: \"delete\",\n                                keys: deleteKeys,\n                                criteria\n                            }).then((res)=>applyMutateResult(deleteKeys.length, res))).then(()=>{\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(()=>{\n                    if (totalFailures.length > 0) throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {\n            return this._write((trans)=>{\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({\n                    trans,\n                    query: {\n                        index: primaryKey,\n                        range: coreRange\n                    }\n                }).then((count)=>{\n                    return ctx.table.core.mutate({\n                        trans,\n                        type: \"deleteRange\",\n                        range: coreRange\n                    }).then((param)=>{\n                        let { failures, lastResult, results, numFailures } = param;\n                        if (numFailures) throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map((pos)=>failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx)=>ctx.value = null;\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator) try {\n            keyRange = keyRangeGenerator();\n        } catch (ex) {\n            error = ex;\n        }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, ()=>rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ? (s)=>s.toUpperCase() : (s)=>s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ? (s)=>s.toLowerCase() : (s)=>s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for(var i = 0; i < length; ++i){\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0) llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\") return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\") return key.substr(0, upperNeedle.length);\n    return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every((s)=>typeof s === \"string\")) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = dir === \"next\" ? simpleCompare : simpleCompareReverse;\n        var needleBounds = needles.map(function(needle) {\n            return {\n                lower: lower(needle),\n                upper: upper(needle)\n            };\n        }).sort(function(a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function(nb) {\n            return nb.upper;\n        });\n        lowerNeedles = needleBounds.map(function(nb) {\n            return nb.lower;\n        });\n        direction = dir;\n        nextKeySuffix = dir === \"next\" ? \"\" : suffix;\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, ()=>createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function(direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function(cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== \"string\") return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        } else {\n            var lowestPossibleCasing = null;\n            for(var i = firstPossibleNeedle; i < needlesLen; ++i){\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function() {\n                    cursor.continue(lowestPossibleCasing + nextKeySuffix);\n                });\n            } else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1,\n        lower: value,\n        upper: value\n    };\n}\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);\n            return new this.Collection(this, ()=>createRange(lower, upper, !includeLower, !includeUpper));\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>rangeEqual(value));\n    }\n    above(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== \"string\") return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\") return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>x.indexOf(a[0]) === 0, [\n            str\n        ], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a)=>x === a[0], [\n            str\n        ], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>a.some((n)=>x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0) return emptyCollection(this);\n        const c = new this.Collection(this, ()=>createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = (direction)=>{\n            compare = direction === \"next\" ? this._ascending : this._descending;\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve)=>{\n            const key = cursor.key;\n            while(compare(key, set[i]) > 0){\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            } else {\n                advance(()=>{\n                    cursor.continue(set[i]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([\n            [\n                minKey,\n                value\n            ],\n            [\n                value,\n                this.db._maxKey\n            ]\n        ], {\n            includeLowers: false,\n            includeUppers: false\n        });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val)=>res ? res.concat([\n                [\n                    res[res.length - 1][1],\n                    val\n                ]\n            ]) : [\n                [\n                    minKey,\n                    val\n                ]\n            ], null);\n        ranges.push([\n            set[set.length - 1],\n            this.db._maxKey\n        ]);\n        return this.inAnyRange(ranges, {\n            includeLowers: false,\n            includeUppers: false\n        });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0) return emptyCollection(this);\n        if (!ranges.every((range)=>range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for(; i < l; ++i){\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l) ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) {\n            return sortDirection(a[0], b[0]);\n        }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        } catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ? (key)=>ascending(key, set[rangePos][1]) > 0 : (key)=>ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ? (key)=>descending(key, set[rangePos][0]) > 0 : (key)=>descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, ()=>createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = (direction)=>{\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            } else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve)=>{\n            var key = cursor.key;\n            while(checkKey(key)){\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            } else {\n                advance(()=>{\n                    if (sortDirection === ascending) cursor.continue(set[rangePos][0]);\n                    else cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every((s)=>typeof s === \"string\")) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0) return emptyCollection(this);\n        return this.inAnyRange(set.map((str)=>[\n                str,\n                str + maxString\n            ]));\n    }\n}\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB1 = db._deps.indexedDB;\n        if (!indexedDB1) throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB1.cmp.bind(indexedDB1);\n        this._descending = (a, b)=>indexedDB1.cmp(b, a);\n        this._max = (a, b)=>indexedDB1.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b)=>indexedDB1.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\nfunction eventRejectHandler(reject) {\n    return wrap(function(event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation) event.stopPropagation();\n    if (event.preventDefault) event.preventDefault();\n}\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = \"storagemutated\";\nconst STORAGE_MUTATED_DOM_EVENT_NAME = \"x-storagemutated-1\";\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global) PSD.lockOwnerFor = null;\n            while(this._blockedFuncs.length > 0 && !this._locked()){\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                } catch (e) {}\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode) return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch(dbOpenError && dbOpenError.name){\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active) throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n            durability: this.chromeTransactionDurability\n        }) : idbdb.transaction(this.storeNames, this.mode, {\n            durability: this.chromeTransactionDurability\n        }));\n        idbtrans.onerror = wrap((ev)=>{\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap((ev)=>{\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(()=>{\n            this.active = false;\n            this._resolve();\n            if (\"mutatedParts\" in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === \"readwrite\" && this.mode !== \"readwrite\") return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active) return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject)=>{\n                this._blockedFuncs.push([\n                    ()=>{\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    },\n                    PSD\n                ]);\n            });\n        } else if (bWriteLock) {\n            return newScope(()=>{\n                var p = new DexiePromise((resolve, reject)=>{\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then) rv.then(resolve, reject);\n                });\n                p.finally(()=>this._unlock());\n                p._lib = true;\n                return p;\n            });\n        } else {\n            var p = new DexiePromise((resolve, reject)=>{\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then) rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(()=>promise);\n        } else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while(root._waitingQueue.length)root._waitingQueue.shift()();\n                if (root._waitingFor) store.get(-Infinity).onsuccess = spin;\n            })();\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject)=>{\n            promise.then((res)=>root._waitingQueue.push(wrap(resolve.bind(null, res))), (err)=>root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(()=>{\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans) this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = this._memoizedTables || (this._memoizedTables = {});\n        if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject)=>{\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(()=>{\n            this.active = false;\n            this.on.complete.fire();\n        }, (e)=>{\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? \"&\" : \"\") + (multi ? \"*\" : \"\") + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === \"string\" ? keyPath : keyPath ? \"[\" + [].join.call(keyPath, \"+\") + \"]\" : \"\";\n}\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, (index)=>[\n                index.name,\n                index\n            ])\n    };\n}\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange)=>{\n    try {\n        IdbKeyRange.only([\n            []\n        ]);\n        getMaxKey = ()=>[\n                []\n            ];\n        return [\n            []\n        ];\n    } catch (e) {\n        getMaxKey = ()=>maxString;\n        return maxString;\n    }\n};\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return ()=>undefined;\n    } else if (typeof keyPath === \"string\") {\n        return getSinglePathKeyExtractor(keyPath);\n    } else {\n        return (obj)=>getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split(\".\");\n    if (split.length === 1) {\n        return (obj)=>obj[keyPath];\n    } else {\n        return (obj)=>getByKeyPath(obj, keyPath);\n    }\n}\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ? \":id\" : typeof keyPath === \"string\" ? keyPath : \"[\".concat(keyPath.join(\"+\"), \"]\");\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map((table)=>trans.objectStore(table)).map((store)=>{\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map((indexName)=>store.index(indexName)).map((index)=>{\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath)=>indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && \"getAll\" in trans.objectStore(tables[0]) && !(typeof navigator !== \"undefined\" && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3) return null;\n        if (range.type === 4) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate(param) {\n            let { trans, type, keys, values, range } = param;\n            return new Promise((resolve, reject)=>{\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== \"delete\" && type !== \"deleteRange\") throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || {\n                    length: 1\n                };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0) return resolve({\n                    numFailures: 0,\n                    failures: {},\n                    results: [],\n                    lastResult: undefined\n                });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = (event)=>{\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === \"deleteRange\") {\n                    if (range.type === 4) return resolve({\n                        numFailures,\n                        failures,\n                        results: [],\n                        lastResult: undefined\n                    });\n                    if (range.type === 3) reqs.push(req = store.clear());\n                    else reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                } else {\n                    const [args1, args2] = isAddOrPut ? outbound ? [\n                        values,\n                        keys\n                    ] : [\n                        values,\n                        null\n                    ] : [\n                        keys,\n                        null\n                    ];\n                    if (isAddOrPut) {\n                        for(let i = 0; i < length; ++i){\n                            reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    } else {\n                        for(let i = 0; i < length; ++i){\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = (event)=>{\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i)=>req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map((req)=>req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = (event)=>{\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor(param) {\n            let { trans, values, query, reverse, unique } = param;\n            return new Promise((resolve, reject)=>{\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ? store : store.index(index.name);\n                const direction = reverse ? unique ? \"prevunique\" : \"prev\" : unique ? \"nextunique\" : \"next\";\n                const req = values || !(\"openKeyCursor\" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap((ev)=>{\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = ()=>{\n                        throw new Error(\"Cursor not started\");\n                    };\n                    const doThrowCursorIsStopped = ()=>{\n                        throw new Error(\"Cursor not stopped\");\n                    };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function() {\n                        let gotOne = 1;\n                        return this.start(()=>gotOne-- ? this.continue() : this.stop()).then(()=>this);\n                    };\n                    cursor.start = (callback)=>{\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration)=>{\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = (value)=>{\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = ()=>{\n                            if (req.result) {\n                                try {\n                                    callback();\n                                } catch (err) {\n                                    cursor.fail(err);\n                                }\n                            } else {\n                                cursor.done = true;\n                                cursor.start = ()=>{\n                                    throw new Error(\"Cursor behind last entry\");\n                                };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap((ev)=>{\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request)=>{\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0) return resolve({\n                        result: []\n                    });\n                    if (hasGetAll) {\n                        const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = (event)=>resolve({\n                                result: event.target.result\n                            });\n                        req.onerror = eventRejectHandler(reject);\n                    } else {\n                        let count = 0;\n                        const req = values || !(\"openKeyCursor\" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = (event)=>{\n                            const cursor = req.result;\n                            if (!cursor) return resolve({\n                                result\n                            });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit) return resolve({\n                                result\n                            });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany (param) {\n                let { trans, keys } = param;\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = (event)=>{\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null) ;\n                        if (++callbackCount === keyCount) resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for(let i = 0; i < length; ++i){\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0) resolve(result);\n                });\n            },\n            get (param) {\n                let { trans, key } = param;\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = (event)=>resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count (param) {\n                let { query, trans } = param;\n                const { index, range } = query;\n                return new Promise((resolve, reject)=>{\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap((ev)=>resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map((tableSchema)=>createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach((table)=>tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table (name) {\n            const result = tableMap[name];\n            if (!result) throw new Error(\"Table '\".concat(name, \"' not found\"));\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, param)=>{\n        let { create } = param;\n        return {\n            ...down,\n            ...create(down)\n        };\n    }, stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, param, tmpTrans) {\n    let { IDBKeyRange, indexedDB: indexedDB1 } = param;\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks(param, tmpTrans) {\n    let { _novip: db } = param;\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach((table)=>{\n        const tableName = table.name;\n        if (db.core.schema.tables.some((tbl)=>tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\nfunction setApiOnPlace(param, objs, tableNames, dbschema) {\n    let { _novip: db } = param;\n    tableNames.forEach((tableName)=>{\n        const schema = dbschema[tableName];\n        objs.forEach((obj)=>{\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || \"value\" in propDesc && propDesc.value === undefined) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get () {\n                            return this.table(tableName);\n                        },\n                        set (value) {\n                            defineProperty(this, tableName, {\n                                value,\n                                writable: true,\n                                configurable: true,\n                                enumerable: true\n                            });\n                        }\n                    });\n                } else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi(param, objs) {\n    let { _novip: db } = param;\n    objs.forEach((obj)=>{\n        for(let key in obj){\n            if (obj[key] instanceof db.Table) delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction(\"readwrite\", db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(()=>{\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach((tableName)=>{\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(()=>db.on.populate.fire(trans)).catch(rejectTransaction);\n        } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes(param, oldVersion, trans, idbUpgradeTrans) {\n    let { _novip: db } = param;\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter((v)=>v._cfg.version >= oldVersion);\n    versToRun.forEach((version)=>{\n        queue.push(()=>{\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach((tuple)=>{\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach((change)=>{\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                } else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach((idx)=>addIndex(store, idx));\n                    change.change.forEach((idx)=>{\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach((idxName)=>store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach((table)=>{\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [\n                    db.Transaction.prototype\n                ]);\n                setApiOnPlace(db, [\n                    db.Transaction.prototype\n                ], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(()=>{\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return returnValue && typeof returnValue.then === \"function\" ? DexiePromise.resolve(returnValue) : promiseFollowed.then(()=>returnValue);\n            }\n        });\n        queue.push((idbtrans)=>{\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [\n                db.Transaction.prototype\n            ]);\n            setApiOnPlace(db, [\n                db.Transaction.prototype\n            ], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();\n    }\n    return runQueue().then(()=>{\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for(table in oldSchema){\n        if (!newSchema[table]) diff.del.push(table);\n    }\n    for(table in newSchema){\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([\n                table,\n                newDef\n            ]);\n        } else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if (\"\" + (oldDef.primKey.keyPath || \"\") !== \"\" + (newDef.primKey.keyPath || \"\") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {\n                change.recreate = true;\n                diff.change.push(change);\n            } else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for(idxName in oldIndexes){\n                    if (!newIndexes[idxName]) change.del.push(idxName);\n                }\n                for(idxName in newIndexes){\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx) change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {\n        keyPath: primKey.keyPath,\n        autoIncrement: primKey.auto\n    } : {\n        autoIncrement: primKey.auto\n    });\n    indexes.forEach((idx)=>addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach((tableName)=>{\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach((storeName)=>newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, {\n        unique: idx.unique,\n        multiEntry: idx.multi\n    });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach((storeName)=>{\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for(let j = 0; j < store.indexNames.length; ++j){\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema(param, idbdb, tmpTrans) {\n    let { _novip: db } = param;\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [\n        db._allTables\n    ], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some((ch)=>ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames(param, schema, idbtrans) {\n    let { _novip: db } = param;\n    const storeNames = idbtrans.db.objectStoreNames;\n    for(let i = 0; i < storeNames.length; ++i){\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = \"getAll\" in store;\n        for(let j = 0; j < store.indexNames.length; ++j){\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === \"string\" ? keyPath : \"[\" + slice(keyPath).join(\"+\") + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== \"undefined\" && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(\",\").map((index, indexNum)=>{\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split(\"+\") : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach((tableName)=>{\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi) throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach((idx)=>{\n                    if (idx.auto) throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath) throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach((version)=>{\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = version._cfg.dbschema = {};\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [\n            db._allTables,\n            db,\n            db.Transaction.prototype\n        ]);\n        setApiOnPlace(db, [\n            db._allTables,\n            db,\n            db.Transaction.prototype,\n            this._cfg.tables\n        ], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\nfunction getDbNamesTable(indexedDB1, IDBKeyRange) {\n    let dbNamesDB = indexedDB1[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB1[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB: indexedDB1,\n            IDBKeyRange\n        });\n        dbNamesDB.version(1).stores({\n            dbnames: \"name\"\n        });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB1) {\n    return indexedDB1 && typeof indexedDB1.databases === \"function\";\n}\nfunction getDatabaseNames(param) {\n    let { indexedDB: indexedDB1, IDBKeyRange } = param;\n    return hasDatabasesNative(indexedDB1) ? Promise.resolve(indexedDB1.databases()).then((infos)=>infos.map((info)=>info.name).filter((name)=>name !== DBNAMES_DB)) : getDbNamesTable(indexedDB1, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated(param, name) {\n    let { indexedDB: indexedDB1, IDBKeyRange } = param;\n    !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).put({\n        name\n    }).catch(nop);\n}\nfunction _onDatabaseDeleted(param, name) {\n    let { indexedDB: indexedDB1, IDBKeyRange } = param;\n    !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).delete(name).catch(nop);\n}\nfunction vip(fn) {\n    return newScope(function() {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases) return Promise.resolve();\n    var intervalId;\n    return new Promise(function(resolve) {\n        var tryIdb = function() {\n            return indexedDB.databases().finally(resolve);\n        };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function() {\n        return clearInterval(intervalId);\n    });\n}\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB: indexedDB1 } = db._deps;\n    if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(()=>state.dbOpenError ? rejection(state.dbOpenError) : db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed(\"db.open() was cancelled\");\n    }\n    let resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;\n    const tryOpenDB = ()=>new DexiePromise((resolve, reject)=>{\n            throwIfCancelled();\n            if (!indexedDB1) throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ? indexedDB1.open(dbName) : indexedDB1.open(dbName, Math.round(db.verno * 10));\n            if (!req) throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap((e)=>{\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB1.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(()=>{\n                        reject(new exceptions.NoSuchDatabase(\"Database \".concat(dbName, \" doesnt exist\")));\n                    });\n                } else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(()=>{\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0) try {\n                    const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), \"readonly\");\n                    if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);\n                    else {\n                        adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                        if (!verifyInstalledSchema(db, tmpTrans)) {\n                            console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.\");\n                        }\n                    }\n                    generateMiddlewareStacks(db, tmpTrans);\n                } catch (e) {}\n                connections.push(db);\n                idbdb.onversionchange = wrap((ev)=>{\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap((ev)=>{\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated) _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }).catch((err)=>{\n            if (err && err.name === \"UnknownError\" && state.PR1398_maxLoop > 0) {\n                state.PR1398_maxLoop--;\n                console.warn(\"Dexie: Workaround for Chrome UnknownError on open()\");\n                return tryOpenDB();\n            } else {\n                return DexiePromise.reject(err);\n            }\n        });\n    return DexiePromise.race([\n        openCanceller,\n        (typeof navigator === \"undefined\" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n    ]).then(()=>{\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(()=>db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(()=>remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(()=>{\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(()=>{\n        return db;\n    }).catch((err)=>{\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        } catch (_a) {}\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(()=>{\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\nfunction awaitIterator(iterator) {\n    var callNext = (result)=>iterator.next(result), doThrow = (error)=>iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val)=>{\n            var next = getNext(val), value = next.value;\n            return next.done ? value : !value || typeof value.then !== \"function\" ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);\n        };\n    }\n    return step(callNext)();\n}\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2) throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while(--i)args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [\n        mode,\n        tables,\n        scopeFunc\n    ];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(()=>{\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        } else {\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            } catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn(\"Dexie: Need to reopen db\");\n                    db._close();\n                    return db.open().then(()=>enterTransactionScope(db, mode, storeNames, null, scopeFunc));\n                }\n                return rejection(ex);\n            }\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(()=>{\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                } else if (typeof returnValue.next === \"function\" && typeof returnValue.throw === \"function\") {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === \"function\" ? DexiePromise.resolve(returnValue).then((x)=>trans.active ? x : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"))) : promiseFollowed.then(()=>returnValue)).then((x)=>{\n            if (parentTransaction) trans._resolve();\n            return trans._completion.then(()=>x);\n        }).catch((e)=>{\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [\n        a\n    ];\n    for(let i = 0; i < count; ++i)result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table (tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];\n                const keyLength = keyPath == null ? 0 : typeof keyPath === \"string\" ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b)=>a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [\n                primaryKey\n            ];\n            for (const index of schema.indexes){\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1 ? 2 : range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count (req) {\n                    return table.count(translateRequest(req));\n                },\n                query (req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor (req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual) return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: {\n                                value: _continue\n                            },\n                            continuePrimaryKey: {\n                                value (key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get () {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get () {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ? key[0] : key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get () {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req)).then((cursor)=>cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || \"\";\n    keys(a).forEach((prop)=>{\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        } else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === \"object\" && typeof bp === \"object\" && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                } else if (apTypeName === \"Object\") {\n                    getObjectDiff(ap, bp, rv, prfx + prop + \".\");\n                } else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            } else if (ap !== bp) rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop)=>{\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === \"delete\") return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore)=>({\n            ...downCore,\n            table (tableName) {\n                const downTable = downCore.table(tableName);\n                const { primaryKey } = downTable.schema;\n                const tableMiddleware = {\n                    ...downTable,\n                    mutate (req) {\n                        const dxTrans = PSD.trans;\n                        const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                        switch(req.type){\n                            case \"add\":\n                                if (creating.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"put\":\n                                if (creating.fire === nop && updating.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"delete\":\n                                if (deleting.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"deleteRange\":\n                                if (deleting.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>deleteRange(req), true);\n                        }\n                        return downTable.mutate(req);\n                        function addPutOrDelete(req) {\n                            const dxTrans = PSD.trans;\n                            const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                            if (!keys) throw new Error(\"Keys missing\");\n                            req = req.type === \"add\" || req.type === \"put\" ? {\n                                ...req,\n                                keys\n                            } : {\n                                ...req\n                            };\n                            if (req.type !== \"delete\") req.values = [\n                                ...req.values\n                            ];\n                            if (req.keys) req.keys = [\n                                ...req.keys\n                            ];\n                            return getExistingValues(downTable, req, keys).then((existingValues)=>{\n                                const contexts = keys.map((key, i)=>{\n                                    const existingValue = existingValues[i];\n                                    const ctx = {\n                                        onerror: null,\n                                        onsuccess: null\n                                    };\n                                    if (req.type === \"delete\") {\n                                        deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                    } else if (req.type === \"add\" || existingValue === undefined) {\n                                        const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                        if (key == null && generatedPrimaryKey != null) {\n                                            key = generatedPrimaryKey;\n                                            req.keys[i] = key;\n                                            if (!primaryKey.outbound) {\n                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                            }\n                                        }\n                                    } else {\n                                        const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                        const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                        if (additionalChanges) {\n                                            const requestedValue = req.values[i];\n                                            Object.keys(additionalChanges).forEach((keyPath)=>{\n                                                if (hasOwn(requestedValue, keyPath)) {\n                                                    requestedValue[keyPath] = additionalChanges[keyPath];\n                                                } else {\n                                                    setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                                }\n                                            });\n                                        }\n                                    }\n                                    return ctx;\n                                });\n                                return downTable.mutate(req).then((param)=>{\n                                    let { failures, results, numFailures, lastResult } = param;\n                                    for(let i = 0; i < keys.length; ++i){\n                                        const primKey = results ? results[i] : keys[i];\n                                        const ctx = contexts[i];\n                                        if (primKey == null) {\n                                            ctx.onerror && ctx.onerror(failures[i]);\n                                        } else {\n                                            ctx.onsuccess && ctx.onsuccess(req.type === \"put\" && existingValues[i] ? req.values[i] : primKey);\n                                        }\n                                    }\n                                    return {\n                                        failures,\n                                        results,\n                                        numFailures,\n                                        lastResult\n                                    };\n                                }).catch((error)=>{\n                                    contexts.forEach((ctx)=>ctx.onerror && ctx.onerror(error));\n                                    return Promise.reject(error);\n                                });\n                            });\n                        }\n                        function deleteRange(req) {\n                            return deleteNextChunk(req.trans, req.range, 10000);\n                        }\n                        function deleteNextChunk(trans, range, limit) {\n                            return downTable.query({\n                                trans,\n                                values: false,\n                                query: {\n                                    index: primaryKey,\n                                    range\n                                },\n                                limit\n                            }).then((param)=>{\n                                let { result } = param;\n                                return addPutOrDelete({\n                                    type: \"delete\",\n                                    keys: result,\n                                    trans\n                                }).then((res)=>{\n                                    if (res.numFailures > 0) return Promise.reject(res.failures[0]);\n                                    if (result.length < limit) {\n                                        return {\n                                            failures: [],\n                                            numFailures: 0,\n                                            lastResult: undefined\n                                        };\n                                    } else {\n                                        return deleteNextChunk(trans, {\n                                            ...range,\n                                            lower: result[result.length - 1],\n                                            lowerOpen: true\n                                        }, limit);\n                                    }\n                                });\n                            });\n                        }\n                    }\n                };\n                return tableMiddleware;\n            }\n        })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\" ? Promise.resolve([]) : table.getMany({\n        trans: req.trans,\n        keys: effectiveKeys,\n        cache: \"immutable\"\n    });\n}\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache) return null;\n        if (cache.keys.length < keys.length) return null;\n        const result = [];\n        for(let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i){\n            if (cmp(cache.keys[i], keys[j]) !== 0) continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    } catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core)=>{\n        return {\n            table: (tableName)=>{\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req)=>{\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res)=>{\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req)=>{\n                        if (req.type !== \"add\") req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    }\n                };\n            }\n        };\n    }\n};\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function(fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? {\n            d: 1,\n            from: fromOrTree,\n            to: arguments.length > 1 ? to : fromOrTree\n        } : {\n            d: 0\n        });\n    } else {\n        const rv = new RangeSet();\n        if (fromOrTree && \"d\" in fromOrTree) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\n_c7 = RangeSet;\nprops(RangeSet.prototype, {\n    add (rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey (key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys (keys) {\n        keys.forEach((key)=>addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol] () {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff)) return;\n    if (diff > 0) throw RangeError();\n    if (isEmptyRange(target)) return extend(target, {\n        from,\n        to,\n        d: 1\n    });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left ? addRange(left, from, to) : target.l = {\n            from,\n            to,\n            d: 1,\n            l: null,\n            r: null\n        };\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right ? addRange(right, from, to) : target.r = {\n            from,\n            to,\n            d: 1,\n            l: null,\n            r: null\n        };\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, param) {\n        let { from, to, l, r } = param;\n        addRange(target, from, to);\n        if (l) _addRangeSet(target, l);\n        if (r) _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done) return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while(!nextResult1.done && !nextResult2.done){\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;\n        cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : {\n        s: 0,\n        n: node\n    };\n    return {\n        next (key) {\n            const keyProvided = arguments.length > 0;\n            while(state){\n                switch(state.s){\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while(state.n.l && cmp(key, state.n.from) < 0)state = {\n                                up: state,\n                                n: state.n.l,\n                                s: 1\n                            };\n                        } else {\n                            while(state.n.l)state = {\n                                up: state,\n                                n: state.n.l,\n                                s: 1\n                            };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0) return {\n                            value: state.n,\n                            done: false\n                        };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = {\n                                up: state,\n                                n: state.n.r,\n                                s: 0\n                            };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return {\n                done: true\n            };\n        }\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = {\n            ...target\n        };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth(param) {\n    let { r, l } = param;\n    return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;\n}\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core)=>{\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName)=>{\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req)=>{\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName)=>{\n                            const part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                            return mutatedParts[part] || (mutatedParts[part] = new RangeSet());\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\" ? [\n                            req.range\n                        ] : req.type === \"delete\" ? [\n                            req.keys\n                        ] : req.values.length < 50 ? [\n                            [],\n                            req.values\n                        ] : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res)=>{\n                            if (isArray(keys)) {\n                                if (type !== \"delete\") keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            } else if (keys) {\n                                const range = {\n                                    from: keys.lower,\n                                    to: keys.upper\n                                };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            } else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach((idx)=>getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    }\n                };\n                const getRange = (param)=>{\n                    let { query: { index, range } } = param;\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req)=>[\n                            primaryKey,\n                            new RangeSet(req.key)\n                        ],\n                    getMany: (req)=>[\n                            primaryKey,\n                            new RangeSet().addKeys(req.keys)\n                        ],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange\n                };\n                keys(readSubscribers).forEach((method)=>{\n                    tableClone[method] = function(req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName)=>{\n                                const part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                                return subscr[part] || (subscr[part] = new RangeSet());\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                } else {\n                                    const keysPromise = method === \"query\" && outbound && req.values && table.query({\n                                        ...req,\n                                        values: false\n                                    });\n                                    return table[method].apply(this, arguments).then((res)=>{\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then((param)=>{\n                                                    let { result: resultingKeys } = param;\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values ? res.result.map(extractKey) : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            } else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        } else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return cursor && Object.create(cursor, {\n                                                key: {\n                                                    get () {\n                                                        delsRangeSet.addKey(cursor.primaryKey);\n                                                        return cursor.key;\n                                                    }\n                                                },\n                                                primaryKey: {\n                                                    get () {\n                                                        const pkey = cursor.primaryKey;\n                                                        delsRangeSet.addKey(pkey);\n                                                        return pkey;\n                                                    }\n                                                },\n                                                value: {\n                                                    get () {\n                                                        wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                        return cursor.value;\n                                                    }\n                                                }\n                                            });\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            }\n        };\n    }\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key)=>ix.multiEntry && isArray(key) ? key.forEach((key)=>rangeSet.addKey(key)) : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i)=>{\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null) addKeyOrKeys(oldKey);\n                if (newKey != null) addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\nclass Dexie$1 {\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type(\"Given version is not a positive number\");\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter((v)=>v._cfg.version === versionNumber)[0];\n        if (versionInstance) return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve, reject)=>{\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use(param) {\n        let { stack, create, level, name } = param;\n        if (name) this.unuse({\n            stack,\n            name\n        });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({\n            stack,\n            create,\n            level: level == null ? 10 : level,\n            name\n        });\n        middlewares.sort((a, b)=>a.level - b.level);\n        return this;\n    }\n    unuse(param) {\n        let { stack, name, create } = param;\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter((mw)=>create ? mw.create !== create : name ? mw.name !== name : false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0) connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            } catch (e) {}\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise((resolve)=>{\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject)=>{\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject)=>{\n            const doDelete = ()=>{\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(()=>{\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments) throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            } else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && dbOpenError.name === \"DatabaseClosed\";\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map((name)=>this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf(\"!\") !== -1) parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf(\"?\") !== -1;\n        mode = mode.replace(\"!\", \"\").replace(\"?\", \"\");\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map((table)=>{\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== \"string\") throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY) idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE) idbMode = READWRITE;\n            else throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    } else throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach((storeName)=>{\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            } else throw new exceptions.SubTransaction(\"Table \" + storeName + \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        } catch (e) {\n            return parentTransaction ? parentTransaction._promise(null, (_, reject)=>{\n                reject(e);\n            }) : rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, \"lock\") : PSD.trans ? usePSD(PSD.transless, ()=>this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(\"Table \".concat(tableName, \" does not exist\"));\n        }\n        return this._allTables[tableName];\n    }\n    constructor(name, options){\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true,\n            PR1398_maxLoop: 3\n        };\n        state.dbReadyPromise = new DexiePromise((resolve)=>{\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject)=>{\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n            ready: [\n                promisableChain,\n                nop\n            ]\n        });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, (subscribe)=>{\n            return (subscriber, bSticky)=>{\n                Dexie$1.vip(()=>{\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);\n                        if (bSticky) subscribe(subscriber);\n                    } else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky) subscribe(subscriber);\n                    } else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky) subscribe(function unsubscribe() {\n                            db.on.ready.unsubscribe(subscriber);\n                            db.on.ready.unsubscribe(unsubscribe);\n                        });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", (ev)=>{\n            if (ev.newVersion > 0) console.warn(\"Another connection wants to upgrade database '\".concat(this.name, \"'. Closing db now to resume the upgrade.\"));\n            else console.warn(\"Another connection wants to delete database '\".concat(this.name, \"'. Closing db now to resume the delete request.\"));\n            this.close();\n        });\n        this.on(\"blocked\", (ev)=>{\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn(\"Dexie.delete('\".concat(this.name, \"') was blocked\"));\n            else console.warn(\"Upgrade '\".concat(this.name, \"' blocked by other connection holding version \").concat(ev.oldVersion / 10));\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction)=>new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = (ev)=>{\n            this.on(\"blocked\").fire(ev);\n            connections.filter((c)=>c.name === this.name && c !== this && !c._state.vcFired).map((c)=>c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, {\n            _vip: {\n                value: true\n            }\n        });\n        addons.forEach((addon)=>addon(this));\n    }\n}\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\nclass Observable {\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? {\n            next: x,\n            error,\n            complete\n        } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n    constructor(subscribe){\n        this._subscribe = subscribe;\n    }\n}\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach((part)=>{\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\nfunction liveQuery(querier) {\n    let hasValue = false;\n    let currentValue = undefined;\n    const observable = new Observable((observer)=>{\n        var _s = $RefreshSig$();\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            _s();\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = ()=>newScope(querier, {\n                    subscr,\n                    trans: null\n                });\n            const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        _s(execute, \"/tBoMdnHWUGJ5RVjhLjcPIXP5iU=\", false, function() {\n            return [\n                usePSD\n            ];\n        });\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed () {\n                return closed;\n            },\n            unsubscribe: ()=>{\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            }\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key)=>accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts)=>{\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = ()=>{\n            if (querying || closed) return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result)=>{\n                hasValue = true;\n                currentValue = result;\n                querying = false;\n                if (closed) return;\n                if (shouldNotify()) {\n                    doQuery();\n                } else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err)=>{\n                querying = false;\n                hasValue = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n    observable.hasValue = ()=>hasValue;\n    observable.getValue = ()=>currentValue;\n    return observable;\n}\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n} catch (e) {\n    domDeps = {\n        indexedDB: null,\n        IDBKeyRange: null\n    };\n}\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete (databaseName) {\n        const db = new Dexie(databaseName, {\n            addons: []\n        });\n        return db.delete();\n    },\n    exists (name) {\n        return new Dexie(name, {\n            addons: []\n        }).open().then((db)=>{\n            db.close();\n            return true;\n        }).catch(\"NoSuchDatabaseError\", ()=>false);\n    },\n    getDatabaseNames (cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        } catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass () {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction (scopeFunc) {\n        return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();\n    },\n    vip,\n    async: function(generatorFn) {\n        return function() {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== \"function\") return DexiePromise.resolve(rv);\n                return rv;\n            } catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function(generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== \"function\") return DexiePromise.resolve(rv);\n            return rv;\n        } catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: ()=>PSD.trans || null\n    },\n    waitFor: function(promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === \"function\" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);\n        return PSD.trans ? PSD.trans.waitFor(promise) : promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: ()=>debug,\n        set: (value)=>{\n            setDebug(value, value === \"dexie\" ? ()=>true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split(\".\").map((n)=>parseInt(n)).reduce((p, c, i)=>p + c / Math.pow(10, i * 2))\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\nif (typeof dispatchEvent !== \"undefined\" && typeof addEventListener !== \"undefined\") {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (updatedParts)=>{\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            } else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, (param)=>{\n        let { detail } = param;\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    } finally{\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\nif (typeof BroadcastChannel !== \"undefined\") {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    if (typeof bc.unref === \"function\") {\n        bc.unref();\n    }\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts)=>{\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev)=>{\n        if (ev.data) propagateLocally(ev.data);\n    };\n} else if (typeof self !== \"undefined\" && typeof navigator !== \"undefined\") {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts)=>{\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts\n                    }));\n                }\n                if (typeof self[\"clients\"] === \"object\") {\n                    [\n                        ...self[\"clients\"].matchAll({\n                            includeUncontrolled: true\n                        })\n                    ].forEach((client)=>client.postMessage({\n                            type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                            changedParts\n                        }));\n                }\n            }\n        } catch (_a) {}\n    });\n    if (typeof addEventListener !== \"undefined\") {\n        addEventListener(\"storage\", (ev)=>{\n            if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n                const data = JSON.parse(ev.newValue);\n                if (data) propagateLocally(data.changedParts);\n            }\n        });\n    }\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener(\"message\", propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally(param) {\n    let { data } = param;\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n //# sourceMappingURL=dexie.mjs.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7;\n$RefreshReg$(_c, \"DexieError\");\n$RefreshReg$(_c1, \"ModifyError\");\n$RefreshReg$(_c2, \"BulkError\");\n$RefreshReg$(_c3, \"DexiePromise\");\n$RefreshReg$(_c4, \"Listener\");\n$RefreshReg$(_c5, \"PromiseReject\");\n$RefreshReg$(_c6, \"Events\");\n$RefreshReg$(_c7, \"RangeSet\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGV4aWVAMy4yLjcvbm9kZV9tb2R1bGVzL2RleGllL2Rpc3QvbW9kZXJuL2RleGllLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Q0FXQztBQUVELE1BQU1BLFVBQVUsT0FBT0MsZUFBZSxjQUFjQSxhQUNoRCxPQUFPQyxTQUFTLGNBQWNBLE9BQzFCLEtBQWtCLEdBQWNDLFNBQzVCQyxDQUFNQTtBQUVsQixNQUFNQyxPQUFPQyxPQUFPRCxJQUFJO0FBQ3hCLE1BQU1FLFVBQVVDLE1BQU1ELE9BQU87QUFDN0IsSUFBSSxPQUFPRSxZQUFZLGVBQWUsQ0FBQ1QsUUFBUVMsT0FBTyxFQUFFO0lBQ3BEVCxRQUFRUyxPQUFPLEdBQUdBO0FBQ3RCO0FBQ0EsU0FBU0MsT0FBT0MsR0FBRyxFQUFFQyxTQUFTO0lBQzFCLElBQUksT0FBT0EsY0FBYyxVQUNyQixPQUFPRDtJQUNYTixLQUFLTyxXQUFXQyxPQUFPLENBQUMsU0FBVUMsR0FBRztRQUNqQ0gsR0FBRyxDQUFDRyxJQUFJLEdBQUdGLFNBQVMsQ0FBQ0UsSUFBSTtJQUM3QjtJQUNBLE9BQU9IO0FBQ1g7QUFDQSxNQUFNSSxXQUFXVCxPQUFPVSxjQUFjO0FBQ3RDLE1BQU1DLFVBQVUsQ0FBQyxFQUFFQyxjQUFjO0FBQ2pDLFNBQVNDLE9BQU9SLEdBQUcsRUFBRVMsSUFBSTtJQUNyQixPQUFPSCxRQUFRSSxJQUFJLENBQUNWLEtBQUtTO0FBQzdCO0FBQ0EsU0FBU0UsTUFBTUMsS0FBSyxFQUFFWCxTQUFTO0lBQzNCLElBQUksT0FBT0EsY0FBYyxZQUNyQkEsWUFBWUEsVUFBVUcsU0FBU1E7SUFDbEMsUUFBT0MsWUFBWSxjQUFjbkIsT0FBT21CLFFBQVFDLE9BQU8sRUFBRWIsV0FBV0MsT0FBTyxDQUFDQyxDQUFBQTtRQUN6RVksUUFBUUgsT0FBT1QsS0FBS0YsU0FBUyxDQUFDRSxJQUFJO0lBQ3RDO0FBQ0o7QUFD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QXFCO3dCQUFLO3FCQUFHLENBQUNycUMsT0FBTyxDQUFDLENBQUNzcUMsU0FBV0EsT0FBT1QsV0FBVyxDQUFDOzRCQUNoR241QixNQUFNb2Q7NEJBQ044Yjt3QkFDSjtnQkFDSjtZQUNKO1FBQ0osRUFDQSxPQUFPNXFCLElBQUksQ0FBRTtJQUNqQjtJQUNBLElBQUksT0FBT2txQixxQkFBcUIsYUFBYTtRQUN6Q0EsaUJBQWlCLFdBQVcsQ0FBQ3BhO1lBQ3pCLElBQUlBLEdBQUc3dUIsR0FBRyxLQUFLNnRCLGdDQUFnQztnQkFDM0MsTUFBTWljLE9BQU92dEIsS0FBSyt0QixLQUFLLENBQUN6YixHQUFHMGIsUUFBUTtnQkFDbkMsSUFBSVQsTUFDQVQsaUJBQWlCUyxLQUFLSCxZQUFZO1lBQzFDO1FBQ0o7SUFDSjtJQUNBLE1BQU1hLGNBQWNwckMsS0FBSzhOLFFBQVEsSUFBSXNNLFVBQVVpeEIsYUFBYTtJQUM1RCxJQUFJRCxhQUFhO1FBQ2JBLFlBQVl2QixnQkFBZ0IsQ0FBQyxXQUFXeUI7SUFDNUM7QUFDSjtBQUNBLFNBQVNBLHdCQUF3QixLQUFRO1FBQVIsRUFBRVosSUFBSSxFQUFFLEdBQVI7SUFDN0IsSUFBSUEsUUFBUUEsS0FBS3I1QixJQUFJLEtBQUtvZCxnQ0FBZ0M7UUFDdER3YixpQkFBaUJTLEtBQUtILFlBQVk7SUFDdEM7QUFDSjtBQUVBOTZCLGFBQWFkLGVBQWUsR0FBR3pEO0FBQy9CakQsU0FBU0osT0FBTzJTO0FBRWlGLENBQ2pHLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RleGllQDMuMi43L25vZGVfbW9kdWxlcy9kZXhpZS9kaXN0L21vZGVybi9kZXhpZS5tanM/NWJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogRGV4aWUuanMgLSBhIG1pbmltYWxpc3RpYyB3cmFwcGVyIGZvciBJbmRleGVkREJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQnkgRGF2aWQgRmFobGFuZGVyLCBkYXZpZC5mYWhsYW5kZXJAZ21haWwuY29tXG4gKlxuICogVmVyc2lvbiAzLjIuNywgV2VkIE1hciAyMCAyMDI0XG4gKlxuICogaHR0cHM6Ly9kZXhpZS5vcmdcbiAqXG4gKiBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgSmFudWFyeSAyMDA0LCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvXG4gKi9cbiBcbmNvbnN0IF9nbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDpcbiAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDpcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOlxuICAgICAgICAgICAgZ2xvYmFsO1xuXG5jb25zdCBrZXlzID0gT2JqZWN0LmtleXM7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIV9nbG9iYWwuUHJvbWlzZSkge1xuICAgIF9nbG9iYWwuUHJvbWlzZSA9IFByb21pc2U7XG59XG5mdW5jdGlvbiBleHRlbmQob2JqLCBleHRlbnNpb24pIHtcbiAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAga2V5cyhleHRlbnNpb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBvYmpba2V5XSA9IGV4dGVuc2lvbltrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG5jb25zdCBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbmNvbnN0IF9oYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093bihvYmosIHByb3ApIHtcbiAgICByZXR1cm4gX2hhc093bi5jYWxsKG9iaiwgcHJvcCk7XG59XG5mdW5jdGlvbiBwcm9wcyhwcm90bywgZXh0ZW5zaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbihnZXRQcm90byhwcm90bykpO1xuICAgICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiA/IGtleXMgOiBSZWZsZWN0Lm93bktleXMpKGV4dGVuc2lvbikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBzZXRQcm9wKHByb3RvLCBrZXksIGV4dGVuc2lvbltrZXldKTtcbiAgICB9KTtcbn1cbmNvbnN0IGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuZnVuY3Rpb24gc2V0UHJvcChvYmosIHByb3AsIGZ1bmN0aW9uT3JHZXRTZXQsIG9wdGlvbnMpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGV4dGVuZChmdW5jdGlvbk9yR2V0U2V0ICYmIGhhc093bihmdW5jdGlvbk9yR2V0U2V0LCBcImdldFwiKSAmJiB0eXBlb2YgZnVuY3Rpb25PckdldFNldC5nZXQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICB7IGdldDogZnVuY3Rpb25PckdldFNldC5nZXQsIHNldDogZnVuY3Rpb25PckdldFNldC5zZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IDpcbiAgICAgICAgeyB2YWx1ZTogZnVuY3Rpb25PckdldFNldCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiBkZXJpdmUoQ2hpbGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBmdW5jdGlvbiAoUGFyZW50KSB7XG4gICAgICAgICAgICBDaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgc2V0UHJvcChDaGlsZC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgQ2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBleHRlbmQ6IHByb3BzLmJpbmQobnVsbCwgQ2hpbGQucHJvdG90eXBlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICAgIGNvbnN0IHBkID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgbGV0IHByb3RvO1xuICAgIHJldHVybiBwZCB8fCAocHJvdG8gPSBnZXRQcm90byhvYmopKSAmJiBnZXRQcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApO1xufVxuY29uc3QgX3NsaWNlID0gW10uc2xpY2U7XG5mdW5jdGlvbiBzbGljZShhcmdzLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIF9zbGljZS5jYWxsKGFyZ3MsIHN0YXJ0LCBlbmQpO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGUob3JpZ0Z1bmMsIG92ZXJyaWRlZEZhY3RvcnkpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVkRmFjdG9yeShvcmlnRnVuYyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoYikge1xuICAgIGlmICghYilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIEZhaWxlZFwiKTtcbn1cbmZ1bmN0aW9uIGFzYXAkMShmbikge1xuICAgIGlmIChfZ2xvYmFsLnNldEltbWVkaWF0ZSlcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICBlbHNlXG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnJheSwgZXh0cmFjdG9yKSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgocmVzdWx0LCBpdGVtLCBpKSA9PiB7XG4gICAgICAgIHZhciBuYW1lQW5kVmFsdWUgPSBleHRyYWN0b3IoaXRlbSwgaSk7XG4gICAgICAgIGlmIChuYW1lQW5kVmFsdWUpXG4gICAgICAgICAgICByZXN1bHRbbmFtZUFuZFZhbHVlWzBdXSA9IG5hbWVBbmRWYWx1ZVsxXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiB0cnlDYXRjaChmbiwgb25lcnJvciwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgb25lcnJvciAmJiBvbmVycm9yKGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyAmJiBoYXNPd24ob2JqLCBrZXlQYXRoKSlcbiAgICAgICAgcmV0dXJuIG9ialtrZXlQYXRoXTtcbiAgICBpZiAoIWtleVBhdGgpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0pO1xuICAgICAgICAgICAgcnYucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpXTtcbiAgICAgICAgcmV0dXJuIGlubmVyT2JqID09IG51bGwgPyB1bmRlZmluZWQgOiBnZXRCeUtleVBhdGgoaW5uZXJPYmosIGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKSB7XG4gICAgaWYgKCFvYmogfHwga2V5UGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCdpc0Zyb3plbicgaW4gT2JqZWN0ICYmIE9iamVjdC5pc0Zyb3plbihvYmopKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiBrZXlQYXRoKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICdsZW5ndGgnIGluIHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSwgdmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcGVyaW9kID0ga2V5UGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEtleVBhdGggPSBrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZ0tleVBhdGggPSBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdLZXlQYXRoID09PSBcIlwiKVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG9iaikgJiYgIWlzTmFOKHBhcnNlSW50KGN1cnJlbnRLZXlQYXRoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouc3BsaWNlKGN1cnJlbnRLZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtjdXJyZW50S2V5UGF0aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqW2N1cnJlbnRLZXlQYXRoXSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyT2JqIHx8ICFoYXNPd24ob2JqLCBjdXJyZW50S2V5UGF0aCkpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyT2JqID0gKG9ialtjdXJyZW50S2V5UGF0aF0gPSB7fSk7XG4gICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGlubmVyT2JqLCByZW1haW5pbmdLZXlQYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG9iaikgJiYgIWlzTmFOKHBhcnNlSW50KGtleVBhdGgpKSlcbiAgICAgICAgICAgICAgICAgICAgb2JqLnNwbGljZShrZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb2JqW2tleVBhdGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkZWxCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJylcbiAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdW5kZWZpbmVkKTtcbiAgICBlbHNlIGlmICgnbGVuZ3RoJyBpbiBrZXlQYXRoKVxuICAgICAgICBbXS5tYXAuY2FsbChrZXlQYXRoLCBmdW5jdGlvbiAoa3ApIHtcbiAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtwLCB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmopIHtcbiAgICB2YXIgcnYgPSB7fTtcbiAgICBmb3IgKHZhciBtIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duKG9iaiwgbSkpXG4gICAgICAgICAgICBydlttXSA9IG9ialttXTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufVxuY29uc3QgY29uY2F0ID0gW10uY29uY2F0O1xuZnVuY3Rpb24gZmxhdHRlbihhKSB7XG4gICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgYSk7XG59XG5jb25zdCBpbnRyaW5zaWNUeXBlTmFtZXMgPSBcIkJpZ1VpbnQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQXJyYXksQm9vbGVhbixTdHJpbmcsRGF0ZSxSZWdFeHAsQmxvYixGaWxlLEZpbGVMaXN0LEZpbGVTeXN0ZW1GaWxlSGFuZGxlLEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUsQXJyYXlCdWZmZXIsRGF0YVZpZXcsVWludDhDbGFtcGVkQXJyYXksSW1hZ2VCaXRtYXAsSW1hZ2VEYXRhLE1hcCxTZXQsQ3J5cHRvS2V5XCJcbiAgICAuc3BsaXQoJywnKS5jb25jYXQoZmxhdHRlbihbOCwgMTYsIDMyLCA2NF0ubWFwKG51bSA9PiBbXCJJbnRcIiwgXCJVaW50XCIsIFwiRmxvYXRcIl0ubWFwKHQgPT4gdCArIG51bSArIFwiQXJyYXlcIikpKSkuZmlsdGVyKHQgPT4gX2dsb2JhbFt0XSk7XG5jb25zdCBpbnRyaW5zaWNUeXBlcyA9IGludHJpbnNpY1R5cGVOYW1lcy5tYXAodCA9PiBfZ2xvYmFsW3RdKTtcbmFycmF5VG9PYmplY3QoaW50cmluc2ljVHlwZU5hbWVzLCB4ID0+IFt4LCB0cnVlXSk7XG5sZXQgY2lyY3VsYXJSZWZzID0gbnVsbDtcbmZ1bmN0aW9uIGRlZXBDbG9uZShhbnkpIHtcbiAgICBjaXJjdWxhclJlZnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBydiA9IGlubmVyRGVlcENsb25lKGFueSk7XG4gICAgY2lyY3VsYXJSZWZzID0gbnVsbDtcbiAgICByZXR1cm4gcnY7XG59XG5mdW5jdGlvbiBpbm5lckRlZXBDbG9uZShhbnkpIHtcbiAgICBpZiAoIWFueSB8fCB0eXBlb2YgYW55ICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGFueTtcbiAgICBsZXQgcnYgPSBjaXJjdWxhclJlZnMgJiYgY2lyY3VsYXJSZWZzLmdldChhbnkpO1xuICAgIGlmIChydilcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIGlmIChpc0FycmF5KGFueSkpIHtcbiAgICAgICAgcnYgPSBbXTtcbiAgICAgICAgY2lyY3VsYXJSZWZzICYmIGNpcmN1bGFyUmVmcy5zZXQoYW55LCBydik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYW55Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgcnYucHVzaChpbm5lckRlZXBDbG9uZShhbnlbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnRyaW5zaWNUeXBlcy5pbmRleE9mKGFueS5jb25zdHJ1Y3RvcikgPj0gMCkge1xuICAgICAgICBydiA9IGFueTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8oYW55KTtcbiAgICAgICAgcnYgPSBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHt9IDogT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICAgIGNpcmN1bGFyUmVmcyAmJiBjaXJjdWxhclJlZnMuc2V0KGFueSwgcnYpO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGFueSkge1xuICAgICAgICAgICAgaWYgKGhhc093bihhbnksIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcnZbcHJvcF0gPSBpbm5lckRlZXBDbG9uZShhbnlbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cbmNvbnN0IHsgdG9TdHJpbmcgfSA9IHt9O1xuZnVuY3Rpb24gdG9TdHJpbmdUYWcobykge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbn1cbmNvbnN0IGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgIFN5bWJvbC5pdGVyYXRvciA6XG4gICAgJ0BAaXRlcmF0b3InO1xuY29uc3QgZ2V0SXRlcmF0b3JPZiA9IHR5cGVvZiBpdGVyYXRvclN5bWJvbCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIGk7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiAoaSA9IHhbaXRlcmF0b3JTeW1ib2xdKSAmJiBpLmFwcGx5KHgpO1xufSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG5jb25zdCBOT19DSEFSX0FSUkFZID0ge307XG5mdW5jdGlvbiBnZXRBcnJheU9mKGFycmF5TGlrZSkge1xuICAgIHZhciBpLCBhLCB4LCBpdDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoaXNBcnJheShhcnJheUxpa2UpKVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5TGlrZS5zbGljZSgpO1xuICAgICAgICBpZiAodGhpcyA9PT0gTk9fQ0hBUl9BUlJBWSAmJiB0eXBlb2YgYXJyYXlMaWtlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgICAgaWYgKChpdCA9IGdldEl0ZXJhdG9yT2YoYXJyYXlMaWtlKSkpIHtcbiAgICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICgoeCA9IGl0Lm5leHQoKSksICF4LmRvbmUpXG4gICAgICAgICAgICAgICAgYS5wdXNoKHgudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5TGlrZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgICAgICBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYSA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgYVtpXSA9IGFycmF5TGlrZVtpXTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICB9XG4gICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYSA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBhW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBhO1xufVxuY29uc3QgaXNBc3luY0Z1bmN0aW9uID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IChmbikgPT4gZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jRnVuY3Rpb24nXG4gICAgOiAoKSA9PiBmYWxzZTtcblxudmFyIGRlYnVnID0gdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC9eKGh0dHB8aHR0cHMpOlxcL1xcLyhsb2NhbGhvc3R8MTI3XFwuMFxcLjBcXC4xKS8udGVzdChsb2NhdGlvbi5ocmVmKTtcbmZ1bmN0aW9uIHNldERlYnVnKHZhbHVlLCBmaWx0ZXIpIHtcbiAgICBkZWJ1ZyA9IHZhbHVlO1xuICAgIGxpYnJhcnlGaWx0ZXIgPSBmaWx0ZXI7XG59XG52YXIgbGlicmFyeUZpbHRlciA9ICgpID0+IHRydWU7XG5jb25zdCBORUVEU19USFJPV19GT1JfU1RBQ0sgPSAhbmV3IEVycm9yKFwiXCIpLnN0YWNrO1xuZnVuY3Rpb24gZ2V0RXJyb3JXaXRoU3RhY2soKSB7XG4gICAgaWYgKE5FRURTX1RIUk9XX0ZPUl9TVEFDSylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdldEVycm9yV2l0aFN0YWNrLmFyZ3VtZW50cztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoKTtcbn1cbmZ1bmN0aW9uIHByZXR0eVN0YWNrKGV4Y2VwdGlvbiwgbnVtSWdub3JlZEZyYW1lcykge1xuICAgIHZhciBzdGFjayA9IGV4Y2VwdGlvbi5zdGFjaztcbiAgICBpZiAoIXN0YWNrKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICBudW1JZ25vcmVkRnJhbWVzID0gKG51bUlnbm9yZWRGcmFtZXMgfHwgMCk7XG4gICAgaWYgKHN0YWNrLmluZGV4T2YoZXhjZXB0aW9uLm5hbWUpID09PSAwKVxuICAgICAgICBudW1JZ25vcmVkRnJhbWVzICs9IChleGNlcHRpb24ubmFtZSArIGV4Y2VwdGlvbi5tZXNzYWdlKS5zcGxpdCgnXFxuJykubGVuZ3RoO1xuICAgIHJldHVybiBzdGFjay5zcGxpdCgnXFxuJylcbiAgICAgICAgLnNsaWNlKG51bUlnbm9yZWRGcmFtZXMpXG4gICAgICAgIC5maWx0ZXIobGlicmFyeUZpbHRlcilcbiAgICAgICAgLm1hcChmcmFtZSA9PiBcIlxcblwiICsgZnJhbWUpXG4gICAgICAgIC5qb2luKCcnKTtcbn1cblxudmFyIGRleGllRXJyb3JOYW1lcyA9IFtcbiAgICAnTW9kaWZ5JyxcbiAgICAnQnVsaycsXG4gICAgJ09wZW5GYWlsZWQnLFxuICAgICdWZXJzaW9uQ2hhbmdlJyxcbiAgICAnU2NoZW1hJyxcbiAgICAnVXBncmFkZScsXG4gICAgJ0ludmFsaWRUYWJsZScsXG4gICAgJ01pc3NpbmdBUEknLFxuICAgICdOb1N1Y2hEYXRhYmFzZScsXG4gICAgJ0ludmFsaWRBcmd1bWVudCcsXG4gICAgJ1N1YlRyYW5zYWN0aW9uJyxcbiAgICAnVW5zdXBwb3J0ZWQnLFxuICAgICdJbnRlcm5hbCcsXG4gICAgJ0RhdGFiYXNlQ2xvc2VkJyxcbiAgICAnUHJlbWF0dXJlQ29tbWl0JyxcbiAgICAnRm9yZWlnbkF3YWl0J1xuXTtcbnZhciBpZGJEb21FcnJvck5hbWVzID0gW1xuICAgICdVbmtub3duJyxcbiAgICAnQ29uc3RyYWludCcsXG4gICAgJ0RhdGEnLFxuICAgICdUcmFuc2FjdGlvbkluYWN0aXZlJyxcbiAgICAnUmVhZE9ubHknLFxuICAgICdWZXJzaW9uJyxcbiAgICAnTm90Rm91bmQnLFxuICAgICdJbnZhbGlkU3RhdGUnLFxuICAgICdJbnZhbGlkQWNjZXNzJyxcbiAgICAnQWJvcnQnLFxuICAgICdUaW1lb3V0JyxcbiAgICAnUXVvdGFFeGNlZWRlZCcsXG4gICAgJ1N5bnRheCcsXG4gICAgJ0RhdGFDbG9uZSdcbl07XG52YXIgZXJyb3JMaXN0ID0gZGV4aWVFcnJvck5hbWVzLmNvbmNhdChpZGJEb21FcnJvck5hbWVzKTtcbnZhciBkZWZhdWx0VGV4dHMgPSB7XG4gICAgVmVyc2lvbkNoYW5nZWQ6IFwiRGF0YWJhc2UgdmVyc2lvbiBjaGFuZ2VkIGJ5IG90aGVyIGRhdGFiYXNlIGNvbm5lY3Rpb25cIixcbiAgICBEYXRhYmFzZUNsb3NlZDogXCJEYXRhYmFzZSBoYXMgYmVlbiBjbG9zZWRcIixcbiAgICBBYm9ydDogXCJUcmFuc2FjdGlvbiBhYm9ydGVkXCIsXG4gICAgVHJhbnNhY3Rpb25JbmFjdGl2ZTogXCJUcmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBjb21wbGV0ZWQgb3IgZmFpbGVkXCIsXG4gICAgTWlzc2luZ0FQSTogXCJJbmRleGVkREIgQVBJIG1pc3NpbmcuIFBsZWFzZSB2aXNpdCBodHRwczovL3Rpbnl1cmwuY29tL3kydXV2c2tiXCJcbn07XG5mdW5jdGlvbiBEZXhpZUVycm9yKG5hbWUsIG1zZykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xufVxuZGVyaXZlKERleGllRXJyb3IpLmZyb20oRXJyb3IpLmV4dGVuZCh7XG4gICAgc3RhY2s6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2sgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5fc3RhY2sgPSB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBwcmV0dHlTdGFjayh0aGlzLl9lLCAyKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH1cbn0pO1xuZnVuY3Rpb24gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcykge1xuICAgIHJldHVybiBtc2cgKyBcIi4gRXJyb3JzOiBcIiArIE9iamVjdC5rZXlzKGZhaWx1cmVzKVxuICAgICAgICAubWFwKGtleSA9PiBmYWlsdXJlc1trZXldLnRvU3RyaW5nKCkpXG4gICAgICAgIC5maWx0ZXIoKHYsIGksIHMpID0+IHMuaW5kZXhPZih2KSA9PT0gaSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuZnVuY3Rpb24gTW9kaWZ5RXJyb3IobXNnLCBmYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzKSB7XG4gICAgdGhpcy5fZSA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgdGhpcy5mYWlsdXJlcyA9IGZhaWx1cmVzO1xuICAgIHRoaXMuZmFpbGVkS2V5cyA9IGZhaWxlZEtleXM7XG4gICAgdGhpcy5zdWNjZXNzQ291bnQgPSBzdWNjZXNzQ291bnQ7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcyk7XG59XG5kZXJpdmUoTW9kaWZ5RXJyb3IpLmZyb20oRGV4aWVFcnJvcik7XG5mdW5jdGlvbiBCdWxrRXJyb3IobXNnLCBmYWlsdXJlcykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMubmFtZSA9IFwiQnVsa0Vycm9yXCI7XG4gICAgdGhpcy5mYWlsdXJlcyA9IE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAocG9zID0+IGZhaWx1cmVzW3Bvc10pO1xuICAgIHRoaXMuZmFpbHVyZXNCeVBvcyA9IGZhaWx1cmVzO1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpO1xufVxuZGVyaXZlKEJ1bGtFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcbnZhciBlcnJuYW1lcyA9IGVycm9yTGlzdC5yZWR1Y2UoKG9iaiwgbmFtZSkgPT4gKG9ialtuYW1lXSA9IG5hbWUgKyBcIkVycm9yXCIsIG9iaiksIHt9KTtcbmNvbnN0IEJhc2VFeGNlcHRpb24gPSBEZXhpZUVycm9yO1xudmFyIGV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKChvYmosIG5hbWUpID0+IHtcbiAgICB2YXIgZnVsbE5hbWUgPSBuYW1lICsgXCJFcnJvclwiO1xuICAgIGZ1bmN0aW9uIERleGllRXJyb3IobXNnT3JJbm5lciwgaW5uZXIpIHtcbiAgICAgICAgdGhpcy5fZSA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IGZ1bGxOYW1lO1xuICAgICAgICBpZiAoIW1zZ09ySW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGRlZmF1bHRUZXh0c1tuYW1lXSB8fCBmdWxsTmFtZTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtc2dPcklubmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7bXNnT3JJbm5lcn0keyFpbm5lciA/ICcnIDogJ1xcbiAnICsgaW5uZXJ9YDtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lciB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtc2dPcklubmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7bXNnT3JJbm5lci5uYW1lfSAke21zZ09ySW5uZXIubWVzc2FnZX1gO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG1zZ09ySW5uZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVyaXZlKERleGllRXJyb3IpLmZyb20oQmFzZUV4Y2VwdGlvbik7XG4gICAgb2JqW25hbWVdID0gRGV4aWVFcnJvcjtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuZXhjZXB0aW9ucy5TeW50YXggPSBTeW50YXhFcnJvcjtcbmV4Y2VwdGlvbnMuVHlwZSA9IFR5cGVFcnJvcjtcbmV4Y2VwdGlvbnMuUmFuZ2UgPSBSYW5nZUVycm9yO1xudmFyIGV4Y2VwdGlvbk1hcCA9IGlkYkRvbUVycm9yTmFtZXMucmVkdWNlKChvYmosIG5hbWUpID0+IHtcbiAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgIHJldHVybiBvYmo7XG59LCB7fSk7XG5mdW5jdGlvbiBtYXBFcnJvcihkb21FcnJvciwgbWVzc2FnZSkge1xuICAgIGlmICghZG9tRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBEZXhpZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgU3ludGF4RXJyb3IgfHwgIWRvbUVycm9yLm5hbWUgfHwgIWV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXSlcbiAgICAgICAgcmV0dXJuIGRvbUVycm9yO1xuICAgIHZhciBydiA9IG5ldyBleGNlcHRpb25NYXBbZG9tRXJyb3IubmFtZV0obWVzc2FnZSB8fCBkb21FcnJvci5tZXNzYWdlLCBkb21FcnJvcik7XG4gICAgaWYgKFwic3RhY2tcIiBpbiBkb21FcnJvcikge1xuICAgICAgICBzZXRQcm9wKHJ2LCBcInN0YWNrXCIsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXIuc3RhY2s7XG4gICAgICAgICAgICB9IH0pO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG52YXIgZnVsbE5hbWVFeGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLCBuYW1lKSA9PiB7XG4gICAgaWYgKFtcIlN5bnRheFwiLCBcIlR5cGVcIiwgXCJSYW5nZVwiXS5pbmRleE9mKG5hbWUpID09PSAtMSlcbiAgICAgICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuZnVsbE5hbWVFeGNlcHRpb25zLk1vZGlmeUVycm9yID0gTW9kaWZ5RXJyb3I7XG5mdWxsTmFtZUV4Y2VwdGlvbnMuRGV4aWVFcnJvciA9IERleGllRXJyb3I7XG5mdWxsTmFtZUV4Y2VwdGlvbnMuQnVsa0Vycm9yID0gQnVsa0Vycm9yO1xuXG5mdW5jdGlvbiBub3AoKSB7IH1cbmZ1bmN0aW9uIG1pcnJvcih2YWwpIHsgcmV0dXJuIHZhbDsgfVxuZnVuY3Rpb24gcHVyZUZ1bmN0aW9uQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09IG51bGwgfHwgZjEgPT09IG1pcnJvcilcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBmMihmMSh2YWwpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY2FsbEJvdGgob24xLCBvbjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tDcmVhdGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IHJlcztcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcylcbiAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgaWYgKG9uZXJyb3IpXG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICAgICAgcmV0dXJuIHJlczIgIT09IHVuZGVmaW5lZCA/IHJlczIgOiByZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tEZWxldGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChvbnN1Y2Nlc3MpXG4gICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgIGlmIChvbmVycm9yKVxuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tVcGRhdGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZmljYXRpb25zKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBleHRlbmQobW9kaWZpY2F0aW9ucywgcmVzKTtcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcylcbiAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgaWYgKG9uZXJyb3IpXG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICAgICAgcmV0dXJuIHJlcyA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIChyZXMyID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZXMyKSA6XG4gICAgICAgICAgICAoZXh0ZW5kKHJlcywgcmVzMikpO1xuICAgIH07XG59XG5mdW5jdGlvbiByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByb21pc2FibGVDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHRoaXogPSB0aGlzLCBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIHJldHVybiByZXMudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXosIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxudmFyIElOVEVSTkFMID0ge307XG5jb25zdCBMT05HX1NUQUNLU19DTElQX0xJTUlUID0gMTAwLFxuTUFYX0xPTkdfU1RBQ0tTID0gMjAsIFpPTkVfRUNIT19MSU1JVCA9IDEwMCwgW3Jlc29sdmVkTmF0aXZlUHJvbWlzZSwgbmF0aXZlUHJvbWlzZVByb3RvLCByZXNvbHZlZEdsb2JhbFByb21pc2VdID0gdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID9cbiAgICBbXSA6XG4gICAgKCgpID0+IHtcbiAgICAgICAgbGV0IGdsb2JhbFAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnIHx8ICFjcnlwdG8uc3VidGxlKVxuICAgICAgICAgICAgcmV0dXJuIFtnbG9iYWxQLCBnZXRQcm90byhnbG9iYWxQKSwgZ2xvYmFsUF07XG4gICAgICAgIGNvbnN0IG5hdGl2ZVAgPSBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS01MTJcIiwgbmV3IFVpbnQ4QXJyYXkoWzBdKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuYXRpdmVQLFxuICAgICAgICAgICAgZ2V0UHJvdG8obmF0aXZlUCksXG4gICAgICAgICAgICBnbG9iYWxQXG4gICAgICAgIF07XG4gICAgfSkoKSwgbmF0aXZlUHJvbWlzZVRoZW4gPSBuYXRpdmVQcm9taXNlUHJvdG8gJiYgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW47XG5jb25zdCBOYXRpdmVQcm9taXNlID0gcmVzb2x2ZWROYXRpdmVQcm9taXNlICYmIHJlc29sdmVkTmF0aXZlUHJvbWlzZS5jb25zdHJ1Y3RvcjtcbmNvbnN0IHBhdGNoR2xvYmFsUHJvbWlzZSA9ICEhcmVzb2x2ZWRHbG9iYWxQcm9taXNlO1xudmFyIHN0YWNrX2JlaW5nX2dlbmVyYXRlZCA9IGZhbHNlO1xudmFyIHNjaGVkdWxlUGh5c2ljYWxUaWNrID0gcmVzb2x2ZWRHbG9iYWxQcm9taXNlID9cbiAgICAoKSA9PiB7IHJlc29sdmVkR2xvYmFsUHJvbWlzZS50aGVuKHBoeXNpY2FsVGljayk7IH1cbiAgICA6XG4gICAgICAgIF9nbG9iYWwuc2V0SW1tZWRpYXRlID9cbiAgICAgICAgICAgIHNldEltbWVkaWF0ZS5iaW5kKG51bGwsIHBoeXNpY2FsVGljaykgOlxuICAgICAgICAgICAgX2dsb2JhbC5NdXRhdGlvbk9ic2VydmVyID9cbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAobmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGh5c2ljYWxUaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5EaXYgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KSkub2JzZXJ2ZShoaWRkZW5EaXYsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2LnNldEF0dHJpYnV0ZSgnaScsICcxJyk7XG4gICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgKCkgPT4geyBzZXRUaW1lb3V0KHBoeXNpY2FsVGljaywgMCk7IH07XG52YXIgYXNhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgIG1pY3JvdGlja1F1ZXVlLnB1c2goW2NhbGxiYWNrLCBhcmdzXSk7XG4gICAgaWYgKG5lZWRzTmV3UGh5c2ljYWxUaWNrKSB7XG4gICAgICAgIHNjaGVkdWxlUGh5c2ljYWxUaWNrKCk7XG4gICAgICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gZmFsc2U7XG4gICAgfVxufTtcbnZhciBpc091dHNpZGVNaWNyb1RpY2sgPSB0cnVlLFxubmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlLFxudW5oYW5kbGVkRXJyb3JzID0gW10sXG5yZWplY3RpbmdFcnJvcnMgPSBbXSxcbmN1cnJlbnRGdWxmaWxsZXIgPSBudWxsLCByZWplY3Rpb25NYXBwZXIgPSBtaXJyb3I7XG52YXIgZ2xvYmFsUFNEID0ge1xuICAgIGlkOiAnZ2xvYmFsJyxcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgcmVmOiAwLFxuICAgIHVuaGFuZGxlZHM6IFtdLFxuICAgIG9udW5oYW5kbGVkOiBnbG9iYWxFcnJvcixcbiAgICBwZ3A6IGZhbHNlLFxuICAgIGVudjoge30sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmhhbmRsZWRzLmZvckVhY2godWggPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBnbG9iYWxFcnJvcih1aFswXSwgdWhbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xudmFyIFBTRCA9IGdsb2JhbFBTRDtcbnZhciBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xudmFyIG51bVNjaGVkdWxlZENhbGxzID0gMDtcbnZhciB0aWNrRmluYWxpemVycyA9IFtdO1xuZnVuY3Rpb24gRGV4aWVQcm9taXNlKGZuKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5vbnVuY2F0Y2hlZCA9IG5vcDtcbiAgICB0aGlzLl9saWIgPSBmYWxzZTtcbiAgICB2YXIgcHNkID0gKHRoaXMuX1BTRCA9IFBTRCk7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIHRoaXMuX3N0YWNrSG9sZGVyID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICAgICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuX251bVByZXYgPSAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChmbiAhPT0gSU5URVJOQUwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICBoYW5kbGVSZWplY3Rpb24odGhpcywgdGhpcy5fdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgKytwc2QucmVmO1xuICAgIGV4ZWN1dGVQcm9taXNlVGFzayh0aGlzLCBmbik7XG59XG5jb25zdCB0aGVuUHJvcCA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBzZCA9IFBTRCwgbWljcm9UYXNrSWQgPSB0b3RhbEVjaG9lcztcbiAgICAgICAgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgdmFyIHBvc3NpYmxlQXdhaXQgPSAhcHNkLmdsb2JhbCAmJiAocHNkICE9PSBQU0QgfHwgbWljcm9UYXNrSWQgIT09IHRvdGFsRWNob2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBwb3NzaWJsZUF3YWl0ICYmICFkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcih0aGlzLCBuZXcgTGlzdGVuZXIobmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvbkZ1bGZpbGxlZCwgcHNkLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSwgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlamVjdGVkLCBwc2QsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApLCByZXNvbHZlLCByZWplY3QsIHBzZCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWJ1ZyAmJiBsaW5rVG9QcmV2aW91c1Byb21pc2UocnYsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgICAgIHRoZW4ucHJvdG90eXBlID0gSU5URVJOQUw7XG4gICAgICAgIHJldHVybiB0aGVuO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc2V0UHJvcCh0aGlzLCAndGhlbicsIHZhbHVlICYmIHZhbHVlLnByb3RvdHlwZSA9PT0gSU5URVJOQUwgP1xuICAgICAgICAgICAgdGhlblByb3AgOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IHRoZW5Qcm9wLnNldFxuICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcbnByb3BzKERleGllUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICB0aGVuOiB0aGVuUHJvcCxcbiAgICBfdGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIodGhpcywgbmV3IExpc3RlbmVyKG51bGwsIG51bGwsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBQU0QpKTtcbiAgICB9LFxuICAgIGNhdGNoOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLCBoYW5kbGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0aGlzLnRoZW4obnVsbCwgZXJyID0+XG4gICAgICAgIGVyciBpbnN0YW5jZW9mIHR5cGUgPyBoYW5kbGVyKGVycikgOiBQcm9taXNlUmVqZWN0KGVycikpXG4gICAgICAgICAgICA6IHRoaXMudGhlbihudWxsLCBlcnIgPT5cbiAgICAgICAgICAgIGVyciAmJiBlcnIubmFtZSA9PT0gdHlwZSA/IGhhbmRsZXIoZXJyKSA6IFByb21pc2VSZWplY3QoZXJyKSk7XG4gICAgfSxcbiAgICBmaW5hbGx5OiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBvbkZpbmFsbHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlUmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgc3RhY2s6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGFja19iZWluZ19nZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBzdGFja3MgPSBnZXRTdGFjayh0aGlzLCBbXSwgTUFYX0xPTkdfU1RBQ0tTKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBzdGFja3Muam9pbihcIlxcbkZyb20gcHJldmlvdXM6IFwiKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRpbWVvdXQ6IGZ1bmN0aW9uIChtcywgbXNnKSB7XG4gICAgICAgIHJldHVybiBtcyA8IEluZmluaXR5ID9cbiAgICAgICAgICAgIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgZXhjZXB0aW9ucy5UaW1lb3V0KG1zZykpLCBtcyk7XG4gICAgICAgICAgICAgICAgdGhpcy50aGVuKHJlc29sdmUsIHJlamVjdCkuZmluYWxseShjbGVhclRpbWVvdXQuYmluZChudWxsLCBoYW5kbGUpKTtcbiAgICAgICAgICAgIH0pIDogdGhpcztcbiAgICB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpXG4gICAgc2V0UHJvcChEZXhpZVByb21pc2UucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsICdEZXhpZS5Qcm9taXNlJyk7XG5nbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcbmZ1bmN0aW9uIExpc3RlbmVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3QsIHpvbmUpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICAgIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB0aGlzLnBzZCA9IHpvbmU7XG59XG5wcm9wcyhEZXhpZVByb21pc2UsIHtcbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKGEsIGkpID0+IERleGllUHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldID0geDtcbiAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgICB9LCByZWplY3QpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICByZXNvbHZlOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgcnYgPSBuZXcgRGV4aWVQcm9taXNlKElOVEVSTkFMLCB0cnVlLCB2YWx1ZSk7XG4gICAgICAgIGxpbmtUb1ByZXZpb3VzUHJvbWlzZShydiwgY3VycmVudEZ1bGZpbGxlcik7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9LFxuICAgIHJlamVjdDogUHJvbWlzZVJlamVjdCxcbiAgICByYWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5tYXAodmFsdWUgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgUFNEOiB7XG4gICAgICAgIGdldDogKCkgPT4gUFNELFxuICAgICAgICBzZXQ6IHZhbHVlID0+IFBTRCA9IHZhbHVlXG4gICAgfSxcbiAgICB0b3RhbEVjaG9lczogeyBnZXQ6ICgpID0+IHRvdGFsRWNob2VzIH0sXG4gICAgbmV3UFNEOiBuZXdTY29wZSxcbiAgICB1c2VQU0Q6IHVzZVBTRCxcbiAgICBzY2hlZHVsZXI6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBhc2FwLFxuICAgICAgICBzZXQ6IHZhbHVlID0+IHsgYXNhcCA9IHZhbHVlOyB9XG4gICAgfSxcbiAgICByZWplY3Rpb25NYXBwZXI6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiByZWplY3Rpb25NYXBwZXIsXG4gICAgICAgIHNldDogdmFsdWUgPT4geyByZWplY3Rpb25NYXBwZXIgPSB2YWx1ZTsgfVxuICAgIH0sXG4gICAgZm9sbG93OiAoZm4sIHpvbmVQcm9wcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBwc2QgPSBQU0Q7XG4gICAgICAgICAgICAgICAgcHNkLnVuaGFuZGxlZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBwc2Qub251bmhhbmRsZWQgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgcHNkLmZpbmFsaXplID0gY2FsbEJvdGgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5oYW5kbGVkcy5sZW5ndGggPT09IDAgPyByZXNvbHZlKCkgOiByZWplY3QodGhpcy51bmhhbmRsZWRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgcHNkLmZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSwgem9uZVByb3BzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmlmIChOYXRpdmVQcm9taXNlKSB7XG4gICAgaWYgKE5hdGl2ZVByb21pc2UuYWxsU2V0dGxlZClcbiAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYWxsU2V0dGxlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlUHJvbWlzZXMuZm9yRWFjaCgocCwgaSkgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUocCkudGhlbih2YWx1ZSA9PiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwiZnVsZmlsbGVkXCIsIHZhbHVlIH0sIHJlYXNvbiA9PiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29uIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IC0tcmVtYWluaW5nIHx8IHJlc29sdmUocmVzdWx0cykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbnkgJiYgdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYW55XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlUHJvbWlzZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKFtdKSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKChwLCBpKSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKHZhbHVlID0+IHJlc29sdmUodmFsdWUpLCBmYWlsdXJlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXNbaV0gPSBmYWlsdXJlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihmYWlsdXJlcykpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVQcm9taXNlVGFzayhwcm9taXNlLCBmbikge1xuICAgIHRyeSB7XG4gICAgICAgIGZuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHByb21pc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fdGhlbihyZXNvbHZlLCByZWplY3QpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3N0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRFeGVjdXRlVGljaylcbiAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9LCBoYW5kbGVSZWplY3Rpb24uYmluZChudWxsLCBwcm9taXNlKSk7XG4gICAgfVxuICAgIGNhdGNoIChleCkge1xuICAgICAgICBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVJlamVjdGlvbihwcm9taXNlLCByZWFzb24pIHtcbiAgICByZWplY3RpbmdFcnJvcnMucHVzaChyZWFzb24pO1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgcmVhc29uID0gcmVqZWN0aW9uTWFwcGVyKHJlYXNvbik7XG4gICAgcHJvbWlzZS5fc3RhdGUgPSBmYWxzZTtcbiAgICBwcm9taXNlLl92YWx1ZSA9IHJlYXNvbjtcbiAgICBkZWJ1ZyAmJiByZWFzb24gIT09IG51bGwgJiYgdHlwZW9mIHJlYXNvbiA9PT0gJ29iamVjdCcgJiYgIXJlYXNvbi5fcHJvbWlzZSAmJiB0cnlDYXRjaCgoKSA9PiB7XG4gICAgICAgIHZhciBvcmlnUHJvcCA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihyZWFzb24sIFwic3RhY2tcIik7XG4gICAgICAgIHJlYXNvbi5fcHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHNldFByb3AocmVhc29uLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIGdldDogKCkgPT4gc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID9cbiAgICAgICAgICAgICAgICBvcmlnUHJvcCAmJiAob3JpZ1Byb3AuZ2V0ID9cbiAgICAgICAgICAgICAgICAgICAgb3JpZ1Byb3AuZ2V0LmFwcGx5KHJlYXNvbikgOlxuICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcC52YWx1ZSkgOlxuICAgICAgICAgICAgICAgIHByb21pc2Uuc3RhY2tcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKTtcbiAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG4gICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xufVxuZnVuY3Rpb24gcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gcHJvbWlzZS5fbGlzdGVuZXJzO1xuICAgIHByb21pc2UuX2xpc3RlbmVycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcnNbaV0pO1xuICAgIH1cbiAgICB2YXIgcHNkID0gcHJvbWlzZS5fUFNEO1xuICAgIC0tcHNkLnJlZiB8fCBwc2QuZmluYWxpemUoKTtcbiAgICBpZiAobnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIHtcbiAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgICAgYXNhcCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBwcm9taXNlLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNiID0gcHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5vbkZ1bGZpbGxlZCA6IGxpc3RlbmVyLm9uUmVqZWN0ZWQ7XG4gICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAocHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5yZXNvbHZlIDogbGlzdGVuZXIucmVqZWN0KShwcm9taXNlLl92YWx1ZSk7XG4gICAgfVxuICAgICsrbGlzdGVuZXIucHNkLnJlZjtcbiAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgIGFzYXAoY2FsbExpc3RlbmVyLCBbY2IsIHByb21pc2UsIGxpc3RlbmVyXSk7XG59XG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIoY2IsIHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY3VycmVudEZ1bGZpbGxlciA9IHByb21pc2U7XG4gICAgICAgIHZhciByZXQsIHZhbHVlID0gcHJvbWlzZS5fdmFsdWU7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSkge1xuICAgICAgICAgICAgcmV0ID0gY2IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlamVjdGluZ0Vycm9ycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVqZWN0aW5nRXJyb3JzID0gW107XG4gICAgICAgICAgICByZXQgPSBjYih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVqZWN0aW5nRXJyb3JzLmluZGV4T2YodmFsdWUpID09PSAtMSlcbiAgICAgICAgICAgICAgICBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIucmVzb2x2ZShyZXQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsaXN0ZW5lci5yZWplY3QoZSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50RnVsZmlsbGVyID0gbnVsbDtcbiAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG4gICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgICAgICAtLWxpc3RlbmVyLnBzZC5yZWYgfHwgbGlzdGVuZXIucHNkLmZpbmFsaXplKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U3RhY2socHJvbWlzZSwgc3RhY2tzLCBsaW1pdCkge1xuICAgIGlmIChzdGFja3MubGVuZ3RoID09PSBsaW1pdClcbiAgICAgICAgcmV0dXJuIHN0YWNrcztcbiAgICB2YXIgc3RhY2sgPSBcIlwiO1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGZhaWx1cmUgPSBwcm9taXNlLl92YWx1ZSwgZXJyb3JOYW1lLCBtZXNzYWdlO1xuICAgICAgICBpZiAoZmFpbHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBlcnJvck5hbWUgPSBmYWlsdXJlLm5hbWUgfHwgXCJFcnJvclwiO1xuICAgICAgICAgICAgbWVzc2FnZSA9IGZhaWx1cmUubWVzc2FnZSB8fCBmYWlsdXJlO1xuICAgICAgICAgICAgc3RhY2sgPSBwcmV0dHlTdGFjayhmYWlsdXJlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yTmFtZSA9IGZhaWx1cmU7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBzdGFja3MucHVzaChlcnJvck5hbWUgKyAobWVzc2FnZSA/IFwiOiBcIiArIG1lc3NhZ2UgOiBcIlwiKSArIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIHN0YWNrID0gcHJldHR5U3RhY2socHJvbWlzZS5fc3RhY2tIb2xkZXIsIDIpO1xuICAgICAgICBpZiAoc3RhY2sgJiYgc3RhY2tzLmluZGV4T2Yoc3RhY2spID09PSAtMSlcbiAgICAgICAgICAgIHN0YWNrcy5wdXNoKHN0YWNrKTtcbiAgICAgICAgaWYgKHByb21pc2UuX3ByZXYpXG4gICAgICAgICAgICBnZXRTdGFjayhwcm9taXNlLl9wcmV2LCBzdGFja3MsIGxpbWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrcztcbn1cbmZ1bmN0aW9uIGxpbmtUb1ByZXZpb3VzUHJvbWlzZShwcm9taXNlLCBwcmV2KSB7XG4gICAgdmFyIG51bVByZXYgPSBwcmV2ID8gcHJldi5fbnVtUHJldiArIDEgOiAwO1xuICAgIGlmIChudW1QcmV2IDwgTE9OR19TVEFDS1NfQ0xJUF9MSU1JVCkge1xuICAgICAgICBwcm9taXNlLl9wcmV2ID0gcHJldjtcbiAgICAgICAgcHJvbWlzZS5fbnVtUHJldiA9IG51bVByZXY7XG4gICAgfVxufVxuZnVuY3Rpb24gcGh5c2ljYWxUaWNrKCkge1xuICAgIGJlZ2luTWljcm9UaWNrU2NvcGUoKSAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xufVxuZnVuY3Rpb24gYmVnaW5NaWNyb1RpY2tTY29wZSgpIHtcbiAgICB2YXIgd2FzUm9vdEV4ZWMgPSBpc091dHNpZGVNaWNyb1RpY2s7XG4gICAgaXNPdXRzaWRlTWljcm9UaWNrID0gZmFsc2U7XG4gICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICByZXR1cm4gd2FzUm9vdEV4ZWM7XG59XG5mdW5jdGlvbiBlbmRNaWNyb1RpY2tTY29wZSgpIHtcbiAgICB2YXIgY2FsbGJhY2tzLCBpLCBsO1xuICAgIGRvIHtcbiAgICAgICAgd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IG1pY3JvdGlja1F1ZXVlO1xuICAgICAgICAgICAgbWljcm90aWNrUXVldWUgPSBbXTtcbiAgICAgICAgICAgIGwgPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGl0ZW1bMF0uYXBwbHkobnVsbCwgaXRlbVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKTtcbiAgICBpc091dHNpZGVNaWNyb1RpY2sgPSB0cnVlO1xuICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplUGh5c2ljYWxUaWNrKCkge1xuICAgIHZhciB1bmhhbmRsZWRFcnJzID0gdW5oYW5kbGVkRXJyb3JzO1xuICAgIHVuaGFuZGxlZEVycm9ycyA9IFtdO1xuICAgIHVuaGFuZGxlZEVycnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgcC5fUFNELm9udW5oYW5kbGVkLmNhbGwobnVsbCwgcC5fdmFsdWUsIHApO1xuICAgIH0pO1xuICAgIHZhciBmaW5hbGl6ZXJzID0gdGlja0ZpbmFsaXplcnMuc2xpY2UoMCk7XG4gICAgdmFyIGkgPSBmaW5hbGl6ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSlcbiAgICAgICAgZmluYWxpemVyc1stLWldKCk7XG59XG5mdW5jdGlvbiBydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrKGZuKSB7XG4gICAgZnVuY3Rpb24gZmluYWxpemVyKCkge1xuICAgICAgICBmbigpO1xuICAgICAgICB0aWNrRmluYWxpemVycy5zcGxpY2UodGlja0ZpbmFsaXplcnMuaW5kZXhPZihmaW5hbGl6ZXIpLCAxKTtcbiAgICB9XG4gICAgdGlja0ZpbmFsaXplcnMucHVzaChmaW5hbGl6ZXIpO1xuICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG4gICAgYXNhcCgoKSA9PiB7XG4gICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICB9LCBbXSk7XG59XG5mdW5jdGlvbiBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpIHtcbiAgICBpZiAoIXVuaGFuZGxlZEVycm9ycy5zb21lKHAgPT4gcC5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlKSlcbiAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnB1c2gocHJvbWlzZSk7XG59XG5mdW5jdGlvbiBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSkge1xuICAgIHZhciBpID0gdW5oYW5kbGVkRXJyb3JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSlcbiAgICAgICAgaWYgKHVuaGFuZGxlZEVycm9yc1stLWldLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWUpIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZEVycm9ycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbn1cbmZ1bmN0aW9uIFByb21pc2VSZWplY3QocmVhc29uKSB7XG4gICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIGZhbHNlLCByZWFzb24pO1xufVxuZnVuY3Rpb24gd3JhcChmbiwgZXJyb3JDYXRjaGVyKSB7XG4gICAgdmFyIHBzZCA9IFBTRDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCksIG91dGVyU2NvcGUgPSBQU0Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckNhdGNoZXIgJiYgZXJyb3JDYXRjaGVyKGUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh3YXNSb290RXhlYylcbiAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IHRhc2sgPSB7IGF3YWl0czogMCwgZWNob2VzOiAwLCBpZDogMCB9O1xudmFyIHRhc2tDb3VudGVyID0gMDtcbnZhciB6b25lU3RhY2sgPSBbXTtcbnZhciB6b25lRWNob2VzID0gMDtcbnZhciB0b3RhbEVjaG9lcyA9IDA7XG52YXIgem9uZV9pZF9jb3VudGVyID0gMDtcbmZ1bmN0aW9uIG5ld1Njb3BlKGZuLCBwcm9wcywgYTEsIGEyKSB7XG4gICAgdmFyIHBhcmVudCA9IFBTRCwgcHNkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIHBzZC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcHNkLnJlZiA9IDA7XG4gICAgcHNkLmdsb2JhbCA9IGZhbHNlO1xuICAgIHBzZC5pZCA9ICsrem9uZV9pZF9jb3VudGVyO1xuICAgIHZhciBnbG9iYWxFbnYgPSBnbG9iYWxQU0QuZW52O1xuICAgIHBzZC5lbnYgPSBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgIFByb21pc2U6IERleGllUHJvbWlzZSxcbiAgICAgICAgUHJvbWlzZVByb3A6IHsgdmFsdWU6IERleGllUHJvbWlzZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgICAgICBhbGw6IERleGllUHJvbWlzZS5hbGwsXG4gICAgICAgIHJhY2U6IERleGllUHJvbWlzZS5yYWNlLFxuICAgICAgICBhbGxTZXR0bGVkOiBEZXhpZVByb21pc2UuYWxsU2V0dGxlZCxcbiAgICAgICAgYW55OiBEZXhpZVByb21pc2UuYW55LFxuICAgICAgICByZXNvbHZlOiBEZXhpZVByb21pc2UucmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBEZXhpZVByb21pc2UucmVqZWN0LFxuICAgICAgICBudGhlbjogZ2V0UGF0Y2hlZFByb21pc2VUaGVuKGdsb2JhbEVudi5udGhlbiwgcHNkKSxcbiAgICAgICAgZ3RoZW46IGdldFBhdGNoZWRQcm9taXNlVGhlbihnbG9iYWxFbnYuZ3RoZW4sIHBzZClcbiAgICB9IDoge307XG4gICAgaWYgKHByb3BzKVxuICAgICAgICBleHRlbmQocHNkLCBwcm9wcyk7XG4gICAgKytwYXJlbnQucmVmO1xuICAgIHBzZC5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLS10aGlzLnBhcmVudC5yZWYgfHwgdGhpcy5wYXJlbnQuZmluYWxpemUoKTtcbiAgICB9O1xuICAgIHZhciBydiA9IHVzZVBTRChwc2QsIGZuLCBhMSwgYTIpO1xuICAgIGlmIChwc2QucmVmID09PSAwKVxuICAgICAgICBwc2QuZmluYWxpemUoKTtcbiAgICByZXR1cm4gcnY7XG59XG5mdW5jdGlvbiBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcbiAgICBpZiAoIXRhc2suaWQpXG4gICAgICAgIHRhc2suaWQgPSArK3Rhc2tDb3VudGVyO1xuICAgICsrdGFzay5hd2FpdHM7XG4gICAgdGFzay5lY2hvZXMgKz0gWk9ORV9FQ0hPX0xJTUlUO1xuICAgIHJldHVybiB0YXNrLmlkO1xufVxuZnVuY3Rpb24gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgaWYgKCF0YXNrLmF3YWl0cylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgtLXRhc2suYXdhaXRzID09PSAwKVxuICAgICAgICB0YXNrLmlkID0gMDtcbiAgICB0YXNrLmVjaG9lcyA9IHRhc2suYXdhaXRzICogWk9ORV9FQ0hPX0xJTUlUO1xuICAgIHJldHVybiB0cnVlO1xufVxuaWYgKCgnJyArIG5hdGl2ZVByb21pc2VUaGVuKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgPT09IC0xKSB7XG4gICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyA9IG5vcDtcbn1cbmZ1bmN0aW9uIG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyhwb3NzaWJsZVByb21pc2UpIHtcbiAgICBpZiAodGFzay5lY2hvZXMgJiYgcG9zc2libGVQcm9taXNlICYmIHBvc3NpYmxlUHJvbWlzZS5jb25zdHJ1Y3RvciA9PT0gTmF0aXZlUHJvbWlzZSkge1xuICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICByZXR1cm4gcG9zc2libGVQcm9taXNlLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0sIGUgPT4ge1xuICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9zc2libGVQcm9taXNlO1xufVxuZnVuY3Rpb24gem9uZUVudGVyRWNobyh0YXJnZXRab25lKSB7XG4gICAgKyt0b3RhbEVjaG9lcztcbiAgICBpZiAoIXRhc2suZWNob2VzIHx8IC0tdGFzay5lY2hvZXMgPT09IDApIHtcbiAgICAgICAgdGFzay5lY2hvZXMgPSB0YXNrLmlkID0gMDtcbiAgICB9XG4gICAgem9uZVN0YWNrLnB1c2goUFNEKTtcbiAgICBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiB6b25lTGVhdmVFY2hvKCkge1xuICAgIHZhciB6b25lID0gem9uZVN0YWNrW3pvbmVTdGFjay5sZW5ndGggLSAxXTtcbiAgICB6b25lU3RhY2sucG9wKCk7XG4gICAgc3dpdGNoVG9ab25lKHpvbmUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHN3aXRjaFRvWm9uZSh0YXJnZXRab25lLCBiRW50ZXJpbmdab25lKSB7XG4gICAgdmFyIGN1cnJlbnRab25lID0gUFNEO1xuICAgIGlmIChiRW50ZXJpbmdab25lID8gdGFzay5lY2hvZXMgJiYgKCF6b25lRWNob2VzKysgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSA6IHpvbmVFY2hvZXMgJiYgKCEtLXpvbmVFY2hvZXMgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSkge1xuICAgICAgICBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGJFbnRlcmluZ1pvbmUgPyB6b25lRW50ZXJFY2hvLmJpbmQobnVsbCwgdGFyZ2V0Wm9uZSkgOiB6b25lTGVhdmVFY2hvKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldFpvbmUgPT09IFBTRClcbiAgICAgICAgcmV0dXJuO1xuICAgIFBTRCA9IHRhcmdldFpvbmU7XG4gICAgaWYgKGN1cnJlbnRab25lID09PSBnbG9iYWxQU0QpXG4gICAgICAgIGdsb2JhbFBTRC5lbnYgPSBzbmFwU2hvdCgpO1xuICAgIGlmIChwYXRjaEdsb2JhbFByb21pc2UpIHtcbiAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBnbG9iYWxQU0QuZW52LlByb21pc2U7XG4gICAgICAgIHZhciB0YXJnZXRFbnYgPSB0YXJnZXRab25lLmVudjtcbiAgICAgICAgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW4gPSB0YXJnZXRFbnYubnRoZW47XG4gICAgICAgIEdsb2JhbFByb21pc2UucHJvdG90eXBlLnRoZW4gPSB0YXJnZXRFbnYuZ3RoZW47XG4gICAgICAgIGlmIChjdXJyZW50Wm9uZS5nbG9iYWwgfHwgdGFyZ2V0Wm9uZS5nbG9iYWwpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZ2xvYmFsLCAnUHJvbWlzZScsIHRhcmdldEVudi5Qcm9taXNlUHJvcCk7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFsbCA9IHRhcmdldEVudi5hbGw7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJhY2UgPSB0YXJnZXRFbnYucmFjZTtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmVzb2x2ZSA9IHRhcmdldEVudi5yZXNvbHZlO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZWplY3QgPSB0YXJnZXRFbnYucmVqZWN0O1xuICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbGxTZXR0bGVkKVxuICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCA9IHRhcmdldEVudi5hbGxTZXR0bGVkO1xuICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbnkpXG4gICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbnkgPSB0YXJnZXRFbnYuYW55O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc25hcFNob3QoKSB7XG4gICAgdmFyIEdsb2JhbFByb21pc2UgPSBfZ2xvYmFsLlByb21pc2U7XG4gICAgcmV0dXJuIHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgUHJvbWlzZTogR2xvYmFsUHJvbWlzZSxcbiAgICAgICAgUHJvbWlzZVByb3A6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2dsb2JhbCwgXCJQcm9taXNlXCIpLFxuICAgICAgICBhbGw6IEdsb2JhbFByb21pc2UuYWxsLFxuICAgICAgICByYWNlOiBHbG9iYWxQcm9taXNlLnJhY2UsXG4gICAgICAgIGFsbFNldHRsZWQ6IEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCxcbiAgICAgICAgYW55OiBHbG9iYWxQcm9taXNlLmFueSxcbiAgICAgICAgcmVzb2x2ZTogR2xvYmFsUHJvbWlzZS5yZXNvbHZlLFxuICAgICAgICByZWplY3Q6IEdsb2JhbFByb21pc2UucmVqZWN0LFxuICAgICAgICBudGhlbjogbmF0aXZlUHJvbWlzZVByb3RvLnRoZW4sXG4gICAgICAgIGd0aGVuOiBHbG9iYWxQcm9taXNlLnByb3RvdHlwZS50aGVuXG4gICAgfSA6IHt9O1xufVxuZnVuY3Rpb24gdXNlUFNEKHBzZCwgZm4sIGExLCBhMiwgYTMpIHtcbiAgICB2YXIgb3V0ZXJTY29wZSA9IFBTRDtcbiAgICB0cnkge1xuICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGZuKGExLCBhMiwgYTMpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGpvYikge1xuICAgIG5hdGl2ZVByb21pc2VUaGVuLmNhbGwocmVzb2x2ZWROYXRpdmVQcm9taXNlLCBqb2IpO1xufVxuZnVuY3Rpb24gbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChmbiwgem9uZSwgcG9zc2libGVBd2FpdCwgY2xlYW51cCkge1xuICAgIHJldHVybiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dGVyWm9uZSA9IFBTRDtcbiAgICAgICAgaWYgKHBvc3NpYmxlQXdhaXQpXG4gICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgdHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclpvbmUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjbGVhbnVwKVxuICAgICAgICAgICAgICAgIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhdGNoZWRQcm9taXNlVGhlbihvcmlnVGhlbiwgem9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob25SZXNvbHZlZCwgb25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gb3JpZ1RoZW4uY2FsbCh0aGlzLCBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVzb2x2ZWQsIHpvbmUpLCBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVqZWN0ZWQsIHpvbmUpKTtcbiAgICB9O1xufVxuY29uc3QgVU5IQU5ETEVEUkVKRUNUSU9OID0gXCJ1bmhhbmRsZWRyZWplY3Rpb25cIjtcbmZ1bmN0aW9uIGdsb2JhbEVycm9yKGVyciwgcHJvbWlzZSkge1xuICAgIHZhciBydjtcbiAgICB0cnkge1xuICAgICAgICBydiA9IHByb21pc2Uub251bmNhdGNoZWQoZXJyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIGlmIChydiAhPT0gZmFsc2UpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQsIGV2ZW50RGF0YSA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBlcnIgfTtcbiAgICAgICAgICAgIGlmIChfZ2xvYmFsLmRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICAgICAgICBldmVudC5pbml0RXZlbnQoVU5IQU5ETEVEUkVKRUNUSU9OLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBleHRlbmQoZXZlbnQsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfZ2xvYmFsLkN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoVU5IQU5ETEVEUkVKRUNUSU9OLCB7IGRldGFpbDogZXZlbnREYXRhIH0pO1xuICAgICAgICAgICAgICAgIGV4dGVuZChldmVudCwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudCAmJiBfZ2xvYmFsLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIV9nbG9iYWwuUHJvbWlzZVJlamVjdGlvbkV2ZW50ICYmIF9nbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVidWcgJiYgZXZlbnQgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuaGFuZGxlZCByZWplY3Rpb246ICR7ZXJyLnN0YWNrIHx8IGVycn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG59XG52YXIgcmVqZWN0aW9uID0gRGV4aWVQcm9taXNlLnJlamVjdDtcblxuZnVuY3Rpb24gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikge1xuICAgIGlmICghZGIuaWRiZGIgfHwgKCFkYi5fc3RhdGUub3BlbkNvbXBsZXRlICYmICghUFNELmxldFRocm91Z2ggJiYgIWRiLl92aXApKSkge1xuICAgICAgICBpZiAoZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChkYi5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRiLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICBpZiAoIWRiLl9vcHRpb25zLmF1dG9PcGVuKVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG4gICAgICAgICAgICBkYi5vcGVuKCkuY2F0Y2gobm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGIuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oKCkgPT4gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgICAgICAgIGRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gZXJybmFtZXMuSW52YWxpZFN0YXRlICYmIGRiLmlzT3BlbigpICYmIC0tZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IE5lZWQgdG8gcmVvcGVuIGRiJyk7XG4gICAgICAgICAgICAgICAgZGIuX2Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRiLm9wZW4oKS50aGVuKCgpID0+IHRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIFBTRC50cmFucyA9IHRyYW5zO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnMuX2NvbXBsZXRpb24udGhlbigoKSA9PiByZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IERFWElFX1ZFUlNJT04gPSAnMy4yLjcnO1xuY29uc3QgbWF4U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzNSk7XG5jb25zdCBtaW5LZXkgPSAtSW5maW5pdHk7XG5jb25zdCBJTlZBTElEX0tFWV9BUkdVTUVOVCA9IFwiSW52YWxpZCBrZXkgcHJvdmlkZWQuIEtleXMgbXVzdCBiZSBvZiB0eXBlIHN0cmluZywgbnVtYmVyLCBEYXRlIG9yIEFycmF5PHN0cmluZyB8IG51bWJlciB8IERhdGU+LlwiO1xuY29uc3QgU1RSSU5HX0VYUEVDVEVEID0gXCJTdHJpbmcgZXhwZWN0ZWQuXCI7XG5jb25zdCBjb25uZWN0aW9ucyA9IFtdO1xuY29uc3QgaXNJRU9yRWRnZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC8oTVNJRXxUcmlkZW50fEVkZ2UpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1ZyA9IGlzSUVPckVkZ2U7XG5jb25zdCBoYW5nc09uRGVsZXRlTGFyZ2VLZXlSYW5nZSA9IGlzSUVPckVkZ2U7XG5jb25zdCBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIgPSBmcmFtZSA9PiAhLyhkZXhpZVxcLmpzfGRleGllXFwubWluXFwuanMpLy50ZXN0KGZyYW1lKTtcbmNvbnN0IERCTkFNRVNfREIgPSAnX19kYm5hbWVzJztcbmNvbnN0IFJFQURPTkxZID0gJ3JlYWRvbmx5JztcbmNvbnN0IFJFQURXUklURSA9ICdyZWFkd3JpdGUnO1xuXG5mdW5jdGlvbiBjb21iaW5lKGZpbHRlcjEsIGZpbHRlcjIpIHtcbiAgICByZXR1cm4gZmlsdGVyMSA/XG4gICAgICAgIGZpbHRlcjIgP1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsdGVyMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICYmIGZpbHRlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSA6XG4gICAgICAgICAgICBmaWx0ZXIxIDpcbiAgICAgICAgZmlsdGVyMjtcbn1cblxuY29uc3QgQW55UmFuZ2UgPSB7XG4gICAgdHlwZTogMyAsXG4gICAgbG93ZXI6IC1JbmZpbml0eSxcbiAgICBsb3dlck9wZW46IGZhbHNlLFxuICAgIHVwcGVyOiBbW11dLFxuICAgIHVwcGVyT3BlbjogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09IFwic3RyaW5nXCIgJiYgIS9cXC4vLnRlc3Qoa2V5UGF0aClcbiAgICAgICAgPyAob2JqKSA9PiB7XG4gICAgICAgICAgICBpZiAob2JqW2tleVBhdGhdID09PSB1bmRlZmluZWQgJiYgKGtleVBhdGggaW4gb2JqKSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIDogKG9iaikgPT4gb2JqO1xufVxuXG5jbGFzcyBUYWJsZSB7XG4gICAgX3RyYW5zKG1vZGUsIGZuLCB3cml0ZUxvY2tlZCkge1xuICAgICAgICBjb25zdCB0cmFucyA9IHRoaXMuX3R4IHx8IFBTRC50cmFucztcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBmdW5jdGlvbiBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKSB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zLnNjaGVtYVt0YWJsZU5hbWVdKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGUgXCIgKyB0YWJsZU5hbWUgKyBcIiBub3QgcGFydCBvZiB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybiBmbih0cmFucy5pZGJ0cmFucywgdHJhbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zICYmIHRyYW5zLmRiID09PSB0aGlzLmRiID9cbiAgICAgICAgICAgICAgICB0cmFucyA9PT0gUFNELnRyYW5zID9cbiAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlKCgpID0+IHRyYW5zLl9wcm9taXNlKG1vZGUsIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uLCB3cml0ZUxvY2tlZCksIHsgdHJhbnM6IHRyYW5zLCB0cmFuc2xlc3M6IFBTRC50cmFuc2xlc3MgfHwgUFNEIH0pIDpcbiAgICAgICAgICAgICAgICB0ZW1wVHJhbnNhY3Rpb24odGhpcy5kYiwgbW9kZSwgW3RoaXMubmFtZV0sIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh3YXNSb290RXhlYylcbiAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChrZXlPckNyaXQsIGNiKSB7XG4gICAgICAgIGlmIChrZXlPckNyaXQgJiYga2V5T3JDcml0LmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShrZXlPckNyaXQpLmZpcnN0KGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkb25seScsICh0cmFucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5nZXQoeyB0cmFucywga2V5OiBrZXlPckNyaXQgfSlcbiAgICAgICAgICAgICAgICAudGhlbihyZXMgPT4gdGhpcy5ob29rLnJlYWRpbmcuZmlyZShyZXMpKTtcbiAgICAgICAgfSkudGhlbihjYik7XG4gICAgfVxuICAgIHdoZXJlKGluZGV4T3JDcml0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXhPckNyaXQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGluZGV4T3JDcml0KTtcbiAgICAgICAgaWYgKGlzQXJyYXkoaW5kZXhPckNyaXQpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGBbJHtpbmRleE9yQ3JpdC5qb2luKCcrJyl9XWApO1xuICAgICAgICBjb25zdCBrZXlQYXRocyA9IGtleXMoaW5kZXhPckNyaXQpO1xuICAgICAgICBpZiAoa2V5UGF0aHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAud2hlcmUoa2V5UGF0aHNbMF0pXG4gICAgICAgICAgICAgICAgLmVxdWFscyhpbmRleE9yQ3JpdFtrZXlQYXRoc1swXV0pO1xuICAgICAgICBjb25zdCBjb21wb3VuZEluZGV4ID0gdGhpcy5zY2hlbWEuaW5kZXhlcy5jb25jYXQodGhpcy5zY2hlbWEucHJpbUtleSkuZmlsdGVyKGl4ID0+IHtcbiAgICAgICAgICAgIGlmIChpeC5jb21wb3VuZCAmJlxuICAgICAgICAgICAgICAgIGtleVBhdGhzLmV2ZXJ5KGtleVBhdGggPT4gaXgua2V5UGF0aC5pbmRleE9mKGtleVBhdGgpID49IDApKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlQYXRocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aHMuaW5kZXhPZihpeC5rZXlQYXRoW2ldKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KS5zb3J0KChhLCBiKSA9PiBhLmtleVBhdGgubGVuZ3RoIC0gYi5rZXlQYXRoLmxlbmd0aClbMF07XG4gICAgICAgIGlmIChjb21wb3VuZEluZGV4ICYmIHRoaXMuZGIuX21heEtleSAhPT0gbWF4U3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlQYXRoc0luVmFsaWRPcmRlciA9IGNvbXBvdW5kSW5kZXgua2V5UGF0aC5zbGljZSgwLCBrZXlQYXRocy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAud2hlcmUoa2V5UGF0aHNJblZhbGlkT3JkZXIpXG4gICAgICAgICAgICAgICAgLmVxdWFscyhrZXlQYXRoc0luVmFsaWRPcmRlci5tYXAoa3AgPT4gaW5kZXhPckNyaXRba3BdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wb3VuZEluZGV4ICYmIGRlYnVnKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGUgcXVlcnkgJHtKU09OLnN0cmluZ2lmeShpbmRleE9yQ3JpdCl9IG9uICR7dGhpcy5uYW1lfSB3b3VsZCBiZW5lZml0IG9mIGEgYCArXG4gICAgICAgICAgICAgICAgYGNvbXBvdW5kIGluZGV4IFske2tleVBhdGhzLmpvaW4oJysnKX1dYCk7XG4gICAgICAgIGNvbnN0IHsgaWR4QnlOYW1lIH0gPSB0aGlzLnNjaGVtYTtcbiAgICAgICAgY29uc3QgaWRiID0gdGhpcy5kYi5fZGVwcy5pbmRleGVkREI7XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZGIuY21wKGEsIGIpID09PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2lkeCwgZmlsdGVyRnVuY3Rpb25dID0ga2V5UGF0aHMucmVkdWNlKChbcHJldkluZGV4LCBwcmV2RmlsdGVyRm5dLCBrZXlQYXRoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGlkeEJ5TmFtZVtrZXlQYXRoXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW5kZXhPckNyaXRba2V5UGF0aF07XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHByZXZJbmRleCB8fCBpbmRleCxcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXggfHwgIWluZGV4ID9cbiAgICAgICAgICAgICAgICAgICAgY29tYmluZShwcmV2RmlsdGVyRm4sIGluZGV4ICYmIGluZGV4Lm11bHRpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBnZXRCeUtleVBhdGgoeCwga2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkocHJvcCkgJiYgcHJvcC5zb21lKGl0ZW0gPT4gZXF1YWxzKHZhbHVlLCBpdGVtKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogeCA9PiBlcXVhbHModmFsdWUsIGdldEJ5S2V5UGF0aCh4LCBrZXlQYXRoKSkpXG4gICAgICAgICAgICAgICAgICAgIDogcHJldkZpbHRlckZuXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LCBbbnVsbCwgbnVsbF0pO1xuICAgICAgICByZXR1cm4gaWR4ID9cbiAgICAgICAgICAgIHRoaXMud2hlcmUoaWR4Lm5hbWUpLmVxdWFscyhpbmRleE9yQ3JpdFtpZHgua2V5UGF0aF0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOlxuICAgICAgICAgICAgY29tcG91bmRJbmRleCA/XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pIDpcbiAgICAgICAgICAgICAgICB0aGlzLndoZXJlKGtleVBhdGhzKS5lcXVhbHMoJycpO1xuICAgIH1cbiAgICBmaWx0ZXIoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuYW5kKGZpbHRlckZ1bmN0aW9uKTtcbiAgICB9XG4gICAgY291bnQodGhlblNob3J0Y3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmNvdW50KHRoZW5TaG9ydGN1dCk7XG4gICAgfVxuICAgIG9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkub2Zmc2V0KG9mZnNldCk7XG4gICAgfVxuICAgIGxpbWl0KG51bVJvd3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkubGltaXQobnVtUm93cyk7XG4gICAgfVxuICAgIGVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuZWFjaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHRvQXJyYXkodGhlblNob3J0Y3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnRvQXJyYXkodGhlblNob3J0Y3V0KTtcbiAgICB9XG4gICAgdG9Db2xsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzKSk7XG4gICAgfVxuICAgIG9yZGVyQnkoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLkNvbGxlY3Rpb24obmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgaXNBcnJheShpbmRleCkgP1xuICAgICAgICAgICAgYFske2luZGV4LmpvaW4oJysnKX1dYCA6XG4gICAgICAgICAgICBpbmRleCkpO1xuICAgIH1cbiAgICByZXZlcnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIG1hcFRvQ2xhc3MoY29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEubWFwcGVkQ2xhc3MgPSBjb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgcmVhZEhvb2sgPSBvYmogPT4ge1xuICAgICAgICAgICAgaWYgKCFvYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IE9iamVjdC5jcmVhdGUoY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gaW4gb2JqKVxuICAgICAgICAgICAgICAgIGlmIChoYXNPd24ob2JqLCBtKSlcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1ttXSA9IG9ialttXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zY2hlbWEucmVhZEhvb2spIHtcbiAgICAgICAgICAgIHRoaXMuaG9vay5yZWFkaW5nLnVuc3Vic2NyaWJlKHRoaXMuc2NoZW1hLnJlYWRIb29rKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVtYS5yZWFkSG9vayA9IHJlYWRIb29rO1xuICAgICAgICB0aGlzLmhvb2soXCJyZWFkaW5nXCIsIHJlYWRIb29rKTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBkZWZpbmVDbGFzcygpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2xhc3MoY29udGVudCkge1xuICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hcFRvQ2xhc3MoQ2xhc3MpO1xuICAgIH1cbiAgICBhZGQob2JqLCBrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhdXRvLCBrZXlQYXRoIH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgICAgICBsZXQgb2JqVG9BZGQgPSBvYmo7XG4gICAgICAgIGlmIChrZXlQYXRoICYmIGF1dG8pIHtcbiAgICAgICAgICAgIG9ialRvQWRkID0gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkob2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXkgIT0gbnVsbCA/IFtrZXldIDogbnVsbCwgdmFsdWVzOiBbb2JqVG9BZGRdIH0pO1xuICAgICAgICB9KS50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdClcbiAgICAgICAgICAgIC50aGVuKGxhc3RSZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBsYXN0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUoa2V5T3JPYmplY3QsIG1vZGlmaWNhdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXlPck9iamVjdCA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkoa2V5T3JPYmplY3QpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRCeUtleVBhdGgoa2V5T3JPYmplY3QsIHRoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aCk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJHaXZlbiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBpdHMgcHJpbWFyeSBrZXlcIikpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWNhdGlvbnMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBrZXlzKG1vZGlmaWNhdGlvbnMpLmZvckVhY2goa2V5UGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoa2V5T3JPYmplY3QsIGtleVBhdGgsIG1vZGlmaWNhdGlvbnNba2V5UGF0aF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWNhdGlvbnMoa2V5T3JPYmplY3QsIHsgdmFsdWU6IGtleU9yT2JqZWN0LCBwcmltS2V5OiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5T3JPYmplY3QpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXQob2JqLCBrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhdXRvLCBrZXlQYXRoIH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgICAgICBsZXQgb2JqVG9BZGQgPSBvYmo7XG4gICAgICAgIGlmIChrZXlQYXRoICYmIGF1dG8pIHtcbiAgICAgICAgICAgIG9ialRvQWRkID0gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkob2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ3B1dCcsIHZhbHVlczogW29ialRvQWRkXSwga2V5czoga2V5ICE9IG51bGwgPyBba2V5XSA6IG51bGwgfSkpXG4gICAgICAgICAgICAudGhlbihyZXMgPT4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogcmVzLmxhc3RSZXN1bHQpXG4gICAgICAgICAgICAudGhlbihsYXN0UmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IFtrZXldIH0pKVxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IEFueVJhbmdlIH0pKVxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGJ1bGtHZXQoa2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWRvbmx5JywgdHJhbnMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5nZXRNYW55KHtcbiAgICAgICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgICAgIHRyYW5zXG4gICAgICAgICAgICB9KS50aGVuKHJlc3VsdCA9PiByZXN1bHQubWFwKHJlcyA9PiB0aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcykpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1bGtBZGQob2JqZWN0cywga2V5c09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShrZXlzT3JPcHRpb25zKSA/IGtleXNPck9wdGlvbnMgOiB1bmRlZmluZWQ7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dG8sIGtleVBhdGggfSA9IHRoaXMuc2NoZW1hLnByaW1LZXk7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBrZXlzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtBZGQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgICAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJBcmd1bWVudHMgb2JqZWN0cyBhbmQga2V5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgY29uc3QgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG9iamVjdHNUb0FkZCA9IGtleVBhdGggJiYgYXV0byA/XG4gICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgICAgICAgICBvYmplY3RzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2FkZCcsIGtleXM6IGtleXMsIHZhbHVlczogb2JqZWN0c1RvQWRkLCB3YW50UmVzdWx0cyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKCh7IG51bUZhaWx1cmVzLCByZXN1bHRzLCBsYXN0UmVzdWx0LCBmYWlsdXJlcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FudFJlc3VsdHMgPyByZXN1bHRzIDogbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihgJHt0aGlzLm5hbWV9LmJ1bGtBZGQoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1PYmplY3RzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVsa1B1dChvYmplY3RzLCBrZXlzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgKGtleXMgPyB1bmRlZmluZWQgOiBrZXlzT3JPcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd2FudFJlc3VsdHMgPSBvcHRpb25zID8gb3B0aW9ucy5hbGxLZXlzIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0bywga2V5UGF0aCB9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiYnVsa1B1dCgpOiBrZXlzIGFyZ3VtZW50IGludmFsaWQgb24gdGFibGVzIHdpdGggaW5ib3VuZCBrZXlzXCIpO1xuICAgICAgICAgICAgaWYgKGtleXMgJiYga2V5cy5sZW5ndGggIT09IG9iamVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICBjb25zdCBudW1PYmplY3RzID0gb2JqZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgb2JqZWN0c1RvUHV0ID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgICAgICAgICBvYmplY3RzLm1hcCh3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKSkgOlxuICAgICAgICAgICAgICAgIG9iamVjdHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAncHV0Jywga2V5czoga2V5cywgdmFsdWVzOiBvYmplY3RzVG9QdXQsIHdhbnRSZXN1bHRzIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHsgbnVtRmFpbHVyZXMsIHJlc3VsdHMsIGxhc3RSZXN1bHQsIGZhaWx1cmVzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB3YW50UmVzdWx0cyA/IHJlc3VsdHMgOiBsYXN0UmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKGAke3RoaXMubmFtZX0uYnVsa1B1dCgpOiAke251bUZhaWx1cmVzfSBvZiAke251bU9iamVjdHN9IG9wZXJhdGlvbnMgZmFpbGVkYCwgZmFpbHVyZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWxrRGVsZXRlKGtleXMpIHtcbiAgICAgICAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBrZXlzIH0pO1xuICAgICAgICB9KS50aGVuKCh7IG51bUZhaWx1cmVzLCBsYXN0UmVzdWx0LCBmYWlsdXJlcyB9KSA9PiB7XG4gICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKGAke3RoaXMubmFtZX0uYnVsa0RlbGV0ZSgpOiAke251bUZhaWx1cmVzfSBvZiAke251bUtleXN9IG9wZXJhdGlvbnMgZmFpbGVkYCwgZmFpbHVyZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEV2ZW50cyhjdHgpIHtcbiAgICB2YXIgZXZzID0ge307XG4gICAgdmFyIHJ2ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICAgICAgICAgIHdoaWxlICgtLWkpXG4gICAgICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBldnNbZXZlbnROYW1lXS5zdWJzY3JpYmUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBldnNbZXZlbnROYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcnYuYWRkRXZlbnRUeXBlID0gYWRkO1xuICAgIGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICBhZGQoYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICAgIGZ1bmN0aW9uIGFkZChldmVudE5hbWUsIGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gYWRkQ29uZmlndXJlZEV2ZW50cyhldmVudE5hbWUpO1xuICAgICAgICBpZiAoIWNoYWluRnVuY3Rpb24pXG4gICAgICAgICAgICBjaGFpbkZ1bmN0aW9uID0gcmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW47XG4gICAgICAgIGlmICghZGVmYXVsdEZ1bmN0aW9uKVxuICAgICAgICAgICAgZGVmYXVsdEZ1bmN0aW9uID0gbm9wO1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgICAgIGZpcmU6IGRlZmF1bHRGdW5jdGlvbixcbiAgICAgICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc3Vic2NyaWJlcnMuaW5kZXhPZihjYikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNoYWluRnVuY3Rpb24oY29udGV4dC5maXJlLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzID0gY29udGV4dC5zdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbiAhPT0gY2I7IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNvbnRleHQuc3Vic2NyaWJlcnMucmVkdWNlKGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV2c1tldmVudE5hbWVdID0gcnZbZXZlbnROYW1lXSA9IGNvbnRleHQ7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRDb25maWd1cmVkRXZlbnRzKGNmZykge1xuICAgICAgICBrZXlzKGNmZykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGNmZ1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgICAgICAgICBhZGQoZXZlbnROYW1lLCBjZmdbZXZlbnROYW1lXVswXSwgY2ZnW2V2ZW50TmFtZV1bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJncyA9PT0gJ2FzYXAnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBhZGQoZXZlbnROYW1lLCBtaXJyb3IsIGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzYXAkMShmdW5jdGlvbiBmaXJlRXZlbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCBldmVudCBjb25maWdcIik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFrZUNsYXNzQ29uc3RydWN0b3IocHJvdG90eXBlLCBjb25zdHJ1Y3Rvcikge1xuICAgIGRlcml2ZShjb25zdHJ1Y3RvcikuZnJvbSh7IHByb3RvdHlwZSB9KTtcbiAgICByZXR1cm4gY29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlQ29uc3RydWN0b3IoZGIpIHtcbiAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVGFibGUucHJvdG90eXBlLCBmdW5jdGlvbiBUYWJsZShuYW1lLCB0YWJsZVNjaGVtYSwgdHJhbnMpIHtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICB0aGlzLl90eCA9IHRyYW5zO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHRhYmxlU2NoZW1hO1xuICAgICAgICB0aGlzLmhvb2sgPSBkYi5fYWxsVGFibGVzW25hbWVdID8gZGIuX2FsbFRhYmxlc1tuYW1lXS5ob29rIDogRXZlbnRzKG51bGwsIHtcbiAgICAgICAgICAgIFwiY3JlYXRpbmdcIjogW2hvb2tDcmVhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICAgICAgXCJyZWFkaW5nXCI6IFtwdXJlRnVuY3Rpb25DaGFpbiwgbWlycm9yXSxcbiAgICAgICAgICAgIFwidXBkYXRpbmdcIjogW2hvb2tVcGRhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICAgICAgXCJkZWxldGluZ1wiOiBbaG9va0RlbGV0aW5nQ2hhaW4sIG5vcF1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5LZXlSYW5nZShjdHgsIGlnbm9yZUxpbWl0RmlsdGVyKSB7XG4gICAgcmV0dXJuICEoY3R4LmZpbHRlciB8fCBjdHguYWxnb3JpdGhtIHx8IGN0eC5vcikgJiZcbiAgICAgICAgKGlnbm9yZUxpbWl0RmlsdGVyID8gY3R4Lmp1c3RMaW1pdCA6ICFjdHgucmVwbGF5RmlsdGVyKTtcbn1cbmZ1bmN0aW9uIGFkZEZpbHRlcihjdHgsIGZuKSB7XG4gICAgY3R4LmZpbHRlciA9IGNvbWJpbmUoY3R4LmZpbHRlciwgZm4pO1xufVxuZnVuY3Rpb24gYWRkUmVwbGF5RmlsdGVyKGN0eCwgZmFjdG9yeSwgaXNMaW1pdEZpbHRlcikge1xuICAgIHZhciBjdXJyID0gY3R4LnJlcGxheUZpbHRlcjtcbiAgICBjdHgucmVwbGF5RmlsdGVyID0gY3VyciA/ICgpID0+IGNvbWJpbmUoY3VycigpLCBmYWN0b3J5KCkpIDogZmFjdG9yeTtcbiAgICBjdHguanVzdExpbWl0ID0gaXNMaW1pdEZpbHRlciAmJiAhY3Vycjtcbn1cbmZ1bmN0aW9uIGFkZE1hdGNoRmlsdGVyKGN0eCwgZm4pIHtcbiAgICBjdHguaXNNYXRjaCA9IGNvbWJpbmUoY3R4LmlzTWF0Y2gsIGZuKTtcbn1cbmZ1bmN0aW9uIGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVTY2hlbWEpIHtcbiAgICBpZiAoY3R4LmlzUHJpbUtleSlcbiAgICAgICAgcmV0dXJuIGNvcmVTY2hlbWEucHJpbWFyeUtleTtcbiAgICBjb25zdCBpbmRleCA9IGNvcmVTY2hlbWEuZ2V0SW5kZXhCeUtleVBhdGgoY3R4LmluZGV4KTtcbiAgICBpZiAoIWluZGV4KVxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJLZXlQYXRoIFwiICsgY3R4LmluZGV4ICsgXCIgb24gb2JqZWN0IHN0b3JlIFwiICsgY29yZVNjaGVtYS5uYW1lICsgXCIgaXMgbm90IGluZGV4ZWRcIik7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gb3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgdHJhbnMpIHtcbiAgICBjb25zdCBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpO1xuICAgIHJldHVybiBjb3JlVGFibGUub3BlbkN1cnNvcih7XG4gICAgICAgIHRyYW5zLFxuICAgICAgICB2YWx1ZXM6ICFjdHgua2V5c09ubHksXG4gICAgICAgIHJldmVyc2U6IGN0eC5kaXIgPT09ICdwcmV2JyxcbiAgICAgICAgdW5pcXVlOiAhIWN0eC51bmlxdWUsXG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXRlcihjdHgsIGZuLCBjb3JlVHJhbnMsIGNvcmVUYWJsZSkge1xuICAgIGNvbnN0IGZpbHRlciA9IGN0eC5yZXBsYXlGaWx0ZXIgPyBjb21iaW5lKGN0eC5maWx0ZXIsIGN0eC5yZXBsYXlGaWx0ZXIoKSkgOiBjdHguZmlsdGVyO1xuICAgIGlmICghY3R4Lm9yKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIGNvcmVUcmFucyksIGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZmlsdGVyKSwgZm4sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHNldCA9IHt9O1xuICAgICAgICBjb25zdCB1bmlvbiA9IChpdGVtLCBjdXJzb3IsIGFkdmFuY2UpID0+IHtcbiAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihjdXJzb3IsIGFkdmFuY2UsIHJlc3VsdCA9PiBjdXJzb3Iuc3RvcChyZXN1bHQpLCBlcnIgPT4gY3Vyc29yLmZhaWwoZXJyKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSAnJyArIHByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJylcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gJycgKyBuZXcgVWludDhBcnJheShwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc093bihzZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0W2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBmbihpdGVtLCBjdXJzb3IsIGFkdmFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGN0eC5vci5faXRlcmF0ZSh1bmlvbiwgY29yZVRyYW5zKSxcbiAgICAgICAgICAgIGl0ZXJhdGUob3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSwgY3R4LmFsZ29yaXRobSwgdW5pb24sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKVxuICAgICAgICBdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpdGVyYXRlKGN1cnNvclByb21pc2UsIGZpbHRlciwgZm4sIHZhbHVlTWFwcGVyKSB7XG4gICAgdmFyIG1hcHBlZEZuID0gdmFsdWVNYXBwZXIgPyAoeCwgYywgYSkgPT4gZm4odmFsdWVNYXBwZXIoeCksIGMsIGEpIDogZm47XG4gICAgdmFyIHdyYXBwZWRGbiA9IHdyYXAobWFwcGVkRm4pO1xuICAgIHJldHVybiBjdXJzb3JQcm9taXNlLnRoZW4oY3Vyc29yID0+IHtcbiAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5zdGFydCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSAoKSA9PiBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoY3Vyc29yLCBhZHZhbmNlciA9PiBjID0gYWR2YW5jZXIsIHZhbCA9PiB7IGN1cnNvci5zdG9wKHZhbCk7IGMgPSBub3A7IH0sIGUgPT4geyBjdXJzb3IuZmFpbChlKTsgYyA9IG5vcDsgfSkpXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRGbihjdXJzb3IudmFsdWUsIGN1cnNvciwgYWR2YW5jZXIgPT4gYyA9IGFkdmFuY2VyKTtcbiAgICAgICAgICAgICAgICBjKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjbXAoYSwgYikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRhID0gdHlwZShhKTtcbiAgICAgICAgY29uc3QgdGIgPSB0eXBlKGIpO1xuICAgICAgICBpZiAodGEgIT09IHRiKSB7XG4gICAgICAgICAgICBpZiAodGEgPT09ICdBcnJheScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAodGIgPT09ICdBcnJheScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHRhID09PSAnYmluYXJ5JylcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmICh0YiA9PT0gJ2JpbmFyeScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHRhID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmICh0YiA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHRhID09PSAnRGF0ZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAodGIgIT09ICdEYXRlJylcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGEpIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICAgICAgICAgICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlVWludDhBcnJheXMoZ2V0VWludDhBcnJheShhKSwgZ2V0VWludDhBcnJheShiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVBcnJheXMoYSwgYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7IH1cbiAgICByZXR1cm4gTmFOO1xufVxuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgY29uc3QgYWwgPSBhLmxlbmd0aDtcbiAgICBjb25zdCBibCA9IGIubGVuZ3RoO1xuICAgIGNvbnN0IGwgPSBhbCA8IGJsID8gYWwgOiBibDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICBjb25zdCByZXMgPSBjbXAoYVtpXSwgYltpXSk7XG4gICAgICAgIGlmIChyZXMgIT09IDApXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gYWwgPT09IGJsID8gMCA6IGFsIDwgYmwgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBjb21wYXJlVWludDhBcnJheXMoYSwgYikge1xuICAgIGNvbnN0IGFsID0gYS5sZW5ndGg7XG4gICAgY29uc3QgYmwgPSBiLmxlbmd0aDtcbiAgICBjb25zdCBsID0gYWwgPCBibCA/IGFsIDogYmw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICByZXR1cm4gYVtpXSA8IGJbaV0gPyAtMSA6IDE7XG4gICAgfVxuICAgIHJldHVybiBhbCA9PT0gYmwgPyAwIDogYWwgPCBibCA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHR5cGUoeCkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgeDtcbiAgICBpZiAodCAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiB0O1xuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoeCkpXG4gICAgICAgIHJldHVybiAnYmluYXJ5JztcbiAgICBjb25zdCB0c1RhZyA9IHRvU3RyaW5nVGFnKHgpO1xuICAgIHJldHVybiB0c1RhZyA9PT0gJ0FycmF5QnVmZmVyJyA/ICdiaW5hcnknIDogdHNUYWc7XG59XG5mdW5jdGlvbiBnZXRVaW50OEFycmF5KGEpIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBhO1xuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkpXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhLmJ1ZmZlciwgYS5ieXRlT2Zmc2V0LCBhLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhKTtcbn1cblxuY2xhc3MgQ29sbGVjdGlvbiB7XG4gICAgX3JlYWQoZm4sIGNiKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIHJldHVybiBjdHguZXJyb3IgP1xuICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG4gICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkb25seScsIGZuKS50aGVuKGNiKTtcbiAgICB9XG4gICAgX3dyaXRlKGZuKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIHJldHVybiBjdHguZXJyb3IgP1xuICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG4gICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkd3JpdGUnLCBmbiwgXCJsb2NrZWRcIik7XG4gICAgfVxuICAgIF9hZGRBbGdvcml0aG0oZm4pIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgY3R4LmFsZ29yaXRobSA9IGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZm4pO1xuICAgIH1cbiAgICBfaXRlcmF0ZShmbiwgY29yZVRyYW5zKSB7XG4gICAgICAgIHJldHVybiBpdGVyKHRoaXMuX2N0eCwgZm4sIGNvcmVUcmFucywgdGhpcy5fY3R4LnRhYmxlLmNvcmUpO1xuICAgIH1cbiAgICBjbG9uZShwcm9wcykge1xuICAgICAgICB2YXIgcnYgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKSwgY3R4ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLl9jdHgpO1xuICAgICAgICBpZiAocHJvcHMpXG4gICAgICAgICAgICBleHRlbmQoY3R4LCBwcm9wcyk7XG4gICAgICAgIHJ2Ll9jdHggPSBjdHg7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgcmF3KCkge1xuICAgICAgICB0aGlzLl9jdHgudmFsdWVNYXBwZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZWFjaChmbikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZCh0cmFucyA9PiBpdGVyKGN0eCwgZm4sIHRyYW5zLCBjdHgudGFibGUuY29yZSkpO1xuICAgIH1cbiAgICBjb3VudChjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZCh0cmFucyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICBjb25zdCBjb3JlVGFibGUgPSBjdHgudGFibGUuY29yZTtcbiAgICAgICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlVGFibGUuY291bnQoe1xuICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oY291bnQgPT4gTWF0aC5taW4oY291bnQsIGN0eC5saW1pdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcihjdHgsICgpID0+IHsgKytjb3VudDsgcmV0dXJuIGZhbHNlOyB9LCB0cmFucywgY29yZVRhYmxlKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oY2IpO1xuICAgIH1cbiAgICBzb3J0Qnkoa2V5UGF0aCwgY2IpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBrZXlQYXRoLnNwbGl0KCcuJykucmV2ZXJzZSgpLCBsYXN0UGFydCA9IHBhcnRzWzBdLCBsYXN0SW5kZXggPSBwYXJ0cy5sZW5ndGggLSAxO1xuICAgICAgICBmdW5jdGlvbiBnZXR2YWwob2JqLCBpKSB7XG4gICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dmFsKG9ialtwYXJ0c1tpXV0sIGkgLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBvYmpbbGFzdFBhcnRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmRlciA9IHRoaXMuX2N0eC5kaXIgPT09IFwibmV4dFwiID8gMSA6IC0xO1xuICAgICAgICBmdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuICAgICAgICAgICAgdmFyIGFWYWwgPSBnZXR2YWwoYSwgbGFzdEluZGV4KSwgYlZhbCA9IGdldHZhbChiLCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGFWYWwgPCBiVmFsID8gLW9yZGVyIDogYVZhbCA+IGJWYWwgPyBvcmRlciA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEuc29ydChzb3J0ZXIpO1xuICAgICAgICB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgdG9BcnJheShjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZCh0cmFucyA9PiB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZU1hcHBlciB9ID0gY3R4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS50aGVuKCh7IHJlc3VsdCB9KSA9PiB2YWx1ZU1hcHBlciA/IHJlc3VsdC5tYXAodmFsdWVNYXBwZXIpIDogcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcihjdHgsIGl0ZW0gPT4gYS5wdXNoKGl0ZW0pLCB0cmFucywgY3R4LnRhYmxlLmNvcmUpLnRoZW4oKCkgPT4gYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNiKTtcbiAgICB9XG4gICAgb2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBpZiAob2Zmc2V0IDw9IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgY3R4Lm9mZnNldCArPSBvZmZzZXQ7XG4gICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4KSkge1xuICAgICAgICAgICAgYWRkUmVwbGF5RmlsdGVyKGN0eCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3Vyc29yLCBhZHZhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRMZWZ0ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRMZWZ0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLW9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShvZmZzZXRMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gKC0tb2Zmc2V0TGVmdCA8IDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxpbWl0KG51bVJvd3MpIHtcbiAgICAgICAgdGhpcy5fY3R4LmxpbWl0ID0gTWF0aC5taW4odGhpcy5fY3R4LmxpbWl0LCBudW1Sb3dzKTtcbiAgICAgICAgYWRkUmVwbGF5RmlsdGVyKHRoaXMuX2N0eCwgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIHJvd3NMZWZ0ID0gbnVtUm93cztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKC0tcm93c0xlZnQgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93c0xlZnQgPj0gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdW50aWwoZmlsdGVyRnVuY3Rpb24sIGJJbmNsdWRlU3RvcEVudHJ5KSB7XG4gICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJGdW5jdGlvbihjdXJzb3IudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYkluY2x1ZGVTdG9wRW50cnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaXJzdChjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5saW1pdCgxKS50b0FycmF5KGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgbGFzdChjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3QoY2IpO1xuICAgIH1cbiAgICBmaWx0ZXIoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRNYXRjaEZpbHRlcih0aGlzLl9jdHgsIGZpbHRlckZ1bmN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFuZChmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIG9yKGluZGV4TmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcy5fY3R4LnRhYmxlLCBpbmRleE5hbWUsIHRoaXMpO1xuICAgIH1cbiAgICByZXZlcnNlKCkge1xuICAgICAgICB0aGlzLl9jdHguZGlyID0gKHRoaXMuX2N0eC5kaXIgPT09IFwicHJldlwiID8gXCJuZXh0XCIgOiBcInByZXZcIik7XG4gICAgICAgIGlmICh0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSlcbiAgICAgICAgICAgIHRoaXMuX29uZGlyZWN0aW9uY2hhbmdlKHRoaXMuX2N0eC5kaXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBlYWNoS2V5KGNiKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLmtleSwgY3Vyc29yKTsgfSk7XG4gICAgfVxuICAgIGVhY2hVbmlxdWVLZXkoY2IpIHtcbiAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2hLZXkoY2IpO1xuICAgIH1cbiAgICBlYWNoUHJpbWFyeUtleShjYikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7IGNiKGN1cnNvci5wcmltYXJ5S2V5LCBjdXJzb3IpOyB9KTtcbiAgICB9XG4gICAga2V5cyhjYikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0sIGN1cnNvcikge1xuICAgICAgICAgICAgYS5wdXNoKGN1cnNvci5rZXkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgcHJpbWFyeUtleXMoY2IpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZCh0cmFucyA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS50aGVuKCh7IHJlc3VsdCB9KSA9PiByZXN1bHQpLnRoZW4oY2IpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaXRlbSwgY3Vyc29yKSB7XG4gICAgICAgICAgICBhLnB1c2goY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgdW5pcXVlS2V5cyhjYikge1xuICAgICAgICB0aGlzLl9jdHgudW5pcXVlID0gXCJ1bmlxdWVcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cyhjYik7XG4gICAgfVxuICAgIGZpcnN0S2V5KGNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLmtleXMoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICAgIH1cbiAgICBsYXN0S2V5KGNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maXJzdEtleShjYik7XG4gICAgfVxuICAgIGRpc3RpbmN0KCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LCBpZHggPSBjdHguaW5kZXggJiYgY3R4LnRhYmxlLnNjaGVtYS5pZHhCeU5hbWVbY3R4LmluZGV4XTtcbiAgICAgICAgaWYgKCFpZHggfHwgIWlkeC5tdWx0aSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB2YXIgc2V0ID0ge307XG4gICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgIHZhciBzdHJLZXkgPSBjdXJzb3IucHJpbWFyeUtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gaGFzT3duKHNldCwgc3RyS2V5KTtcbiAgICAgICAgICAgIHNldFtzdHJLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbW9kaWZ5KGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKHRyYW5zID0+IHtcbiAgICAgICAgICAgIHZhciBtb2RpZnllcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG1vZGlmeWVyID0gY2hhbmdlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBrZXlQYXRocyA9IGtleXMoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgdmFyIG51bUtleXMgPSBrZXlQYXRocy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbW9kaWZ5ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW55dGhpbmdNb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBrZXlQYXRoc1tpXSwgdmFsID0gY2hhbmdlc1trZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCkgIT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpdGVtLCBrZXlQYXRoLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueXRoaW5nTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbnl0aGluZ01vZGlmaWVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb3JlVGFibGUgPSBjdHgudGFibGUuY29yZTtcbiAgICAgICAgICAgIGNvbnN0IHsgb3V0Ym91bmQsIGV4dHJhY3RLZXkgfSA9IGNvcmVUYWJsZS5zY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5kYi5fb3B0aW9ucy5tb2RpZnlDaHVua1NpemUgfHwgMjAwO1xuICAgICAgICAgICAgY29uc3QgdG90YWxGYWlsdXJlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICAgICAgICBjb25zdCBmYWlsZWRLZXlzID0gW107XG4gICAgICAgICAgICBjb25zdCBhcHBseU11dGF0ZVJlc3VsdCA9IChleHBlY3RlZENvdW50LCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZhaWx1cmVzLCBudW1GYWlsdXJlcyB9ID0gcmVzO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCArPSBleHBlY3RlZENvdW50IC0gbnVtRmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIGtleXMoZmFpbHVyZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsRmFpbHVyZXMucHVzaChmYWlsdXJlc1twb3NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5wcmltYXJ5S2V5cygpLnRoZW4oa2V5cyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENodW5rID0gKG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKGxpbWl0LCBrZXlzLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlVGFibGUuZ2V0TWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGtleXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjb3VudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogXCJpbW11dGFibGVcIlxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKHZhbHVlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1dFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHV0S2V5cyA9IG91dGJvdW5kID8gW10gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlS2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRlZXBDbG9uZShvcmlnVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltS2V5OiBrZXlzW29mZnNldCArIGldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZ5ZXIuY2FsbChjdHgsIGN0eC52YWx1ZSwgY3R4KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eC52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW91dGJvdW5kICYmIGNtcChleHRyYWN0S2V5KG9yaWdWYWx1ZSksIGV4dHJhY3RLZXkoY3R4LnZhbHVlKSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFZhbHVlcy5wdXNoKGN0eC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRWYWx1ZXMucHVzaChjdHgudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dEtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNyaXRlcmlhID0gaXNQbGFpbktleVJhbmdlKGN0eCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGltaXQgPT09IEluZmluaXR5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nIHx8IGNoYW5nZXMgPT09IGRlbGV0ZUNhbGxiYWNrKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGN0eC5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhZGRWYWx1ZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2FkZCcsIHZhbHVlczogYWRkVmFsdWVzIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBpbiByZXMuZmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMuc3BsaWNlKHBhcnNlSW50KHBvcyksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5TXV0YXRlUmVzdWx0KGFkZFZhbHVlcy5sZW5ndGgsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKCkgPT4gKHB1dFZhbHVlcy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiB0eXBlb2YgY2hhbmdlcyA9PT0gJ29iamVjdCcpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHB1dEtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogcHV0VmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU3BlYzogdHlwZW9mIGNoYW5nZXMgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKHJlcyA9PiBhcHBseU11dGF0ZVJlc3VsdChwdXRWYWx1ZXMubGVuZ3RoLCByZXMpKSkudGhlbigoKSA9PiAoZGVsZXRlS2V5cy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiBjaGFuZ2VzID09PSBkZWxldGVDYWxsYmFjaykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZGVsZXRlS2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JpdGVyaWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKHJlcyA9PiBhcHBseU11dGF0ZVJlc3VsdChkZWxldGVLZXlzLmxlbmd0aCwgcmVzKSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aCA+IG9mZnNldCArIGNvdW50ICYmIG5leHRDaHVuayhvZmZzZXQgKyBsaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENodW5rKDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxGYWlsdXJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1vZGlmeUVycm9yKFwiRXJyb3IgbW9kaWZ5aW5nIG9uZSBvciBtb3JlIG9iamVjdHNcIiwgdG90YWxGYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHgsIHJhbmdlID0gY3R4LnJhbmdlO1xuICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCkgJiZcbiAgICAgICAgICAgICgoY3R4LmlzUHJpbUtleSAmJiAhaGFuZ3NPbkRlbGV0ZUxhcmdlS2V5UmFuZ2UpIHx8IHJhbmdlLnR5cGUgPT09IDMgKSlcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0ZSh0cmFucyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcmltYXJ5S2V5IH0gPSBjdHgudGFibGUuY29yZS5zY2hlbWE7XG4gICAgICAgICAgICAgICAgY29uc3QgY29yZVJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLmNvdW50KHsgdHJhbnMsIHF1ZXJ5OiB7IGluZGV4OiBwcmltYXJ5S2V5LCByYW5nZTogY29yZVJhbmdlIH0gfSkudGhlbihjb3VudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IGNvcmVSYW5nZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHsgZmFpbHVyZXMsIGxhc3RSZXN1bHQsIHJlc3VsdHMsIG51bUZhaWx1cmVzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJDb3VsZCBub3QgZGVsZXRlIHNvbWUgdmFsdWVzXCIsIE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAocG9zID0+IGZhaWx1cmVzW3Bvc10pLCBjb3VudCAtIG51bUZhaWx1cmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudCAtIG51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGlmeShkZWxldGVDYWxsYmFjayk7XG4gICAgfVxufVxuY29uc3QgZGVsZXRlQ2FsbGJhY2sgPSAodmFsdWUsIGN0eCkgPT4gY3R4LnZhbHVlID0gbnVsbDtcblxuZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9yKGRiKSB7XG4gICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKENvbGxlY3Rpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCBrZXlSYW5nZUdlbmVyYXRvcikge1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIGxldCBrZXlSYW5nZSA9IEFueVJhbmdlLCBlcnJvciA9IG51bGw7XG4gICAgICAgIGlmIChrZXlSYW5nZUdlbmVyYXRvcilcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAga2V5UmFuZ2UgPSBrZXlSYW5nZUdlbmVyYXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2hlcmVDdHggPSB3aGVyZUNsYXVzZS5fY3R4O1xuICAgICAgICBjb25zdCB0YWJsZSA9IHdoZXJlQ3R4LnRhYmxlO1xuICAgICAgICBjb25zdCByZWFkaW5nSG9vayA9IHRhYmxlLmhvb2sucmVhZGluZy5maXJlO1xuICAgICAgICB0aGlzLl9jdHggPSB7XG4gICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICBpbmRleDogd2hlcmVDdHguaW5kZXgsXG4gICAgICAgICAgICBpc1ByaW1LZXk6ICghd2hlcmVDdHguaW5kZXggfHwgKHRhYmxlLnNjaGVtYS5wcmltS2V5LmtleVBhdGggJiYgd2hlcmVDdHguaW5kZXggPT09IHRhYmxlLnNjaGVtYS5wcmltS2V5Lm5hbWUpKSxcbiAgICAgICAgICAgIHJhbmdlOiBrZXlSYW5nZSxcbiAgICAgICAgICAgIGtleXNPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgIGRpcjogXCJuZXh0XCIsXG4gICAgICAgICAgICB1bmlxdWU6IFwiXCIsXG4gICAgICAgICAgICBhbGdvcml0aG06IG51bGwsXG4gICAgICAgICAgICBmaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICByZXBsYXlGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICBqdXN0TGltaXQ6IHRydWUsXG4gICAgICAgICAgICBpc01hdGNoOiBudWxsLFxuICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgbGltaXQ6IEluZmluaXR5LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgb3I6IHdoZXJlQ3R4Lm9yLFxuICAgICAgICAgICAgdmFsdWVNYXBwZXI6IHJlYWRpbmdIb29rICE9PSBtaXJyb3IgPyByZWFkaW5nSG9vayA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlQ29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG59XG5mdW5jdGlvbiBzaW1wbGVDb21wYXJlUmV2ZXJzZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG59XG5cbmZ1bmN0aW9uIGZhaWwoY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UsIGVyciwgVCkge1xuICAgIHZhciBjb2xsZWN0aW9uID0gY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UgaW5zdGFuY2VvZiBXaGVyZUNsYXVzZSA/XG4gICAgICAgIG5ldyBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZS5Db2xsZWN0aW9uKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlKSA6XG4gICAgICAgIGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlO1xuICAgIGNvbGxlY3Rpb24uX2N0eC5lcnJvciA9IFQgPyBuZXcgVChlcnIpIDogbmV3IFR5cGVFcnJvcihlcnIpO1xuICAgIHJldHVybiBjb2xsZWN0aW9uO1xufVxuZnVuY3Rpb24gZW1wdHlDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlKSB7XG4gICAgcmV0dXJuIG5ldyB3aGVyZUNsYXVzZS5Db2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCAoKSA9PiByYW5nZUVxdWFsKFwiXCIpKS5saW1pdCgwKTtcbn1cbmZ1bmN0aW9uIHVwcGVyRmFjdG9yeShkaXIpIHtcbiAgICByZXR1cm4gZGlyID09PSBcIm5leHRcIiA/XG4gICAgICAgIChzKSA9PiBzLnRvVXBwZXJDYXNlKCkgOlxuICAgICAgICAocykgPT4gcy50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gbG93ZXJGYWN0b3J5KGRpcikge1xuICAgIHJldHVybiBkaXIgPT09IFwibmV4dFwiID9cbiAgICAgICAgKHMpID0+IHMudG9Mb3dlckNhc2UoKSA6XG4gICAgICAgIChzKSA9PiBzLnRvVXBwZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlLCBsb3dlck5lZWRsZSwgY21wLCBkaXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oa2V5Lmxlbmd0aCwgbG93ZXJOZWVkbGUubGVuZ3RoKTtcbiAgICB2YXIgbGxwID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbHdyS2V5Q2hhciA9IGxvd2VyS2V5W2ldO1xuICAgICAgICBpZiAobHdyS2V5Q2hhciAhPT0gbG93ZXJOZWVkbGVbaV0pIHtcbiAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCB1cHBlck5lZWRsZVtpXSkgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGkpICsgdXBwZXJOZWVkbGVbaV0gKyB1cHBlck5lZWRsZS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIGxvd2VyTmVlZGxlW2ldKSA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyBsb3dlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgICBpZiAobGxwID49IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyS2V5W2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21wKGtleVtpXSwgbHdyS2V5Q2hhcikgPCAwKVxuICAgICAgICAgICAgbGxwID0gaTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IGxvd2VyTmVlZGxlLmxlbmd0aCAmJiBkaXIgPT09IFwibmV4dFwiKVxuICAgICAgICByZXR1cm4ga2V5ICsgdXBwZXJOZWVkbGUuc3Vic3RyKGtleS5sZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPCBrZXkubGVuZ3RoICYmIGRpciA9PT0gXCJwcmV2XCIpXG4gICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIHVwcGVyTmVlZGxlLmxlbmd0aCk7XG4gICAgcmV0dXJuIChsbHAgPCAwID8gbnVsbCA6IGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyTmVlZGxlW2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSkpO1xufVxuZnVuY3Rpb24gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh3aGVyZUNsYXVzZSwgbWF0Y2gsIG5lZWRsZXMsIHN1ZmZpeCkge1xuICAgIHZhciB1cHBlciwgbG93ZXIsIGNvbXBhcmUsIHVwcGVyTmVlZGxlcywgbG93ZXJOZWVkbGVzLCBkaXJlY3Rpb24sIG5leHRLZXlTdWZmaXgsIG5lZWRsZXNMZW4gPSBuZWVkbGVzLmxlbmd0aDtcbiAgICBpZiAoIW5lZWRsZXMuZXZlcnkocyA9PiB0eXBlb2YgcyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybiBmYWlsKHdoZXJlQ2xhdXNlLCBTVFJJTkdfRVhQRUNURUQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0RGlyZWN0aW9uKGRpcikge1xuICAgICAgICB1cHBlciA9IHVwcGVyRmFjdG9yeShkaXIpO1xuICAgICAgICBsb3dlciA9IGxvd2VyRmFjdG9yeShkaXIpO1xuICAgICAgICBjb21wYXJlID0gKGRpciA9PT0gXCJuZXh0XCIgPyBzaW1wbGVDb21wYXJlIDogc2ltcGxlQ29tcGFyZVJldmVyc2UpO1xuICAgICAgICB2YXIgbmVlZGxlQm91bmRzID0gbmVlZGxlcy5tYXAoZnVuY3Rpb24gKG5lZWRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbG93ZXI6IGxvd2VyKG5lZWRsZSksIHVwcGVyOiB1cHBlcihuZWVkbGUpIH07XG4gICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKGEubG93ZXIsIGIubG93ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdXBwZXJOZWVkbGVzID0gbmVlZGxlQm91bmRzLm1hcChmdW5jdGlvbiAobmIpIHsgcmV0dXJuIG5iLnVwcGVyOyB9KTtcbiAgICAgICAgbG93ZXJOZWVkbGVzID0gbmVlZGxlQm91bmRzLm1hcChmdW5jdGlvbiAobmIpIHsgcmV0dXJuIG5iLmxvd2VyOyB9KTtcbiAgICAgICAgZGlyZWN0aW9uID0gZGlyO1xuICAgICAgICBuZXh0S2V5U3VmZml4ID0gKGRpciA9PT0gXCJuZXh0XCIgPyBcIlwiIDogc3VmZml4KTtcbiAgICB9XG4gICAgaW5pdERpcmVjdGlvbihcIm5leHRcIik7XG4gICAgdmFyIGMgPSBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwgKCkgPT4gY3JlYXRlUmFuZ2UodXBwZXJOZWVkbGVzWzBdLCBsb3dlck5lZWRsZXNbbmVlZGxlc0xlbiAtIDFdICsgc3VmZml4KSk7XG4gICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGluaXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICB9O1xuICAgIHZhciBmaXJzdFBvc3NpYmxlTmVlZGxlID0gMDtcbiAgICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgbG93ZXJLZXkgPSBsb3dlcihrZXkpO1xuICAgICAgICBpZiAobWF0Y2gobG93ZXJLZXksIGxvd2VyTmVlZGxlcywgZmlyc3RQb3NzaWJsZU5lZWRsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBmaXJzdFBvc3NpYmxlTmVlZGxlOyBpIDwgbmVlZGxlc0xlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhc2luZyA9IG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGVzW2ldLCBsb3dlck5lZWRsZXNbaV0sIGNvbXBhcmUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGNhc2luZyA9PT0gbnVsbCAmJiBsb3dlc3RQb3NzaWJsZUNhc2luZyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsIHx8IGNvbXBhcmUobG93ZXN0UG9zc2libGVDYXNpbmcsIGNhc2luZykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID0gY2FzaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb3dlc3RQb3NzaWJsZUNhc2luZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUobG93ZXN0UG9zc2libGVDYXNpbmcgKyBuZXh0S2V5U3VmZml4KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGM7XG59XG5mdW5jdGlvbiBjcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMiAsXG4gICAgICAgIGxvd2VyLFxuICAgICAgICB1cHBlcixcbiAgICAgICAgbG93ZXJPcGVuLFxuICAgICAgICB1cHBlck9wZW5cbiAgICB9O1xufVxuZnVuY3Rpb24gcmFuZ2VFcXVhbCh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDEgLFxuICAgICAgICBsb3dlcjogdmFsdWUsXG4gICAgICAgIHVwcGVyOiB2YWx1ZVxuICAgIH07XG59XG5cbmNsYXNzIFdoZXJlQ2xhdXNlIHtcbiAgICBnZXQgQ29sbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC50YWJsZS5kYi5Db2xsZWN0aW9uO1xuICAgIH1cbiAgICBiZXR3ZWVuKGxvd2VyLCB1cHBlciwgaW5jbHVkZUxvd2VyLCBpbmNsdWRlVXBwZXIpIHtcbiAgICAgICAgaW5jbHVkZUxvd2VyID0gaW5jbHVkZUxvd2VyICE9PSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZVVwcGVyID0gaW5jbHVkZVVwcGVyID09PSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA+IDApIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX2NtcChsb3dlciwgdXBwZXIpID09PSAwICYmIChpbmNsdWRlTG93ZXIgfHwgaW5jbHVkZVVwcGVyKSAmJiAhKGluY2x1ZGVMb3dlciAmJiBpbmNsdWRlVXBwZXIpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UobG93ZXIsIHVwcGVyLCAhaW5jbHVkZUxvd2VyLCAhaW5jbHVkZVVwcGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcXVhbHModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IHJhbmdlRXF1YWwodmFsdWUpKTtcbiAgICB9XG4gICAgYWJvdmUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHZhbHVlLCB1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG4gICAgYWJvdmVPckVxdWFsKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCBmYWxzZSkpO1xuICAgIH1cbiAgICBiZWxvdyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSwgZmFsc2UsIHRydWUpKTtcbiAgICB9XG4gICAgYmVsb3dPckVxdWFsKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh1bmRlZmluZWQsIHZhbHVlKSk7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGgoc3RyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFNUUklOR19FWFBFQ1RFRCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJldHdlZW4oc3RyLCBzdHIgKyBtYXhTdHJpbmcsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICBzdGFydHNXaXRoSWdub3JlQ2FzZShzdHIpIHtcbiAgICAgICAgaWYgKHN0ciA9PT0gXCJcIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0c1dpdGgoc3RyKTtcbiAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgKHgsIGEpID0+IHguaW5kZXhPZihhWzBdKSA9PT0gMCwgW3N0cl0sIG1heFN0cmluZyk7XG4gICAgfVxuICAgIGVxdWFsc0lnbm9yZUNhc2Uoc3RyKSB7XG4gICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiB4ID09PSBhWzBdLCBbc3RyXSwgXCJcIik7XG4gICAgfVxuICAgIGFueU9mSWdub3JlQ2FzZSgpIHtcbiAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCAoeCwgYSkgPT4gYS5pbmRleE9mKHgpICE9PSAtMSwgc2V0LCBcIlwiKTtcbiAgICB9XG4gICAgc3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSgpIHtcbiAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCAoeCwgYSkgPT4gYS5zb21lKG4gPT4geC5pbmRleE9mKG4pID09PSAwKSwgc2V0LCBtYXhTdHJpbmcpO1xuICAgIH1cbiAgICBhbnlPZigpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICBsZXQgY29tcGFyZSA9IHRoaXMuX2NtcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICBjb25zdCBjID0gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZShzZXRbMF0sIHNldFtzZXQubGVuZ3RoIC0gMV0pKTtcbiAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBkaXJlY3Rpb24gPT4ge1xuICAgICAgICAgICAgY29tcGFyZSA9IChkaXJlY3Rpb24gPT09IFwibmV4dFwiID9cbiAgICAgICAgICAgICAgICB0aGlzLl9hc2NlbmRpbmcgOlxuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc2NlbmRpbmcpO1xuICAgICAgICAgICAgc2V0LnNvcnQoY29tcGFyZSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgYy5fYWRkQWxnb3JpdGhtKChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShrZXksIHNldFtpXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGFyZShrZXksIHNldFtpXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoKCkgPT4geyBjdXJzb3IuY29udGludWUoc2V0W2ldKTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIG5vdEVxdWFsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2UoW1ttaW5LZXksIHZhbHVlXSwgW3ZhbHVlLCB0aGlzLmRiLl9tYXhLZXldXSwgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG4gICAgfVxuICAgIG5vbmVPZigpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2V0LnNvcnQodGhpcy5fYXNjZW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IHNldC5yZWR1Y2UoKHJlcywgdmFsKSA9PiByZXMgP1xuICAgICAgICAgICAgcmVzLmNvbmNhdChbW3Jlc1tyZXMubGVuZ3RoIC0gMV1bMV0sIHZhbF1dKSA6XG4gICAgICAgICAgICBbW21pbktleSwgdmFsXV0sIG51bGwpO1xuICAgICAgICByYW5nZXMucHVzaChbc2V0W3NldC5sZW5ndGggLSAxXSwgdGhpcy5kYi5fbWF4S2V5XSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2UocmFuZ2VzLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaW5BbnlSYW5nZShyYW5nZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY21wID0gdGhpcy5fY21wLCBhc2NlbmRpbmcgPSB0aGlzLl9hc2NlbmRpbmcsIGRlc2NlbmRpbmcgPSB0aGlzLl9kZXNjZW5kaW5nLCBtaW4gPSB0aGlzLl9taW4sIG1heCA9IHRoaXMuX21heDtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICBpZiAoIXJhbmdlcy5ldmVyeShyYW5nZSA9PiByYW5nZVswXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICByYW5nZVsxXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBhc2NlbmRpbmcocmFuZ2VbMF0sIHJhbmdlWzFdKSA8PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgXCJGaXJzdCBhcmd1bWVudCB0byBpbkFueVJhbmdlKCkgbXVzdCBiZSBhbiBBcnJheSBvZiB0d28tdmFsdWUgQXJyYXlzIFtsb3dlcix1cHBlcl0gd2hlcmUgdXBwZXIgbXVzdCBub3QgYmUgbG93ZXIgdGhhbiBsb3dlclwiLCBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5jbHVkZUxvd2VycyA9ICFvcHRpb25zIHx8IG9wdGlvbnMuaW5jbHVkZUxvd2VycyAhPT0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVVcHBlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZVVwcGVycyA9PT0gdHJ1ZTtcbiAgICAgICAgZnVuY3Rpb24gYWRkUmFuZ2UocmFuZ2VzLCBuZXdSYW5nZSkge1xuICAgICAgICAgICAgbGV0IGkgPSAwLCBsID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNtcChuZXdSYW5nZVswXSwgcmFuZ2VbMV0pIDwgMCAmJiBjbXAobmV3UmFuZ2VbMV0sIHJhbmdlWzBdKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMF0gPSBtaW4ocmFuZ2VbMF0sIG5ld1JhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0gPSBtYXgocmFuZ2VbMV0sIG5ld1JhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IGwpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3UmFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICAgICAgZnVuY3Rpb24gcmFuZ2VTb3J0ZXIoYSwgYikgeyByZXR1cm4gc29ydERpcmVjdGlvbihhWzBdLCBiWzBdKTsgfVxuICAgICAgICBsZXQgc2V0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2V0ID0gcmFuZ2VzLnJlZHVjZShhZGRSYW5nZSwgW10pO1xuICAgICAgICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZVBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGtleUlzQmV5b25kQ3VycmVudEVudHJ5ID0gaW5jbHVkZVVwcGVycyA/XG4gICAgICAgICAgICBrZXkgPT4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPiAwIDpcbiAgICAgICAgICAgIGtleSA9PiBhc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA+PSAwO1xuICAgICAgICBjb25zdCBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeSA9IGluY2x1ZGVMb3dlcnMgP1xuICAgICAgICAgICAga2V5ID0+IGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+IDAgOlxuICAgICAgICAgICAga2V5ID0+IGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+PSAwO1xuICAgICAgICBmdW5jdGlvbiBrZXlXaXRoaW5DdXJyZW50UmFuZ2Uoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gIWtleUlzQmV5b25kQ3VycmVudEVudHJ5KGtleSkgJiYgIWtleUlzQmVmb3JlQ3VycmVudEVudHJ5KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHNldFswXVswXSwgc2V0W3NldC5sZW5ndGggLSAxXVsxXSwgIWluY2x1ZGVMb3dlcnMsICFpbmNsdWRlVXBwZXJzKSk7XG4gICAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZGlyZWN0aW9uID0+IHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID0gZGVzY2VuZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgYy5fYWRkQWxnb3JpdGhtKChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgd2hpbGUgKGNoZWNrS2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICArK3JhbmdlUG9zO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZVBvcyA9PT0gc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jbXAoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA9PT0gMCB8fCB0aGlzLl9jbXAoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydERpcmVjdGlvbiA9PT0gYXNjZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHNldFtyYW5nZVBvc11bMF0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoc2V0W3JhbmdlUG9zXVsxXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGhBbnlPZigpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoIXNldC5ldmVyeShzID0+IHR5cGVvZiBzID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwic3RhcnRzV2l0aEFueU9mKCkgb25seSB3b3JrcyB3aXRoIHN0cmluZ3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKHNldC5tYXAoKHN0cikgPT4gW3N0ciwgc3RyICsgbWF4U3RyaW5nXSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3RvcihkYikge1xuICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihXaGVyZUNsYXVzZS5wcm90b3R5cGUsIGZ1bmN0aW9uIFdoZXJlQ2xhdXNlKHRhYmxlLCBpbmRleCwgb3JDb2xsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5fY3R4ID0ge1xuICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4ID09PSBcIjppZFwiID8gbnVsbCA6IGluZGV4LFxuICAgICAgICAgICAgb3I6IG9yQ29sbGVjdGlvblxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbmRleGVkREIgPSBkYi5fZGVwcy5pbmRleGVkREI7XG4gICAgICAgIGlmICghaW5kZXhlZERCKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuICAgICAgICB0aGlzLl9jbXAgPSB0aGlzLl9hc2NlbmRpbmcgPSBpbmRleGVkREIuY21wLmJpbmQoaW5kZXhlZERCKTtcbiAgICAgICAgdGhpcy5fZGVzY2VuZGluZyA9IChhLCBiKSA9PiBpbmRleGVkREIuY21wKGIsIGEpO1xuICAgICAgICB0aGlzLl9tYXggPSAoYSwgYikgPT4gaW5kZXhlZERCLmNtcChhLCBiKSA+IDAgPyBhIDogYjtcbiAgICAgICAgdGhpcy5fbWluID0gKGEsIGIpID0+IGluZGV4ZWREQi5jbXAoYSwgYikgPCAwID8gYSA6IGI7XG4gICAgICAgIHRoaXMuX0lEQktleVJhbmdlID0gZGIuX2RlcHMuSURCS2V5UmFuZ2U7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpIHtcbiAgICByZXR1cm4gd3JhcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmNvbnN0IERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FID0gJ3N0b3JhZ2VtdXRhdGVkJztcbmNvbnN0IFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSA9ICd4LXN0b3JhZ2VtdXRhdGVkLTEnO1xuY29uc3QgZ2xvYmFsRXZlbnRzID0gRXZlbnRzKG51bGwsIERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FKTtcblxuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIF9sb2NrKCkge1xuICAgICAgICBhc3NlcnQoIVBTRC5nbG9iYWwpO1xuICAgICAgICArK3RoaXMuX3JlY3Vsb2NrO1xuICAgICAgICBpZiAodGhpcy5fcmVjdWxvY2sgPT09IDEgJiYgIVBTRC5nbG9iYWwpXG4gICAgICAgICAgICBQU0QubG9ja093bmVyRm9yID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF91bmxvY2soKSB7XG4gICAgICAgIGFzc2VydCghUFNELmdsb2JhbCk7XG4gICAgICAgIGlmICgtLXRoaXMuX3JlY3Vsb2NrID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIVBTRC5nbG9iYWwpXG4gICAgICAgICAgICAgICAgUFNELmxvY2tPd25lckZvciA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fYmxvY2tlZEZ1bmNzLmxlbmd0aCA+IDAgJiYgIXRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuQW5kUFNEID0gdGhpcy5fYmxvY2tlZEZ1bmNzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdXNlUFNEKGZuQW5kUFNEWzFdLCBmbkFuZFBTRFswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2xvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Vsb2NrICYmIFBTRC5sb2NrT3duZXJGb3IgIT09IHRoaXM7XG4gICAgfVxuICAgIGNyZWF0ZShpZGJ0cmFucykge1xuICAgICAgICBpZiAoIXRoaXMubW9kZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjb25zdCBpZGJkYiA9IHRoaXMuZGIuaWRiZGI7XG4gICAgICAgIGNvbnN0IGRiT3BlbkVycm9yID0gdGhpcy5kYi5fc3RhdGUuZGJPcGVuRXJyb3I7XG4gICAgICAgIGFzc2VydCghdGhpcy5pZGJ0cmFucyk7XG4gICAgICAgIGlmICghaWRidHJhbnMgJiYgIWlkYmRiKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRiT3BlbkVycm9yICYmIGRiT3BlbkVycm9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiRGF0YWJhc2VDbG9zZWRFcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBcIk1pc3NpbmdBUElFcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKGRiT3BlbkVycm9yLm1lc3NhZ2UsIGRiT3BlbkVycm9yKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5PcGVuRmFpbGVkKGRiT3BlbkVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVHJhbnNhY3Rpb25JbmFjdGl2ZSgpO1xuICAgICAgICBhc3NlcnQodGhpcy5fY29tcGxldGlvbi5fc3RhdGUgPT09IG51bGwpO1xuICAgICAgICBpZGJ0cmFucyA9IHRoaXMuaWRidHJhbnMgPSBpZGJ0cmFucyB8fFxuICAgICAgICAgICAgKHRoaXMuZGIuY29yZVxuICAgICAgICAgICAgICAgID8gdGhpcy5kYi5jb3JlLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlLCB7IGR1cmFiaWxpdHk6IHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IH0pXG4gICAgICAgICAgICAgICAgOiBpZGJkYi50cmFuc2FjdGlvbih0aGlzLnN0b3JlTmFtZXMsIHRoaXMubW9kZSwgeyBkdXJhYmlsaXR5OiB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSB9KSk7XG4gICAgICAgIGlkYnRyYW5zLm9uZXJyb3IgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2KTtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChpZGJ0cmFucy5lcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZGJ0cmFucy5vbmFib3J0ID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSAmJiB0aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoaWRidHJhbnMuZXJyb3IpKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uKFwiYWJvcnRcIikuZmlyZShldik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZGJ0cmFucy5vbmNvbXBsZXRlID0gd3JhcCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgICAgICAgaWYgKCdtdXRhdGVkUGFydHMnIGluIGlkYnRyYW5zKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLmZpcmUoaWRidHJhbnNbXCJtdXRhdGVkUGFydHNcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9wcm9taXNlKG1vZGUsIGZuLCBiV3JpdGVMb2NrKSB7XG4gICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJyAmJiB0aGlzLm1vZGUgIT09ICdyZWFkd3JpdGUnKVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlRyYW5zYWN0aW9uIGlzIHJlYWRvbmx5XCIpKTtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuVHJhbnNhY3Rpb25JbmFjdGl2ZSgpKTtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tlZEZ1bmNzLnB1c2goWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UobW9kZSwgZm4sIGJXcml0ZUxvY2spLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgUFNEXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiV3JpdGVMb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwLmZpbmFsbHkoKCkgPT4gdGhpcy5fdW5sb2NrKCkpO1xuICAgICAgICAgICAgICAgIHAuX2xpYiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcbiAgICAgICAgICAgICAgICAgICAgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50Ll9yb290KCkgOiB0aGlzO1xuICAgIH1cbiAgICB3YWl0Rm9yKHByb21pc2VMaWtlKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdCgpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUocHJvbWlzZUxpa2UpO1xuICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0Zvcikge1xuICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IHJvb3QuX3dhaXRpbmdGb3IudGhlbigoKSA9PiBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBwcm9taXNlO1xuICAgICAgICAgICAgcm9vdC5fd2FpdGluZ1F1ZXVlID0gW107XG4gICAgICAgICAgICB2YXIgc3RvcmUgPSByb290LmlkYnRyYW5zLm9iamVjdFN0b3JlKHJvb3Quc3RvcmVOYW1lc1swXSk7XG4gICAgICAgICAgICAoZnVuY3Rpb24gc3BpbigpIHtcbiAgICAgICAgICAgICAgICArK3Jvb3QuX3NwaW5Db3VudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAocm9vdC5fd2FpdGluZ1F1ZXVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgKHJvb3QuX3dhaXRpbmdRdWV1ZS5zaGlmdCgpKSgpO1xuICAgICAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yKVxuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXQoLUluZmluaXR5KS5vbnN1Y2Nlc3MgPSBzcGluO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudFdhaXRQcm9taXNlID0gcm9vdC5fd2FpdGluZ0ZvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKHJlcyA9PiByb290Ll93YWl0aW5nUXVldWUucHVzaCh3cmFwKHJlc29sdmUuYmluZChudWxsLCByZXMpKSksIGVyciA9PiByb290Ll93YWl0aW5nUXVldWUucHVzaCh3cmFwKHJlamVjdC5iaW5kKG51bGwsIGVycikpKSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IgPT09IGN1cnJlbnRXYWl0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5pZGJ0cmFucylcbiAgICAgICAgICAgICAgICB0aGlzLmlkYnRyYW5zLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFibGUodGFibGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IG1lbW9pemVkVGFibGVzID0gKHRoaXMuX21lbW9pemVkVGFibGVzIHx8ICh0aGlzLl9tZW1vaXplZFRhYmxlcyA9IHt9KSk7XG4gICAgICAgIGlmIChoYXNPd24obWVtb2l6ZWRUYWJsZXMsIHRhYmxlTmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRUYWJsZXNbdGFibGVOYW1lXTtcbiAgICAgICAgY29uc3QgdGFibGVTY2hlbWEgPSB0aGlzLnNjaGVtYVt0YWJsZU5hbWVdO1xuICAgICAgICBpZiAoIXRhYmxlU2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25Cb3VuZFRhYmxlID0gbmV3IHRoaXMuZGIuVGFibGUodGFibGVOYW1lLCB0YWJsZVNjaGVtYSwgdGhpcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uQm91bmRUYWJsZS5jb3JlID0gdGhpcy5kYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV0gPSB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yKGRiKSB7XG4gICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSwgcGFyZW50KSB7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5zdG9yZU5hbWVzID0gc3RvcmVOYW1lcztcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBkYnNjaGVtYTtcbiAgICAgICAgdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgPSBjaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHk7XG4gICAgICAgIHRoaXMuaWRidHJhbnMgPSBudWxsO1xuICAgICAgICB0aGlzLm9uID0gRXZlbnRzKHRoaXMsIFwiY29tcGxldGVcIiwgXCJlcnJvclwiLCBcImFib3J0XCIpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlY3Vsb2NrID0gMDtcbiAgICAgICAgdGhpcy5fYmxvY2tlZEZ1bmNzID0gW107XG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2FpdGluZ1F1ZXVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3BpbkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fY29tcGxldGlvbiA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jb21wbGV0aW9uLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub24uY29tcGxldGUuZmlyZSgpO1xuICAgICAgICB9LCBlID0+IHtcbiAgICAgICAgICAgIHZhciB3YXNBY3RpdmUgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uLmVycm9yLmZpcmUoZSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3JlamVjdChlKSA6XG4gICAgICAgICAgICAgICAgd2FzQWN0aXZlICYmIHRoaXMuaWRidHJhbnMgJiYgdGhpcy5pZGJ0cmFucy5hYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4U3BlYyhuYW1lLCBrZXlQYXRoLCB1bmlxdWUsIG11bHRpLCBhdXRvLCBjb21wb3VuZCwgaXNQcmltS2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAga2V5UGF0aCxcbiAgICAgICAgdW5pcXVlLFxuICAgICAgICBtdWx0aSxcbiAgICAgICAgYXV0byxcbiAgICAgICAgY29tcG91bmQsXG4gICAgICAgIHNyYzogKHVuaXF1ZSAmJiAhaXNQcmltS2V5ID8gJyYnIDogJycpICsgKG11bHRpID8gJyonIDogJycpICsgKGF1dG8gPyBcIisrXCIgOiBcIlwiKSArIG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKVxuICAgIH07XG59XG5mdW5jdGlvbiBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aCkge1xuICAgIHJldHVybiB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgP1xuICAgICAgICBrZXlQYXRoIDpcbiAgICAgICAga2V5UGF0aCA/ICgnWycgKyBbXS5qb2luLmNhbGwoa2V5UGF0aCwgJysnKSArICddJykgOiBcIlwiO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUYWJsZVNjaGVtYShuYW1lLCBwcmltS2V5LCBpbmRleGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJpbUtleSxcbiAgICAgICAgaW5kZXhlcyxcbiAgICAgICAgbWFwcGVkQ2xhc3M6IG51bGwsXG4gICAgICAgIGlkeEJ5TmFtZTogYXJyYXlUb09iamVjdChpbmRleGVzLCBpbmRleCA9PiBbaW5kZXgubmFtZSwgaW5kZXhdKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNhZmFyaU11bHRpU3RvcmVGaXgoc3RvcmVOYW1lcykge1xuICAgIHJldHVybiBzdG9yZU5hbWVzLmxlbmd0aCA9PT0gMSA/IHN0b3JlTmFtZXNbMF0gOiBzdG9yZU5hbWVzO1xufVxubGV0IGdldE1heEtleSA9IChJZGJLZXlSYW5nZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIElkYktleVJhbmdlLm9ubHkoW1tdXSk7XG4gICAgICAgIGdldE1heEtleSA9ICgpID0+IFtbXV07XG4gICAgICAgIHJldHVybiBbW11dO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBnZXRNYXhLZXkgPSAoKSA9PiBtYXhTdHJpbmc7XG4gICAgICAgIHJldHVybiBtYXhTdHJpbmc7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpIHtcbiAgICBpZiAoa2V5UGF0aCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvcihrZXlQYXRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmogPT4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvcihrZXlQYXRoKSB7XG4gICAgY29uc3Qgc3BsaXQgPSBrZXlQYXRoLnNwbGl0KCcuJyk7XG4gICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gb2JqID0+IG9ialtrZXlQYXRoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmogPT4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcnJheWlmeShhcnJheUxpa2UpIHtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbChhcnJheUxpa2UpO1xufVxubGV0IF9pZF9jb3VudGVyID0gMDtcbmZ1bmN0aW9uIGdldEtleVBhdGhBbGlhcyhrZXlQYXRoKSB7XG4gICAgcmV0dXJuIGtleVBhdGggPT0gbnVsbCA/XG4gICAgICAgIFwiOmlkXCIgOlxuICAgICAgICB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAga2V5UGF0aCA6XG4gICAgICAgICAgICBgWyR7a2V5UGF0aC5qb2luKCcrJyl9XWA7XG59XG5mdW5jdGlvbiBjcmVhdGVEQkNvcmUoZGIsIElkYktleVJhbmdlLCB0bXBUcmFucykge1xuICAgIGZ1bmN0aW9uIGV4dHJhY3RTY2hlbWEoZGIsIHRyYW5zKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlcyA9IGFycmF5aWZ5KGRiLm9iamVjdFN0b3JlTmFtZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZGIubmFtZSxcbiAgICAgICAgICAgICAgICB0YWJsZXM6IHRhYmxlcy5tYXAodGFibGUgPT4gdHJhbnMub2JqZWN0U3RvcmUodGFibGUpKS5tYXAoc3RvcmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtleVBhdGgsIGF1dG9JbmNyZW1lbnQgfSA9IHN0b3JlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dGJvdW5kID0ga2V5UGF0aCA9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleEJ5S2V5UGF0aCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdG9yZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmltYXJ5S2V5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0luY3JlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlczogYXJyYXlpZnkoc3RvcmUuaW5kZXhOYW1lcykubWFwKGluZGV4TmFtZSA9PiBzdG9yZS5pbmRleChpbmRleE5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoaW5kZXggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgdW5pcXVlLCBtdWx0aUVudHJ5LCBrZXlQYXRoIH0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0S2V5OiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXhCeUtleVBhdGg6IChrZXlQYXRoKSA9PiBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW1wiOmlkXCJdID0gcmVzdWx0LnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV0gPSByZXN1bHQucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzR2V0QWxsOiB0YWJsZXMubGVuZ3RoID4gMCAmJiAoJ2dldEFsbCcgaW4gdHJhbnMub2JqZWN0U3RvcmUodGFibGVzWzBdKSkgJiZcbiAgICAgICAgICAgICAgICAhKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIS8oQ2hyb21lXFwvfEVkZ2VcXC8pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VJREJLZXlSYW5nZShyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gMyApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDQgKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgbmV2ZXIgdHlwZSB0byBJREJLZXlSYW5nZVwiKTtcbiAgICAgICAgY29uc3QgeyBsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuIH0gPSByYW5nZTtcbiAgICAgICAgY29uc3QgaWRiUmFuZ2UgPSBsb3dlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHVwcGVyID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgICAgIElkYktleVJhbmdlLnVwcGVyQm91bmQodXBwZXIsICEhdXBwZXJPcGVuKSA6XG4gICAgICAgICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS5sb3dlckJvdW5kKGxvd2VyLCAhIWxvd2VyT3BlbikgOlxuICAgICAgICAgICAgICAgIElkYktleVJhbmdlLmJvdW5kKGxvd2VyLCB1cHBlciwgISFsb3dlck9wZW4sICEhdXBwZXJPcGVuKTtcbiAgICAgICAgcmV0dXJuIGlkYlJhbmdlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVEYkNvcmVUYWJsZSh0YWJsZVNjaGVtYSkge1xuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZVNjaGVtYS5uYW1lO1xuICAgICAgICBmdW5jdGlvbiBtdXRhdGUoeyB0cmFucywgdHlwZSwga2V5cywgdmFsdWVzLCByYW5nZSB9KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRib3VuZCA9IHN0b3JlLmtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0FkZE9yUHV0ID0gdHlwZSA9PT0gXCJwdXRcIiB8fCB0eXBlID09PSBcImFkZFwiO1xuICAgICAgICAgICAgICAgIGlmICghaXNBZGRPclB1dCAmJiB0eXBlICE9PSAnZGVsZXRlJyAmJiB0eXBlICE9PSAnZGVsZXRlUmFuZ2UnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wZXJhdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBrZXlzIHx8IHZhbHVlcyB8fCB7IGxlbmd0aDogMSB9O1xuICAgICAgICAgICAgICAgIGlmIChrZXlzICYmIHZhbHVlcyAmJiBrZXlzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiBrZXlzIGFycmF5IG11c3QgaGF2ZSBzYW1lIGxlbmd0aCBhcyBnaXZlbiB2YWx1ZXMgYXJyYXkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IG51bUZhaWx1cmVzOiAwLCBmYWlsdXJlczoge30sIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlcTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXFzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgbnVtRmFpbHVyZXMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgKytudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBudW1GYWlsdXJlcywgZmFpbHVyZXMsIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSAzIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5jbGVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlLmRlbGV0ZShtYWtlSURCS2V5UmFuZ2UocmFuZ2UpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbYXJnczEsIGFyZ3MyXSA9IGlzQWRkT3JQdXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZXMsIGtleXNdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVzLCBudWxsXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBba2V5cywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FkZE9yUHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IChhcmdzMiAmJiBhcmdzMltpXSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbdHlwZV0oYXJnczFbaV0sIGFyZ3MyW2ldKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZVt0eXBlXShhcmdzMVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RSZXN1bHQgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICByZXFzLmZvckVhY2goKHJlcSwgaSkgPT4gcmVxLmVycm9yICE9IG51bGwgJiYgKGZhaWx1cmVzW2ldID0gcmVxLmVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtRmFpbHVyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IHR5cGUgPT09IFwiZGVsZXRlXCIgPyBrZXlzIDogcmVxcy5tYXAocmVxID0+IHJlcS5yZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBkb25lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb3BlbkN1cnNvcih7IHRyYW5zLCB2YWx1ZXMsIHF1ZXJ5LCByZXZlcnNlLCB1bmlxdWUgfSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGluZGV4LCByYW5nZSB9ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlIDpcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcmV2ZXJzZSA/XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcInByZXZ1bmlxdWVcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcInByZXZcIiA6XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5leHR1bmlxdWVcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5leHRcIjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXEgPSB2YWx1ZXMgfHwgISgnb3BlbktleUN1cnNvcicgaW4gc291cmNlKSA/XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5vcGVuQ3Vyc29yKG1ha2VJREJLZXlSYW5nZShyYW5nZSksIGRpcmVjdGlvbikgOlxuICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuX19faWQgPSArK19pZF9jb3VudGVyO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfY3Vyc29yQ29udGludWUgPSBjdXJzb3IuY29udGludWUuYmluZChjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkuYmluZChjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfY3Vyc29yQWR2YW5jZSA9IGN1cnNvci5hZHZhbmNlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZCA9ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIG5vdCBzdGFydGVkXCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb1Rocm93Q3Vyc29ySXNTdG9wcGVkID0gKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3Igbm90IHN0b3BwZWRcIik7IH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci50cmFucyA9IHRyYW5zO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCA9IGN1cnNvci5jb250aW51ZSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuYWR2YW5jZSA9IGRvVGhyb3dDdXJzb3JJc05vdFN0YXJ0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsID0gd3JhcChyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBnb3RPbmUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoKCkgPT4gZ290T25lLS0gPyB0aGlzLmNvbnRpbnVlKCkgOiB0aGlzLnN0b3AoKSkudGhlbigoKSA9PiB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0YXJ0ID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVyYXRpb25Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmVJdGVyYXRpb24sIHJlamVjdEl0ZXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24gPSB3cmFwKHJlc29sdmVJdGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdEl0ZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwgPSByZWplY3RJdGVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzU3RvcHBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUl0ZXJhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3VhcmRlZENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0YXJ0ID0gKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3IgYmVoaW5kIGxhc3QgZW50cnlcIik7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZ3VhcmRlZENhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUgPSBfY3Vyc29yQ29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlID0gX2N1cnNvckFkdmFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBndWFyZGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRpb25Qcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHF1ZXJ5KGhhc0dldEFsbCkge1xuICAgICAgICAgICAgcmV0dXJuIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnMsIHZhbHVlcywgbGltaXQsIHF1ZXJ5IH0gPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub25JbmZpbml0TGltaXQgPSBsaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBsaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpbmRleCwgcmFuZ2UgfSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkYktleVJhbmdlID0gbWFrZUlEQktleVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzR2V0QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXEgPSB2YWx1ZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5nZXRBbGwoaWRiS2V5UmFuZ2UsIG5vbkluZmluaXRMaW1pdCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5nZXRBbGxLZXlzKGlkYktleVJhbmdlLCBub25JbmZpbml0TGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50ID0+IHJlc29sdmUoeyByZXN1bHQ6IGV2ZW50LnRhcmdldC5yZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IHZhbHVlcyB8fCAhKCdvcGVuS2V5Q3Vyc29yJyBpbiBzb3VyY2UpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihpZGJLZXlSYW5nZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5vcGVuS2V5Q3Vyc29yKGlkYktleVJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZXMgPyBjdXJzb3IudmFsdWUgOiBjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGxpbWl0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZU5hbWUsXG4gICAgICAgICAgICBzY2hlbWE6IHRhYmxlU2NoZW1hLFxuICAgICAgICAgICAgbXV0YXRlLFxuICAgICAgICAgICAgZ2V0TWFueSh7IHRyYW5zLCBrZXlzIH0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXlDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjYWxsYmFja0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc0hhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXEgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdFtyZXEuX3Bvc10gPSByZXEucmVzdWx0KSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NhbGxiYWNrQ291bnQgPT09IGtleUNvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBzdG9yZS5nZXQoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLl9wb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBzdWNjZXNzSGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2tleUNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQoeyB0cmFucywga2V5IH0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXEgPSBzdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50ID0+IHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5KGhhc0dldEFsbCksXG4gICAgICAgICAgICBvcGVuQ3Vyc29yLFxuICAgICAgICAgICAgY291bnQoeyBxdWVyeSwgdHJhbnMgfSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIHJhbmdlIH0gPSBxdWVyeTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkYktleVJhbmdlID0gbWFrZUlEQktleVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxID0gaWRiS2V5UmFuZ2UgPyBzb3VyY2UuY291bnQoaWRiS2V5UmFuZ2UpIDogc291cmNlLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGV2ID0+IHJlc29sdmUoZXYudGFyZ2V0LnJlc3VsdCkpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IHNjaGVtYSwgaGFzR2V0QWxsIH0gPSBleHRyYWN0U2NoZW1hKGRiLCB0bXBUcmFucyk7XG4gICAgY29uc3QgdGFibGVzID0gc2NoZW1hLnRhYmxlcy5tYXAodGFibGVTY2hlbWEgPT4gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpKTtcbiAgICBjb25zdCB0YWJsZU1hcCA9IHt9O1xuICAgIHRhYmxlcy5mb3JFYWNoKHRhYmxlID0+IHRhYmxlTWFwW3RhYmxlLm5hbWVdID0gdGFibGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgICAgICB0cmFuc2FjdGlvbjogZGIudHJhbnNhY3Rpb24uYmluZChkYiksXG4gICAgICAgIHRhYmxlKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRhYmxlTWFwW25hbWVdO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWJsZSAnJHtuYW1lfScgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICByZXR1cm4gdGFibGVNYXBbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIE1JTl9LRVk6IC1JbmZpbml0eSxcbiAgICAgICAgTUFYX0tFWTogZ2V0TWF4S2V5KElkYktleVJhbmdlKSxcbiAgICAgICAgc2NoZW1hXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrKHN0YWNrSW1wbCwgbWlkZGxld2FyZXMpIHtcbiAgICByZXR1cm4gbWlkZGxld2FyZXMucmVkdWNlKChkb3duLCB7IGNyZWF0ZSB9KSA9PiAoeyAuLi5kb3duLCAuLi5jcmVhdGUoZG93bikgfSksIHN0YWNrSW1wbCk7XG59XG5mdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlU3RhY2tzKG1pZGRsZXdhcmVzLCBpZGJkYiwgeyBJREJLZXlSYW5nZSwgaW5kZXhlZERCIH0sIHRtcFRyYW5zKSB7XG4gICAgY29uc3QgZGJjb3JlID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrKGNyZWF0ZURCQ29yZShpZGJkYiwgSURCS2V5UmFuZ2UsIHRtcFRyYW5zKSwgbWlkZGxld2FyZXMuZGJjb3JlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYmNvcmVcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKHsgX25vdmlwOiBkYiB9LCB0bXBUcmFucykge1xuICAgIGNvbnN0IGlkYmRiID0gdG1wVHJhbnMuZGI7XG4gICAgY29uc3Qgc3RhY2tzID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhkYi5fbWlkZGxld2FyZXMsIGlkYmRiLCBkYi5fZGVwcywgdG1wVHJhbnMpO1xuICAgIGRiLmNvcmUgPSBzdGFja3MuZGJjb3JlO1xuICAgIGRiLnRhYmxlcy5mb3JFYWNoKHRhYmxlID0+IHtcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUubmFtZTtcbiAgICAgICAgaWYgKGRiLmNvcmUuc2NoZW1hLnRhYmxlcy5zb21lKHRibCA9PiB0YmwubmFtZSA9PT0gdGFibGVOYW1lKSkge1xuICAgICAgICAgICAgdGFibGUuY29yZSA9IGRiLmNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgIGlmIChkYlt0YWJsZU5hbWVdIGluc3RhbmNlb2YgZGIuVGFibGUpIHtcbiAgICAgICAgICAgICAgICBkYlt0YWJsZU5hbWVdLmNvcmUgPSB0YWJsZS5jb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldEFwaU9uUGxhY2UoeyBfbm92aXA6IGRiIH0sIG9ianMsIHRhYmxlTmFtZXMsIGRic2NoZW1hKSB7XG4gICAgdGFibGVOYW1lcy5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGRic2NoZW1hW3RhYmxlTmFtZV07XG4gICAgICAgIG9ianMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcERlc2MgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCB0YWJsZU5hbWUpO1xuICAgICAgICAgICAgaWYgKCFwcm9wRGVzYyB8fCAoXCJ2YWx1ZVwiIGluIHByb3BEZXNjICYmIHByb3BEZXNjLnZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlIHx8IG9iaiBpbnN0YW5jZW9mIGRiLlRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFByb3Aob2JqLCB0YWJsZU5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMudGFibGUodGFibGVOYW1lKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIHRhYmxlTmFtZSwgeyB2YWx1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmpbdGFibGVOYW1lXSA9IG5ldyBkYi5UYWJsZSh0YWJsZU5hbWUsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVRhYmxlc0FwaSh7IF9ub3ZpcDogZGIgfSwgb2Jqcykge1xuICAgIG9ianMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqW2tleV0gaW5zdGFuY2VvZiBkYi5UYWJsZSlcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGxvd2VyVmVyc2lvbkZpcnN0KGEsIGIpIHtcbiAgICByZXR1cm4gYS5fY2ZnLnZlcnNpb24gLSBiLl9jZmcudmVyc2lvbjtcbn1cbmZ1bmN0aW9uIHJ1blVwZ3JhZGVycyhkYiwgb2xkVmVyc2lvbiwgaWRiVXBncmFkZVRyYW5zLCByZWplY3QpIHtcbiAgICBjb25zdCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG4gICAgY29uc3QgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScsIGRiLl9zdG9yZU5hbWVzLCBnbG9iYWxTY2hlbWEpO1xuICAgIHRyYW5zLmNyZWF0ZShpZGJVcGdyYWRlVHJhbnMpO1xuICAgIHRyYW5zLl9jb21wbGV0aW9uLmNhdGNoKHJlamVjdCk7XG4gICAgY29uc3QgcmVqZWN0VHJhbnNhY3Rpb24gPSB0cmFucy5fcmVqZWN0LmJpbmQodHJhbnMpO1xuICAgIGNvbnN0IHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuICAgIG5ld1Njb3BlKCgpID0+IHtcbiAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgICAgIFBTRC50cmFuc2xlc3MgPSB0cmFuc2xlc3M7XG4gICAgICAgIGlmIChvbGRWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICBrZXlzKGdsb2JhbFNjaGVtYSkuZm9yRWFjaCh0YWJsZU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYlVwZ3JhZGVUcmFucywgdGFibGVOYW1lLCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5wcmltS2V5LCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5pbmRleGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgRGV4aWVQcm9taXNlLmZvbGxvdygoKSA9PiBkYi5vbi5wb3B1bGF0ZS5maXJlKHRyYW5zKSkuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoZGIsIG9sZFZlcnNpb24sIHRyYW5zLCBpZGJVcGdyYWRlVHJhbnMpLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoeyBfbm92aXA6IGRiIH0sIG9sZFZlcnNpb24sIHRyYW5zLCBpZGJVcGdyYWRlVHJhbnMpIHtcbiAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgIGNvbnN0IHZlcnNpb25zID0gZGIuX3ZlcnNpb25zO1xuICAgIGxldCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgbGV0IGFueUNvbnRlbnRVcGdyYWRlckhhc1J1biA9IGZhbHNlO1xuICAgIGNvbnN0IHZlcnNUb1J1biA9IHZlcnNpb25zLmZpbHRlcih2ID0+IHYuX2NmZy52ZXJzaW9uID49IG9sZFZlcnNpb24pO1xuICAgIHZlcnNUb1J1bi5mb3JFYWNoKHZlcnNpb24gPT4ge1xuICAgICAgICBxdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFNjaGVtYSA9IGdsb2JhbFNjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBvbGRTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgbmV3U2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gbmV3U2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpO1xuICAgICAgICAgICAgZGlmZi5hZGQuZm9yRWFjaCh0dXBsZSA9PiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0dXBsZVswXSwgdHVwbGVbMV0ucHJpbUtleSwgdHVwbGVbMV0uaW5kZXhlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpZmYuY2hhbmdlLmZvckVhY2goY2hhbmdlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnJlY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlVwZ3JhZGUoXCJOb3QgeWV0IHN1cHBvcnQgZm9yIGNoYW5naW5nIHByaW1hcnkga2V5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSBpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmUoY2hhbmdlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuYWRkLmZvckVhY2goaWR4ID0+IGFkZEluZGV4KHN0b3JlLCBpZHgpKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmNoYW5nZS5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5kZWxldGVJbmRleChpZHgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJbmRleChzdG9yZSwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kZWwuZm9yRWFjaChpZHhOYW1lID0+IHN0b3JlLmRlbGV0ZUluZGV4KGlkeE5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRVcGdyYWRlID0gdmVyc2lvbi5fY2ZnLmNvbnRlbnRVcGdyYWRlO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlICYmIHZlcnNpb24uX2NmZy52ZXJzaW9uID4gb2xkVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgICAgICAgICB0cmFucy5fbWVtb2l6ZWRUYWJsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBhbnlDb250ZW50VXBncmFkZXJIYXNSdW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCB1cGdyYWRlU2NoZW1hID0gc2hhbGxvd0Nsb25lKG5ld1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGlmZi5kZWwuZm9yRWFjaCh0YWJsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZ3JhZGVTY2hlbWFbdGFibGVdID0gb2xkU2NoZW1hW3RhYmxlXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSwga2V5cyh1cGdyYWRlU2NoZW1hKSwgdXBncmFkZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgdHJhbnMuc2NoZW1hID0gdXBncmFkZVNjaGVtYTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50VXBncmFkZUlzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24oY29udGVudFVwZ3JhZGUpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZUlzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VGb2xsb3dlZCA9IERleGllUHJvbWlzZS5mb2xsb3coKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGNvbnRlbnRVcGdyYWRlKHRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlbWVudG9yID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMuYmluZChudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpIDogcHJvbWlzZUZvbGxvd2VkLnRoZW4oKCkgPT4gcmV0dXJuVmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHF1ZXVlLnB1c2goaWRidHJhbnMgPT4ge1xuICAgICAgICAgICAgaWYgKCFhbnlDb250ZW50VXBncmFkZXJIYXNSdW4gfHwgIWhhc0lFRGVsZXRlT2JqZWN0U3RvcmVCdWcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTY2hlbWEgPSB2ZXJzaW9uLl9jZmcuZGJzY2hlbWE7XG4gICAgICAgICAgICAgICAgZGVsZXRlUmVtb3ZlZFRhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGRiLl9zdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuICAgICAgICAgICAgdHJhbnMuc2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBydW5RdWV1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlLmxlbmd0aCA/IERleGllUHJvbWlzZS5yZXNvbHZlKHF1ZXVlLnNoaWZ0KCkodHJhbnMuaWRidHJhbnMpKS50aGVuKHJ1blF1ZXVlKSA6XG4gICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcnVuUXVldWUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgY3JlYXRlTWlzc2luZ1RhYmxlcyhnbG9iYWxTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTY2hlbWFEaWZmKG9sZFNjaGVtYSwgbmV3U2NoZW1hKSB7XG4gICAgY29uc3QgZGlmZiA9IHtcbiAgICAgICAgZGVsOiBbXSxcbiAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgY2hhbmdlOiBbXVxuICAgIH07XG4gICAgbGV0IHRhYmxlO1xuICAgIGZvciAodGFibGUgaW4gb2xkU2NoZW1hKSB7XG4gICAgICAgIGlmICghbmV3U2NoZW1hW3RhYmxlXSlcbiAgICAgICAgICAgIGRpZmYuZGVsLnB1c2godGFibGUpO1xuICAgIH1cbiAgICBmb3IgKHRhYmxlIGluIG5ld1NjaGVtYSkge1xuICAgICAgICBjb25zdCBvbGREZWYgPSBvbGRTY2hlbWFbdGFibGVdLCBuZXdEZWYgPSBuZXdTY2hlbWFbdGFibGVdO1xuICAgICAgICBpZiAoIW9sZERlZikge1xuICAgICAgICAgICAgZGlmZi5hZGQucHVzaChbdGFibGUsIG5ld0RlZl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRhYmxlLFxuICAgICAgICAgICAgICAgIGRlZjogbmV3RGVmLFxuICAgICAgICAgICAgICAgIHJlY3JlYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZWw6IFtdLFxuICAgICAgICAgICAgICAgIGFkZDogW10sXG4gICAgICAgICAgICAgICAgY2hhbmdlOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgoXG4gICAgICAgICAgICAnJyArIChvbGREZWYucHJpbUtleS5rZXlQYXRoIHx8ICcnKSkgIT09ICgnJyArIChuZXdEZWYucHJpbUtleS5rZXlQYXRoIHx8ICcnKSkgfHxcbiAgICAgICAgICAgICAgICAob2xkRGVmLnByaW1LZXkuYXV0byAhPT0gbmV3RGVmLnByaW1LZXkuYXV0byAmJiAhaXNJRU9yRWRnZSkpXG4gICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNoYW5nZS5yZWNyZWF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkSW5kZXhlcyA9IG9sZERlZi5pZHhCeU5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IG5ld0RlZi5pZHhCeU5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IGlkeE5hbWU7XG4gICAgICAgICAgICAgICAgZm9yIChpZHhOYW1lIGluIG9sZEluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdJbmRleGVzW2lkeE5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRlbC5wdXNoKGlkeE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGlkeE5hbWUgaW4gbmV3SW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRJZHggPSBvbGRJbmRleGVzW2lkeE5hbWVdLCBuZXdJZHggPSBuZXdJbmRleGVzW2lkeE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZElkeClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5hZGQucHVzaChuZXdJZHgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRJZHguc3JjICE9PSBuZXdJZHguc3JjKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmNoYW5nZS5wdXNoKG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UuZGVsLmxlbmd0aCA+IDAgfHwgY2hhbmdlLmFkZC5sZW5ndGggPiAwIHx8IGNoYW5nZS5jaGFuZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmLmNoYW5nZS5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuICAgIGNvbnN0IHN0b3JlID0gaWRidHJhbnMuZGIuY3JlYXRlT2JqZWN0U3RvcmUodGFibGVOYW1lLCBwcmltS2V5LmtleVBhdGggP1xuICAgICAgICB7IGtleVBhdGg6IHByaW1LZXkua2V5UGF0aCwgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH0gOlxuICAgICAgICB7IGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9KTtcbiAgICBpbmRleGVzLmZvckVhY2goaWR4ID0+IGFkZEluZGV4KHN0b3JlLCBpZHgpKTtcbiAgICByZXR1cm4gc3RvcmU7XG59XG5mdW5jdGlvbiBjcmVhdGVNaXNzaW5nVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpIHtcbiAgICBrZXlzKG5ld1NjaGVtYSkuZm9yRWFjaCh0YWJsZU5hbWUgPT4ge1xuICAgICAgICBpZiAoIWlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGFibGVOYW1lKSkge1xuICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJlbW92ZWRUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucykge1xuICAgIFtdLnNsaWNlLmNhbGwoaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcykuZm9yRWFjaChzdG9yZU5hbWUgPT4gbmV3U2NoZW1hW3N0b3JlTmFtZV0gPT0gbnVsbCAmJiBpZGJ0cmFucy5kYi5kZWxldGVPYmplY3RTdG9yZShzdG9yZU5hbWUpKTtcbn1cbmZ1bmN0aW9uIGFkZEluZGV4KHN0b3JlLCBpZHgpIHtcbiAgICBzdG9yZS5jcmVhdGVJbmRleChpZHgubmFtZSwgaWR4LmtleVBhdGgsIHsgdW5pcXVlOiBpZHgudW5pcXVlLCBtdWx0aUVudHJ5OiBpZHgubXVsdGkgfSk7XG59XG5mdW5jdGlvbiBidWlsZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKSB7XG4gICAgY29uc3QgZ2xvYmFsU2NoZW1hID0ge307XG4gICAgY29uc3QgZGJTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG4gICAgZGJTdG9yZU5hbWVzLmZvckVhY2goc3RvcmVOYW1lID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0bXBUcmFucy5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICBsZXQga2V5UGF0aCA9IHN0b3JlLmtleVBhdGg7XG4gICAgICAgIGNvbnN0IHByaW1LZXkgPSBjcmVhdGVJbmRleFNwZWMobmFtZUZyb21LZXlQYXRoKGtleVBhdGgpLCBrZXlQYXRoIHx8IFwiXCIsIGZhbHNlLCBmYWxzZSwgISFzdG9yZS5hdXRvSW5jcmVtZW50LCBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IGlkYmluZGV4ID0gc3RvcmUuaW5kZXgoc3RvcmUuaW5kZXhOYW1lc1tqXSk7XG4gICAgICAgICAgICBrZXlQYXRoID0gaWRiaW5kZXgua2V5UGF0aDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGNyZWF0ZUluZGV4U3BlYyhpZGJpbmRleC5uYW1lLCBrZXlQYXRoLCAhIWlkYmluZGV4LnVuaXF1ZSwgISFpZGJpbmRleC5tdWx0aUVudHJ5LCBmYWxzZSwga2V5UGF0aCAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gXCJzdHJpbmdcIiwgZmFsc2UpO1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxTY2hlbWFbc3RvcmVOYW1lXSA9IGNyZWF0ZVRhYmxlU2NoZW1hKHN0b3JlTmFtZSwgcHJpbUtleSwgaW5kZXhlcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdsb2JhbFNjaGVtYTtcbn1cbmZ1bmN0aW9uIHJlYWRHbG9iYWxTY2hlbWEoeyBfbm92aXA6IGRiIH0sIGlkYmRiLCB0bXBUcmFucykge1xuICAgIGRiLnZlcm5vID0gaWRiZGIudmVyc2lvbiAvIDEwO1xuICAgIGNvbnN0IGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuICAgIGRiLl9zdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG4gICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLl9hbGxUYWJsZXNdLCBrZXlzKGdsb2JhbFNjaGVtYSksIGdsb2JhbFNjaGVtYSk7XG59XG5mdW5jdGlvbiB2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGIsIHRtcFRyYW5zKSB7XG4gICAgY29uc3QgaW5zdGFsbGVkU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCB0bXBUcmFucyk7XG4gICAgY29uc3QgZGlmZiA9IGdldFNjaGVtYURpZmYoaW5zdGFsbGVkU2NoZW1hLCBkYi5fZGJTY2hlbWEpO1xuICAgIHJldHVybiAhKGRpZmYuYWRkLmxlbmd0aCB8fCBkaWZmLmNoYW5nZS5zb21lKGNoID0+IGNoLmFkZC5sZW5ndGggfHwgY2guY2hhbmdlLmxlbmd0aCkpO1xufVxuZnVuY3Rpb24gYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoeyBfbm92aXA6IGRiIH0sIHNjaGVtYSwgaWRidHJhbnMpIHtcbiAgICBjb25zdCBzdG9yZU5hbWVzID0gaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3JlTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVOYW1lID0gc3RvcmVOYW1lc1tpXTtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBpZGJ0cmFucy5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICBkYi5faGFzR2V0QWxsID0gJ2dldEFsbCcgaW4gc3RvcmU7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RvcmUuaW5kZXhOYW1lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhOYW1lID0gc3RvcmUuaW5kZXhOYW1lc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IGtleVBhdGggPSBzdG9yZS5pbmRleChpbmRleE5hbWUpLmtleVBhdGg7XG4gICAgICAgICAgICBjb25zdCBkZXhpZU5hbWUgPSB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyBrZXlQYXRoIDogXCJbXCIgKyBzbGljZShrZXlQYXRoKS5qb2luKCcrJykgKyBcIl1cIjtcbiAgICAgICAgICAgIGlmIChzY2hlbWFbc3RvcmVOYW1lXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4U3BlYyA9IHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtkZXhpZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleFNwZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhTcGVjLm5hbWUgPSBpbmRleE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2luZGV4TmFtZV0gPSBpbmRleFNwZWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICEvKENocm9tZVxcL3xFZGdlXFwvKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmIF9nbG9iYWwgaW5zdGFuY2VvZiBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmXG4gICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpIHtcbiAgICAgICAgZGIuX2hhc0dldEFsbCA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW5kZXhTeW50YXgocHJpbUtleUFuZEluZGV4ZXMpIHtcbiAgICByZXR1cm4gcHJpbUtleUFuZEluZGV4ZXMuc3BsaXQoJywnKS5tYXAoKGluZGV4LCBpbmRleE51bSkgPT4ge1xuICAgICAgICBpbmRleCA9IGluZGV4LnRyaW0oKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGluZGV4LnJlcGxhY2UoLyhbJipdfFxcK1xcKykvZywgXCJcIik7XG4gICAgICAgIGNvbnN0IGtleVBhdGggPSAvXlxcWy8udGVzdChuYW1lKSA/IG5hbWUubWF0Y2goL15cXFsoLiopXFxdJC8pWzFdLnNwbGl0KCcrJykgOiBuYW1lO1xuICAgICAgICByZXR1cm4gY3JlYXRlSW5kZXhTcGVjKG5hbWUsIGtleVBhdGggfHwgbnVsbCwgL1xcJi8udGVzdChpbmRleCksIC9cXCovLnRlc3QoaW5kZXgpLCAvXFwrXFwrLy50ZXN0KGluZGV4KSwgaXNBcnJheShrZXlQYXRoKSwgaW5kZXhOdW0gPT09IDApO1xuICAgIH0pO1xufVxuXG5jbGFzcyBWZXJzaW9uIHtcbiAgICBfcGFyc2VTdG9yZXNTcGVjKHN0b3Jlcywgb3V0U2NoZW1hKSB7XG4gICAgICAgIGtleXMoc3RvcmVzKS5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RvcmVzW3RhYmxlTmFtZV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IHBhcnNlSW5kZXhTeW50YXgoc3RvcmVzW3RhYmxlTmFtZV0pO1xuICAgICAgICAgICAgICAgIHZhciBwcmltS2V5ID0gaW5kZXhlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmltS2V5Lm11bHRpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJQcmltYXJ5IGtleSBjYW5ub3QgYmUgbXVsdGktdmFsdWVkXCIpO1xuICAgICAgICAgICAgICAgIGluZGV4ZXMuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4LmF1dG8pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJPbmx5IHByaW1hcnkga2V5IGNhbiBiZSBtYXJrZWQgYXMgYXV0b0luY3JlbWVudCAoKyspXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlkeC5rZXlQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiSW5kZXggbXVzdCBoYXZlIGEgbmFtZSBhbmQgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvdXRTY2hlbWFbdGFibGVOYW1lXSA9IGNyZWF0ZVRhYmxlU2NoZW1hKHRhYmxlTmFtZSwgcHJpbUtleSwgaW5kZXhlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9yZXMoc3RvcmVzKSB7XG4gICAgICAgIGNvbnN0IGRiID0gdGhpcy5kYjtcbiAgICAgICAgdGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSA9IHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgP1xuICAgICAgICAgICAgZXh0ZW5kKHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UsIHN0b3JlcykgOlxuICAgICAgICAgICAgc3RvcmVzO1xuICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IGRiLl92ZXJzaW9ucztcbiAgICAgICAgY29uc3Qgc3RvcmVzU3BlYyA9IHt9O1xuICAgICAgICBsZXQgZGJzY2hlbWEgPSB7fTtcbiAgICAgICAgdmVyc2lvbnMuZm9yRWFjaCh2ZXJzaW9uID0+IHtcbiAgICAgICAgICAgIGV4dGVuZChzdG9yZXNTcGVjLCB2ZXJzaW9uLl9jZmcuc3RvcmVzU291cmNlKTtcbiAgICAgICAgICAgIGRic2NoZW1hID0gKHZlcnNpb24uX2NmZy5kYnNjaGVtYSA9IHt9KTtcbiAgICAgICAgICAgIHZlcnNpb24uX3BhcnNlU3RvcmVzU3BlYyhzdG9yZXNTcGVjLCBkYnNjaGVtYSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkYi5fZGJTY2hlbWEgPSBkYnNjaGVtYTtcbiAgICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSwgdGhpcy5fY2ZnLnRhYmxlc10sIGtleXMoZGJzY2hlbWEpLCBkYnNjaGVtYSk7XG4gICAgICAgIGRiLl9zdG9yZU5hbWVzID0ga2V5cyhkYnNjaGVtYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGdyYWRlKHVwZ3JhZGVGdW5jdGlvbikge1xuICAgICAgICB0aGlzLl9jZmcuY29udGVudFVwZ3JhZGUgPSBwcm9taXNhYmxlQ2hhaW4odGhpcy5fY2ZnLmNvbnRlbnRVcGdyYWRlIHx8IG5vcCwgdXBncmFkZUZ1bmN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IoZGIpIHtcbiAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVmVyc2lvbi5wcm90b3R5cGUsIGZ1bmN0aW9uIFZlcnNpb24odmVyc2lvbk51bWJlcikge1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMuX2NmZyA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25OdW1iZXIsXG4gICAgICAgICAgICBzdG9yZXNTb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBkYnNjaGVtYToge30sXG4gICAgICAgICAgICB0YWJsZXM6IHt9LFxuICAgICAgICAgICAgY29udGVudFVwZ3JhZGU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpIHtcbiAgICBsZXQgZGJOYW1lc0RCID0gaW5kZXhlZERCW1wiX2RiTmFtZXNEQlwiXTtcbiAgICBpZiAoIWRiTmFtZXNEQikge1xuICAgICAgICBkYk5hbWVzREIgPSBpbmRleGVkREJbXCJfZGJOYW1lc0RCXCJdID0gbmV3IERleGllJDEoREJOQU1FU19EQiwge1xuICAgICAgICAgICAgYWRkb25zOiBbXSxcbiAgICAgICAgICAgIGluZGV4ZWREQixcbiAgICAgICAgICAgIElEQktleVJhbmdlLFxuICAgICAgICB9KTtcbiAgICAgICAgZGJOYW1lc0RCLnZlcnNpb24oMSkuc3RvcmVzKHsgZGJuYW1lczogXCJuYW1lXCIgfSk7XG4gICAgfVxuICAgIHJldHVybiBkYk5hbWVzREIudGFibGUoXCJkYm5hbWVzXCIpO1xufVxuZnVuY3Rpb24gaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikge1xuICAgIHJldHVybiBpbmRleGVkREIgJiYgdHlwZW9mIGluZGV4ZWREQi5kYXRhYmFzZXMgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGdldERhdGFiYXNlTmFtZXMoeyBpbmRleGVkREIsIElEQktleVJhbmdlLCB9KSB7XG4gICAgcmV0dXJuIGhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpXG4gICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKGluZGV4ZWREQi5kYXRhYmFzZXMoKSkudGhlbigoaW5mb3MpID0+IGluZm9zXG4gICAgICAgICAgICAubWFwKChpbmZvKSA9PiBpbmZvLm5hbWUpXG4gICAgICAgICAgICAuZmlsdGVyKChuYW1lKSA9PiBuYW1lICE9PSBEQk5BTUVTX0RCKSlcbiAgICAgICAgOiBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkudG9Db2xsZWN0aW9uKCkucHJpbWFyeUtleXMoKTtcbn1cbmZ1bmN0aW9uIF9vbkRhdGFiYXNlQ3JlYXRlZCh7IGluZGV4ZWREQiwgSURCS2V5UmFuZ2UgfSwgbmFtZSkge1xuICAgICFoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSAmJlxuICAgICAgICBuYW1lICE9PSBEQk5BTUVTX0RCICYmXG4gICAgICAgIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS5wdXQoeyBuYW1lIH0pLmNhdGNoKG5vcCk7XG59XG5mdW5jdGlvbiBfb25EYXRhYmFzZURlbGV0ZWQoeyBpbmRleGVkREIsIElEQktleVJhbmdlIH0sIG5hbWUpIHtcbiAgICAhaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikgJiZcbiAgICAgICAgbmFtZSAhPT0gREJOQU1FU19EQiAmJlxuICAgICAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkuZGVsZXRlKG5hbWUpLmNhdGNoKG5vcCk7XG59XG5cbmZ1bmN0aW9uIHZpcChmbikge1xuICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIFBTRC5sZXRUaHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGlkYlJlYWR5KCkge1xuICAgIHZhciBpc1NhZmFyaSA9ICFuYXZpZ2F0b3IudXNlckFnZW50RGF0YSAmJlxuICAgICAgICAvU2FmYXJpXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICEvQ2hyb20oZXxpdW0pXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmICghaXNTYWZhcmkgfHwgIWluZGV4ZWREQi5kYXRhYmFzZXMpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgaW50ZXJ2YWxJZDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHRyeUlkYiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4ZWREQi5kYXRhYmFzZXMoKS5maW5hbGx5KHJlc29sdmUpOyB9O1xuICAgICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodHJ5SWRiLCAxMDApO1xuICAgICAgICB0cnlJZGIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7IH0pO1xufVxuXG5mdW5jdGlvbiBkZXhpZU9wZW4oZGIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGRiLl9zdGF0ZTtcbiAgICBjb25zdCB7IGluZGV4ZWREQiB9ID0gZGIuX2RlcHM7XG4gICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQgfHwgZGIuaWRiZGIpXG4gICAgICAgIHJldHVybiBzdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKCgpID0+IHN0YXRlLmRiT3BlbkVycm9yID9cbiAgICAgICAgICAgIHJlamVjdGlvbihzdGF0ZS5kYk9wZW5FcnJvcikgOlxuICAgICAgICAgICAgZGIpO1xuICAgIGRlYnVnICYmIChzdGF0ZS5vcGVuQ2FuY2VsbGVyLl9zdGFja0hvbGRlciA9IGdldEVycm9yV2l0aFN0YWNrKCkpO1xuICAgIHN0YXRlLmlzQmVpbmdPcGVuZWQgPSB0cnVlO1xuICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbnVsbDtcbiAgICBzdGF0ZS5vcGVuQ29tcGxldGUgPSBmYWxzZTtcbiAgICBjb25zdCBvcGVuQ2FuY2VsbGVyID0gc3RhdGUub3BlbkNhbmNlbGxlcjtcbiAgICBmdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGVkKCkge1xuICAgICAgICBpZiAoc3RhdGUub3BlbkNhbmNlbGxlciAhPT0gb3BlbkNhbmNlbGxlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCdkYi5vcGVuKCkgd2FzIGNhbmNlbGxlZCcpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZURiUmVhZHkgPSBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSxcbiAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsLCB3YXNDcmVhdGVkID0gZmFsc2U7XG4gICAgY29uc3QgdHJ5T3BlbkRCID0gKCkgPT4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAgICAgaWYgKCFpbmRleGVkREIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG4gICAgICAgIGNvbnN0IGRiTmFtZSA9IGRiLm5hbWU7XG4gICAgICAgIGNvbnN0IHJlcSA9IHN0YXRlLmF1dG9TY2hlbWEgP1xuICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lKSA6XG4gICAgICAgICAgICBpbmRleGVkREIub3BlbihkYk5hbWUsIE1hdGgucm91bmQoZGIudmVybm8gKiAxMCkpO1xuICAgICAgICBpZiAoIXJlcSlcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgcmVxLm9uYmxvY2tlZCA9IHdyYXAoZGIuX2ZpcmVPbkJsb2NrZWQpO1xuICAgICAgICByZXEub251cGdyYWRlbmVlZGVkID0gd3JhcChlID0+IHtcbiAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IHJlcS50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hICYmICFkYi5fb3B0aW9ucy5hbGxvd0VtcHR5REIpIHtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IHByZXZlbnREZWZhdWx0O1xuICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHJlcS5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxyZXEgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTtcbiAgICAgICAgICAgICAgICBkZWxyZXEub25zdWNjZXNzID0gZGVscmVxLm9uZXJyb3IgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBleGNlcHRpb25zLk5vU3VjaERhdGFiYXNlKGBEYXRhYmFzZSAke2RiTmFtZX0gZG9lc250IGV4aXN0YCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmVyID0gZS5vbGRWZXJzaW9uID4gTWF0aC5wb3coMiwgNjIpID8gMCA6IGUub2xkVmVyc2lvbjtcbiAgICAgICAgICAgICAgICB3YXNDcmVhdGVkID0gb2xkVmVyIDwgMTtcbiAgICAgICAgICAgICAgICBkYi5fbm92aXAuaWRiZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgIHJ1blVwZ3JhZGVycyhkYiwgb2xkVmVyIC8gMTAsIHVwZ3JhZGVUcmFuc2FjdGlvbiwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoKCkgPT4ge1xuICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGlkYmRiID0gZGIuX25vdmlwLmlkYmRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzKTtcbiAgICAgICAgICAgIGlmIChvYmplY3RTdG9yZU5hbWVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wVHJhbnMgPSBpZGJkYi50cmFuc2FjdGlvbihzYWZhcmlNdWx0aVN0b3JlRml4KG9iamVjdFN0b3JlTmFtZXMpLCAncmVhZG9ubHknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBkYi5fZGJTY2hlbWEsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmVyaWZ5SW5zdGFsbGVkU2NoZW1hKGRiLCB0bXBUcmFucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYERleGllIFNjaGVtYURpZmY6IFNjaGVtYSB3YXMgZXh0ZW5kZWQgd2l0aG91dCBpbmNyZWFzaW5nIHRoZSBudW1iZXIgcGFzc2VkIHRvIGRiLnZlcnNpb24oKS4gU29tZSBxdWVyaWVzIG1heSBmYWlsLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgdG1wVHJhbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goZGIpO1xuICAgICAgICAgICAgaWRiZGIub252ZXJzaW9uY2hhbmdlID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmNGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZGJkYi5vbmNsb3NlID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICAgICAgZGIub24oXCJjbG9zZVwiKS5maXJlKGV2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHdhc0NyZWF0ZWQpXG4gICAgICAgICAgICAgICAgX29uRGF0YWJhc2VDcmVhdGVkKGRiLl9kZXBzLCBkYk5hbWUpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLm5hbWUgPT09ICdVbmtub3duRXJyb3InICYmIHN0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuICAgICAgICAgICAgc3RhdGUuUFIxMzk4X21heExvb3AtLTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IFdvcmthcm91bmQgZm9yIENocm9tZSBVbmtub3duRXJyb3Igb24gb3BlbigpJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ5T3BlbkRCKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIERleGllUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgb3BlbkNhbmNlbGxlcixcbiAgICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gRGV4aWVQcm9taXNlLnJlc29sdmUoKSA6IGlkYlJlYWR5KCkpLnRoZW4odHJ5T3BlbkRCKVxuICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKCk7XG4gICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG4gICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSh2aXAoKCkgPT4gZGIub24ucmVhZHkuZmlyZShkYi52aXApKSkudGhlbihmdW5jdGlvbiBmaXJlUmVtYWluZGVycygpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlbWFpbmRlcnMgPSBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5yZWR1Y2UocHJvbWlzYWJsZUNoYWluLCBub3ApO1xuICAgICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHZpcCgoKSA9PiByZW1haW5kZXJzKGRiLnZpcCkpKS50aGVuKGZpcmVSZW1haW5kZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gbnVsbDtcbiAgICAgICAgc3RhdGUuaXNCZWluZ09wZW5lZCA9IGZhbHNlO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gZGI7XG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBlcnI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gJiYgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgaWYgKG9wZW5DYW5jZWxsZXIgPT09IHN0YXRlLm9wZW5DYW5jZWxsZXIpIHtcbiAgICAgICAgICAgIGRiLl9jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3Rpb24oZXJyKTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgc3RhdGUub3BlbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZURiUmVhZHkoKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYXdhaXRJdGVyYXRvcihpdGVyYXRvcikge1xuICAgIHZhciBjYWxsTmV4dCA9IHJlc3VsdCA9PiBpdGVyYXRvci5uZXh0KHJlc3VsdCksIGRvVGhyb3cgPSBlcnJvciA9PiBpdGVyYXRvci50aHJvdyhlcnJvciksIG9uU3VjY2VzcyA9IHN0ZXAoY2FsbE5leHQpLCBvbkVycm9yID0gc3RlcChkb1Rocm93KTtcbiAgICBmdW5jdGlvbiBzdGVwKGdldE5leHQpIHtcbiAgICAgICAgcmV0dXJuICh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZ2V0TmV4dCh2YWwpLCB2YWx1ZSA9IG5leHQudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gbmV4dC5kb25lID8gdmFsdWUgOlxuICAgICAgICAgICAgICAgICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlLnRoZW4gIT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgICBpc0FycmF5KHZhbHVlKSA/IFByb21pc2UuYWxsKHZhbHVlKS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikgOiBvblN1Y2Nlc3ModmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ZXAoY2FsbE5leHQpKCk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MobW9kZSwgX3RhYmxlQXJnc18sIHNjb3BlRnVuYykge1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAoaSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIlRvbyBmZXcgYXJndW1lbnRzXCIpO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICB3aGlsZSAoLS1pKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICBzY29wZUZ1bmMgPSBhcmdzLnBvcCgpO1xuICAgIHZhciB0YWJsZXMgPSBmbGF0dGVuKGFyZ3MpO1xuICAgIHJldHVybiBbbW9kZSwgdGFibGVzLCBzY29wZUZ1bmNdO1xufVxuZnVuY3Rpb24gZW50ZXJUcmFuc2FjdGlvblNjb3BlKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBwYXJlbnRUcmFuc2FjdGlvbiwgc2NvcGVGdW5jKSB7XG4gICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuICAgICAgICBjb25zdCB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEsIHBhcmVudFRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3Qgem9uZVByb3BzID0ge1xuICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgdHJhbnNsZXNzOiB0cmFuc2xlc3NcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0cmFucy5pZGJ0cmFucyA9IHBhcmVudFRyYW5zYWN0aW9uLmlkYnRyYW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBkYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogTmVlZCB0byByZW9wZW4gZGInKTtcbiAgICAgICAgICAgICAgICAgICAgZGIuX2Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbigoKSA9PiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoZGIsIG1vZGUsIHN0b3JlTmFtZXMsIG51bGwsIHNjb3BlRnVuYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY29wZUZ1bmNJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKHNjb3BlRnVuYyk7XG4gICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICAgICAgY29uc3QgcHJvbWlzZUZvbGxvd2VkID0gRGV4aWVQcm9taXNlLmZvbGxvdygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHNjb3BlRnVuYy5jYWxsKHRyYW5zLCB0cmFucyk7XG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZS5uZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGF3YWl0SXRlcmF0b3IocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgem9uZVByb3BzKTtcbiAgICAgICAgcmV0dXJuIChyZXR1cm5WYWx1ZSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkudGhlbih4ID0+IHRyYW5zLmFjdGl2ZSA/XG4gICAgICAgICAgICAgICAgeFxuICAgICAgICAgICAgICAgIDogcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlByZW1hdHVyZUNvbW1pdChcIlRyYW5zYWN0aW9uIGNvbW1pdHRlZCB0b28gZWFybHkuIFNlZSBodHRwOi8vYml0Lmx5LzJrZGNrTW5cIikpKVxuICAgICAgICAgICAgOiBwcm9taXNlRm9sbG93ZWQudGhlbigoKSA9PiByZXR1cm5WYWx1ZSkpLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgdHJhbnMuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0cmFucy5fY29tcGxldGlvbi50aGVuKCgpID0+IHgpO1xuICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIHRyYW5zLl9yZWplY3QoZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFkKGEsIHZhbHVlLCBjb3VudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGlzQXJyYXkoYSkgPyBhLnNsaWNlKCkgOiBbYV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKVxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxJbmRleE1pZGRsZXdhcmUoZG93bikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRvd24sXG4gICAgICAgIHRhYmxlKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBkb3duLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gdGFibGU7XG4gICAgICAgICAgICBjb25zdCBpbmRleExvb2t1cCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgYWxsVmlydHVhbEluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFZpcnR1YWxJbmRleGVzKGtleVBhdGgsIGtleVRhaWwsIGxvd0xldmVsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlQYXRoQWxpYXMgPSBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhMaXN0ID0gKGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gPSBpbmRleExvb2t1cFtrZXlQYXRoQWxpYXNdIHx8IFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBrZXlQYXRoID09IG51bGwgPyAwIDogdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8gMSA6IGtleVBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmlydHVhbCA9IGtleVRhaWwgPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxJbmRleCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubG93TGV2ZWxJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNWaXJ0dWFsLFxuICAgICAgICAgICAgICAgICAgICBrZXlUYWlsLFxuICAgICAgICAgICAgICAgICAgICBrZXlMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiAhaXNWaXJ0dWFsICYmIGxvd0xldmVsSW5kZXgudW5pcXVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbmRleExpc3QucHVzaCh2aXJ0dWFsSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghdmlydHVhbEluZGV4LmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxWaXJ0dWFsSW5kZXhlcy5wdXNoKHZpcnR1YWxJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXlMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxLZXlQYXRoID0ga2V5TGVuZ3RoID09PSAyID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGhbMF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aC5zbGljZSgwLCBrZXlMZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmlydHVhbEluZGV4ZXModmlydHVhbEtleVBhdGgsIGtleVRhaWwgKyAxLCBsb3dMZXZlbEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXhMaXN0LnNvcnQoKGEsIGIpID0+IGEua2V5VGFpbCAtIGIua2V5VGFpbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByaW1hcnlLZXkgPSBhZGRWaXJ0dWFsSW5kZXhlcyhzY2hlbWEucHJpbWFyeUtleS5rZXlQYXRoLCAwLCBzY2hlbWEucHJpbWFyeUtleSk7XG4gICAgICAgICAgICBpbmRleExvb2t1cFtcIjppZFwiXSA9IFtwcmltYXJ5S2V5XTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2Ygc2NoZW1hLmluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICBhZGRWaXJ0dWFsSW5kZXhlcyhpbmRleC5rZXlQYXRoLCAwLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kQmVzdEluZGV4KGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbmRleExvb2t1cFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgJiYgcmVzdWx0WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNsYXRlUmFuZ2UocmFuZ2UsIGtleVRhaWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiByYW5nZS50eXBlID09PSAxICA/XG4gICAgICAgICAgICAgICAgICAgICAgICAyICA6XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBsb3dlcjogcGFkKHJhbmdlLmxvd2VyLCByYW5nZS5sb3dlck9wZW4gPyBkb3duLk1BWF9LRVkgOiBkb3duLk1JTl9LRVksIGtleVRhaWwpLFxuICAgICAgICAgICAgICAgICAgICBsb3dlck9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyOiBwYWQocmFuZ2UudXBwZXIsIHJhbmdlLnVwcGVyT3BlbiA/IGRvd24uTUlOX0tFWSA6IGRvd24uTUFYX0tFWSwga2V5VGFpbCksXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyT3BlbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSZXF1ZXN0KHJlcSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnF1ZXJ5LmluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleC5pc1ZpcnR1YWwgPyB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnJlcSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRyYW5zbGF0ZVJhbmdlKHJlcS5xdWVyeS5yYW5nZSwgaW5kZXgua2V5VGFpbClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gOiByZXE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgLi4udGFibGUsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlczogYWxsVmlydHVhbEluZGV4ZXMsXG4gICAgICAgICAgICAgICAgICAgIGdldEluZGV4QnlLZXlQYXRoOiBmaW5kQmVzdEluZGV4XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb3VudChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmNvdW50KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBxdWVyeShyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLnF1ZXJ5KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcGVuQ3Vyc29yKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtleVRhaWwsIGlzVmlydHVhbCwga2V5TGVuZ3RoIH0gPSByZXEucXVlcnkuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWaXJ0dWFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlVmlydHVhbEN1cnNvcihjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9jb250aW51ZShrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShwYWQoa2V5LCByZXEucmV2ZXJzZSA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnVuaXF1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoY3Vyc29yLmtleS5zbGljZSgwLCBrZXlMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyZXEucmV2ZXJzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZG93bi5NSU5fS0VZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxDdXJzb3IgPSBPYmplY3QuY3JlYXRlKGN1cnNvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiB7IHZhbHVlOiBfY29udGludWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUoa2V5LCBwcmltYXJ5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5KHBhZChrZXksIGRvd24uTUFYX0tFWSwga2V5VGFpbCksIHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5TGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlbMF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5zbGljZSgwLCBrZXlMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlydHVhbEN1cnNvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUub3BlbkN1cnNvcih0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihjdXJzb3IgPT4gY3Vyc29yICYmIGNyZWF0ZVZpcnR1YWxDdXJzb3IoY3Vyc29yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgdmlydHVhbEluZGV4TWlkZGxld2FyZSA9IHtcbiAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICBuYW1lOiBcIlZpcnR1YWxJbmRleE1pZGRsZXdhcmVcIixcbiAgICBsZXZlbDogMSxcbiAgICBjcmVhdGU6IGNyZWF0ZVZpcnR1YWxJbmRleE1pZGRsZXdhcmVcbn07XG5cbmZ1bmN0aW9uIGdldE9iamVjdERpZmYoYSwgYiwgcnYsIHByZngpIHtcbiAgICBydiA9IHJ2IHx8IHt9O1xuICAgIHByZnggPSBwcmZ4IHx8ICcnO1xuICAgIGtleXMoYSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAoIWhhc093bihiLCBwcm9wKSkge1xuICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFwID0gYVtwcm9wXSwgYnAgPSBiW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJwID09PSAnb2JqZWN0JyAmJiBhcCAmJiBicCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwVHlwZU5hbWUgPSB0b1N0cmluZ1RhZyhhcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGJwKTtcbiAgICAgICAgICAgICAgICBpZiAoYXBUeXBlTmFtZSAhPT0gYnBUeXBlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcFR5cGVOYW1lID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBnZXRPYmplY3REaWZmKGFwLCBicCwgcnYsIHByZnggKyBwcm9wICsgJy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKVxuICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBrZXlzKGIpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKCFoYXNPd24oYSwgcHJvcCkpIHtcbiAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcnY7XG59XG5cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZUtleXMocHJpbWFyeUtleSwgcmVxKSB7XG4gICAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlJylcbiAgICAgICAgcmV0dXJuIHJlcS5rZXlzO1xuICAgIHJldHVybiByZXEua2V5cyB8fCByZXEudmFsdWVzLm1hcChwcmltYXJ5S2V5LmV4dHJhY3RLZXkpO1xufVxuXG5jb25zdCBob29rc01pZGRsZXdhcmUgPSB7XG4gICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgbmFtZTogXCJIb29rc01pZGRsZXdhcmVcIixcbiAgICBsZXZlbDogMixcbiAgICBjcmVhdGU6IChkb3duQ29yZSkgPT4gKHtcbiAgICAgICAgLi4uZG93bkNvcmUsXG4gICAgICAgIHRhYmxlKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgZG93blRhYmxlID0gZG93bkNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJpbWFyeUtleSB9ID0gZG93blRhYmxlLnNjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlTWlkZGxld2FyZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5kb3duVGFibGUsXG4gICAgICAgICAgICAgICAgbXV0YXRlKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkeFRyYW5zID0gUFNELnRyYW5zO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0aW5nLCBjcmVhdGluZywgdXBkYXRpbmcgfSA9IGR4VHJhbnMudGFibGUodGFibGVOYW1lKS5ob29rO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlcS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCAoKSA9PiBhZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0aW5nLmZpcmUgPT09IG5vcCAmJiB1cGRhdGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCAoKSA9PiBhZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0aW5nLmZpcmUgPT09IG5vcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpID0+IGFkZFB1dE9yRGVsZXRlKHJlcSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlUmFuZ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCAoKSA9PiBkZWxldGVSYW5nZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRQdXRPckRlbGV0ZShyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR4VHJhbnMgPSBQU0QudHJhbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gcmVxLmtleXMgfHwgZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IHJlcS50eXBlID09PSAnYWRkJyB8fCByZXEudHlwZSA9PT0gJ3B1dCcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgLi4ucmVxLCBrZXlzIH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgLi4ucmVxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09ICdkZWxldGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXMgPSBbLi4ucmVxLnZhbHVlc107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLmtleXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmtleXMgPSBbLi4ucmVxLmtleXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmFsdWVzKGRvd25UYWJsZSwgcmVxLCBrZXlzKS50aGVuKGV4aXN0aW5nVmFsdWVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0cyA9IGtleXMubWFwKChrZXksIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IGV4aXN0aW5nVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB7IG9uZXJyb3I6IG51bGwsIG9uc3VjY2VzczogbnVsbCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGluZy5maXJlLmNhbGwoY3R4LCBrZXksIGV4aXN0aW5nVmFsdWUsIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcS50eXBlID09PSAnYWRkJyB8fCBleGlzdGluZ1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZFByaW1hcnlLZXkgPSBjcmVhdGluZy5maXJlLmNhbGwoY3R4LCBrZXksIHJlcS52YWx1ZXNbaV0sIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsICYmIGdlbmVyYXRlZFByaW1hcnlLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGdlbmVyYXRlZFByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmtleXNbaV0gPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5Lm91dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChyZXEudmFsdWVzW2ldLCBwcmltYXJ5S2V5LmtleVBhdGgsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0RGlmZiA9IGdldE9iamVjdERpZmYoZXhpc3RpbmdWYWx1ZSwgcmVxLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsQ2hhbmdlcyA9IHVwZGF0aW5nLmZpcmUuY2FsbChjdHgsIG9iamVjdERpZmYsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRWYWx1ZSA9IHJlcS52YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYWRkaXRpb25hbENoYW5nZXMpLmZvckVhY2goa2V5UGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24ocmVxdWVzdGVkVmFsdWUsIGtleVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRWYWx1ZVtrZXlQYXRoXSA9IGFkZGl0aW9uYWxDaGFuZ2VzW2tleVBhdGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcXVlc3RlZFZhbHVlLCBrZXlQYXRoLCBhZGRpdGlvbmFsQ2hhbmdlc1trZXlQYXRoXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSkudGhlbigoeyBmYWlsdXJlcywgcmVzdWx0cywgbnVtRmFpbHVyZXMsIGxhc3RSZXN1bHQgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaW1LZXkgPSByZXN1bHRzID8gcmVzdWx0c1tpXSA6IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjb250ZXh0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihmYWlsdXJlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgub25zdWNjZXNzICYmIGN0eC5vbnN1Y2Nlc3MocmVxLnR5cGUgPT09ICdwdXQnICYmIGV4aXN0aW5nVmFsdWVzW2ldID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlc1tpXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1LZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZhaWx1cmVzLCByZXN1bHRzLCBudW1GYWlsdXJlcywgbGFzdFJlc3VsdCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dHMuZm9yRWFjaChjdHggPT4gY3R4Lm9uZXJyb3IgJiYgY3R4Lm9uZXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZVJhbmdlKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZU5leHRDaHVuayhyZXEudHJhbnMsIHJlcS5yYW5nZSwgMTAwMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZU5leHRDaHVuayh0cmFucywgcmFuZ2UsIGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLnF1ZXJ5KHsgdHJhbnMsIHZhbHVlczogZmFsc2UsIHF1ZXJ5OiB7IGluZGV4OiBwcmltYXJ5S2V5LCByYW5nZSB9LCBsaW1pdCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCh7IHJlc3VsdCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHsgdHlwZTogJ2RlbGV0ZScsIGtleXM6IHJlc3VsdCwgdHJhbnMgfSkudGhlbihyZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWlsdXJlczogW10sIG51bUZhaWx1cmVzOiAwLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxldGVOZXh0Q2h1bmsodHJhbnMsIHsgLi4ucmFuZ2UsIGxvd2VyOiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsb3dlck9wZW46IHRydWUgfSwgbGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGFibGVNaWRkbGV3YXJlO1xuICAgICAgICB9LFxuICAgIH0pXG59O1xuZnVuY3Rpb24gZ2V0RXhpc3RpbmdWYWx1ZXModGFibGUsIHJlcSwgZWZmZWN0aXZlS2V5cykge1xuICAgIHJldHVybiByZXEudHlwZSA9PT0gXCJhZGRcIlxuICAgICAgICA/IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICAgICAgOiB0YWJsZS5nZXRNYW55KHsgdHJhbnM6IHJlcS50cmFucywga2V5czogZWZmZWN0aXZlS2V5cywgY2FjaGU6IFwiaW1tdXRhYmxlXCIgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIGNhY2hlLCBjbG9uZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghY2FjaGUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGNhY2hlLmtleXMubGVuZ3RoIDwga2V5cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGNhY2hlLmtleXMubGVuZ3RoICYmIGogPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY21wKGNhY2hlLmtleXNbaV0sIGtleXNbal0pICE9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2xvbmUgPyBkZWVwQ2xvbmUoY2FjaGUudmFsdWVzW2ldKSA6IGNhY2hlLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IGtleXMubGVuZ3RoID8gcmVzdWx0IDogbnVsbDtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNvbnN0IGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlID0ge1xuICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgIGxldmVsOiAtMSxcbiAgICBjcmVhdGU6IChjb3JlKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWJsZTogKHRhYmxlTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhYmxlLFxuICAgICAgICAgICAgICAgICAgICBnZXRNYW55OiAocmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcS5jYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5nZXRNYW55KHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRSZXN1bHQgPSBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShyZXEua2V5cywgcmVxLnRyYW5zW1wiX2NhY2hlXCJdLCByZXEuY2FjaGUgPT09IFwiY2xvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS50cmFuc1tcIl9jYWNoZVwiXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogcmVxLmtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogcmVxLmNhY2hlID09PSBcImNsb25lXCIgPyBkZWVwQ2xvbmUocmVzKSA6IHJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlOiAocmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09IFwiYWRkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5tdXRhdGUocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZnVuY3Rpb24gaXNFbXB0eVJhbmdlKG5vZGUpIHtcbiAgICByZXR1cm4gIShcImZyb21cIiBpbiBub2RlKTtcbn1cbmNvbnN0IFJhbmdlU2V0ID0gZnVuY3Rpb24gKGZyb21PclRyZWUsIHRvKSB7XG4gICAgaWYgKHRoaXMpIHtcbiAgICAgICAgZXh0ZW5kKHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyB7IGQ6IDEsIGZyb206IGZyb21PclRyZWUsIHRvOiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRvIDogZnJvbU9yVHJlZSB9IDogeyBkOiAwIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcnYgPSBuZXcgUmFuZ2VTZXQoKTtcbiAgICAgICAgaWYgKGZyb21PclRyZWUgJiYgKFwiZFwiIGluIGZyb21PclRyZWUpKSB7XG4gICAgICAgICAgICBleHRlbmQocnYsIGZyb21PclRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG59O1xucHJvcHMoUmFuZ2VTZXQucHJvdG90eXBlLCB7XG4gICAgYWRkKHJhbmdlU2V0KSB7XG4gICAgICAgIG1lcmdlUmFuZ2VzKHRoaXMsIHJhbmdlU2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZGRLZXkoa2V5KSB7XG4gICAgICAgIGFkZFJhbmdlKHRoaXMsIGtleSwga2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZGRLZXlzKGtleXMpIHtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRSYW5nZSh0aGlzLCBrZXksIGtleSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIFtpdGVyYXRvclN5bWJvbF0oKSB7XG4gICAgICAgIHJldHVybiBnZXRSYW5nZVNldEl0ZXJhdG9yKHRoaXMpO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gYWRkUmFuZ2UodGFyZ2V0LCBmcm9tLCB0bykge1xuICAgIGNvbnN0IGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xuICAgIGlmIChpc05hTihkaWZmKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkaWZmID4gMClcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigpO1xuICAgIGlmIChpc0VtcHR5UmFuZ2UodGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh0YXJnZXQsIHsgZnJvbSwgdG8sIGQ6IDEgfSk7XG4gICAgY29uc3QgbGVmdCA9IHRhcmdldC5sO1xuICAgIGNvbnN0IHJpZ2h0ID0gdGFyZ2V0LnI7XG4gICAgaWYgKGNtcCh0bywgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgICAgICBsZWZ0XG4gICAgICAgICAgICA/IGFkZFJhbmdlKGxlZnQsIGZyb20sIHRvKVxuICAgICAgICAgICAgOiAodGFyZ2V0LmwgPSB7IGZyb20sIHRvLCBkOiAxLCBsOiBudWxsLCByOiBudWxsIH0pO1xuICAgICAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gICAgfVxuICAgIGlmIChjbXAoZnJvbSwgdGFyZ2V0LnRvKSA+IDApIHtcbiAgICAgICAgcmlnaHRcbiAgICAgICAgICAgID8gYWRkUmFuZ2UocmlnaHQsIGZyb20sIHRvKVxuICAgICAgICAgICAgOiAodGFyZ2V0LnIgPSB7IGZyb20sIHRvLCBkOiAxLCBsOiBudWxsLCByOiBudWxsIH0pO1xuICAgICAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gICAgfVxuICAgIGlmIChjbXAoZnJvbSwgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgICAgICB0YXJnZXQuZnJvbSA9IGZyb207XG4gICAgICAgIHRhcmdldC5sID0gbnVsbDtcbiAgICAgICAgdGFyZ2V0LmQgPSByaWdodCA/IHJpZ2h0LmQgKyAxIDogMTtcbiAgICB9XG4gICAgaWYgKGNtcCh0bywgdGFyZ2V0LnRvKSA+IDApIHtcbiAgICAgICAgdGFyZ2V0LnRvID0gdG87XG4gICAgICAgIHRhcmdldC5yID0gbnVsbDtcbiAgICAgICAgdGFyZ2V0LmQgPSB0YXJnZXQubCA/IHRhcmdldC5sLmQgKyAxIDogMTtcbiAgICB9XG4gICAgY29uc3QgcmlnaHRXYXNDdXRPZmYgPSAhdGFyZ2V0LnI7XG4gICAgaWYgKGxlZnQgJiYgIXRhcmdldC5sKSB7XG4gICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldCwgbGVmdCk7XG4gICAgfVxuICAgIGlmIChyaWdodCAmJiByaWdodFdhc0N1dE9mZikge1xuICAgICAgICBtZXJnZVJhbmdlcyh0YXJnZXQsIHJpZ2h0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVJhbmdlcyh0YXJnZXQsIG5ld1NldCkge1xuICAgIGZ1bmN0aW9uIF9hZGRSYW5nZVNldCh0YXJnZXQsIHsgZnJvbSwgdG8sIGwsIHIgfSkge1xuICAgICAgICBhZGRSYW5nZSh0YXJnZXQsIGZyb20sIHRvKTtcbiAgICAgICAgaWYgKGwpXG4gICAgICAgICAgICBfYWRkUmFuZ2VTZXQodGFyZ2V0LCBsKTtcbiAgICAgICAgaWYgKHIpXG4gICAgICAgICAgICBfYWRkUmFuZ2VTZXQodGFyZ2V0LCByKTtcbiAgICB9XG4gICAgaWYgKCFpc0VtcHR5UmFuZ2UobmV3U2V0KSlcbiAgICAgICAgX2FkZFJhbmdlU2V0KHRhcmdldCwgbmV3U2V0KTtcbn1cbmZ1bmN0aW9uIHJhbmdlc092ZXJsYXAocmFuZ2VTZXQxLCByYW5nZVNldDIpIHtcbiAgICBjb25zdCBpMSA9IGdldFJhbmdlU2V0SXRlcmF0b3IocmFuZ2VTZXQyKTtcbiAgICBsZXQgbmV4dFJlc3VsdDEgPSBpMS5uZXh0KCk7XG4gICAgaWYgKG5leHRSZXN1bHQxLmRvbmUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYSA9IG5leHRSZXN1bHQxLnZhbHVlO1xuICAgIGNvbnN0IGkyID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDEpO1xuICAgIGxldCBuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKTtcbiAgICBsZXQgYiA9IG5leHRSZXN1bHQyLnZhbHVlO1xuICAgIHdoaWxlICghbmV4dFJlc3VsdDEuZG9uZSAmJiAhbmV4dFJlc3VsdDIuZG9uZSkge1xuICAgICAgICBpZiAoY21wKGIuZnJvbSwgYS50bykgPD0gMCAmJiBjbXAoYi50bywgYS5mcm9tKSA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNtcChhLmZyb20sIGIuZnJvbSkgPCAwXG4gICAgICAgICAgICA/IChhID0gKG5leHRSZXN1bHQxID0gaTEubmV4dChiLmZyb20pKS52YWx1ZSlcbiAgICAgICAgICAgIDogKGIgPSAobmV4dFJlc3VsdDIgPSBpMi5uZXh0KGEuZnJvbSkpLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UmFuZ2VTZXRJdGVyYXRvcihub2RlKSB7XG4gICAgbGV0IHN0YXRlID0gaXNFbXB0eVJhbmdlKG5vZGUpID8gbnVsbCA6IHsgczogMCwgbjogbm9kZSB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBrZXlQcm92aWRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgd2hpbGUgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZS5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVByb3ZpZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLm4ubCAmJiBjbXAoa2V5LCBzdGF0ZS5uLmZyb20pIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5sLCBzOiAxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLmwsIHM6IDEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleVByb3ZpZGVkIHx8IGNtcChrZXksIHN0YXRlLm4udG8pIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHN0YXRlLm4sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5uLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLnIsIHM6IDAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS51cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlYmFsYW5jZSh0YXJnZXQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRpZmYgPSAoKChfYSA9IHRhcmdldC5yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZCkgfHwgMCkgLSAoKChfYiA9IHRhcmdldC5sKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZCkgfHwgMCk7XG4gICAgY29uc3QgciA9IGRpZmYgPiAxID8gXCJyXCIgOiBkaWZmIDwgLTEgPyBcImxcIiA6IFwiXCI7XG4gICAgaWYgKHIpIHtcbiAgICAgICAgY29uc3QgbCA9IHIgPT09IFwiclwiID8gXCJsXCIgOiBcInJcIjtcbiAgICAgICAgY29uc3Qgcm9vdENsb25lID0geyAuLi50YXJnZXQgfTtcbiAgICAgICAgY29uc3Qgb2xkUm9vdFJpZ2h0ID0gdGFyZ2V0W3JdO1xuICAgICAgICB0YXJnZXQuZnJvbSA9IG9sZFJvb3RSaWdodC5mcm9tO1xuICAgICAgICB0YXJnZXQudG8gPSBvbGRSb290UmlnaHQudG87XG4gICAgICAgIHRhcmdldFtyXSA9IG9sZFJvb3RSaWdodFtyXTtcbiAgICAgICAgcm9vdENsb25lW3JdID0gb2xkUm9vdFJpZ2h0W2xdO1xuICAgICAgICB0YXJnZXRbbF0gPSByb290Q2xvbmU7XG4gICAgICAgIHJvb3RDbG9uZS5kID0gY29tcHV0ZURlcHRoKHJvb3RDbG9uZSk7XG4gICAgfVxuICAgIHRhcmdldC5kID0gY29tcHV0ZURlcHRoKHRhcmdldCk7XG59XG5mdW5jdGlvbiBjb21wdXRlRGVwdGgoeyByLCBsIH0pIHtcbiAgICByZXR1cm4gKHIgPyAobCA/IE1hdGgubWF4KHIuZCwgbC5kKSA6IHIuZCkgOiBsID8gbC5kIDogMCkgKyAxO1xufVxuXG5jb25zdCBvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSA9IHtcbiAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICBsZXZlbDogMCxcbiAgICBjcmVhdGU6IChjb3JlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRiTmFtZSA9IGNvcmUuc2NoZW1hLm5hbWU7XG4gICAgICAgIGNvbnN0IEZVTExfUkFOR0UgPSBuZXcgUmFuZ2VTZXQoY29yZS5NSU5fS0VZLCBjb3JlLk1BWF9LRVkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29yZSxcbiAgICAgICAgICAgIHRhYmxlOiAodGFibGVOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHRhYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJpbWFyeUtleSB9ID0gc2NoZW1hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXh0cmFjdEtleSwgb3V0Ym91bmQgfSA9IHByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGVDbG9uZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGFibGUsXG4gICAgICAgICAgICAgICAgICAgIG11dGF0ZTogKHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnMgPSByZXEudHJhbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtdXRhdGVkUGFydHMgPSB0cmFucy5tdXRhdGVkUGFydHMgfHwgKHRyYW5zLm11dGF0ZWRQYXJ0cyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldFJhbmdlU2V0ID0gKGluZGV4TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBgaWRiOi8vJHtkYk5hbWV9LyR7dGFibGVOYW1lfS8ke2luZGV4TmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobXV0YXRlZFBhcnRzW3BhcnRdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtdXRhdGVkUGFydHNbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBrUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbHNSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHJlcTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBba2V5cywgbmV3T2Jqc10gPSByZXEudHlwZSA9PT0gXCJkZWxldGVSYW5nZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcmVxLnJhbmdlXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxLnR5cGUgPT09IFwiZGVsZXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcmVxLmtleXNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxLnZhbHVlcy5sZW5ndGggPCA1MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbW10sIHJlcS52YWx1ZXNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkQ2FjaGUgPSByZXEudHJhbnNbXCJfY2FjaGVcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUubXV0YXRlKHJlcSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IFwiZGVsZXRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzID0gcmVzLnJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkT2JqcyA9IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIG9sZENhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRPYmpzICYmIHR5cGUgIT09IFwiYWRkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRPYmpzIHx8IG5ld09ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrQWZmZWN0ZWRJbmRleGVzKGdldFJhbmdlU2V0LCBzY2hlbWEsIG9sZE9ianMsIG5ld09ianMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7IGZyb206IGtleXMubG93ZXIsIHRvOiBrZXlzLnVwcGVyIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChpZHggPT4gZ2V0UmFuZ2VTZXQoaWR4Lm5hbWUpLmFkZChGVUxMX1JBTkdFKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldFJhbmdlID0gKHsgcXVlcnk6IHsgaW5kZXgsIHJhbmdlIH0sIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJhbmdlU2V0KChfYSA9IHJhbmdlLmxvd2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb3JlLk1JTl9LRVksIChfYiA9IHJhbmdlLnVwcGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb3JlLk1BWF9LRVkpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZFN1YnNjcmliZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IChyZXEpID0+IFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQocmVxLmtleSldLFxuICAgICAgICAgICAgICAgICAgICBnZXRNYW55OiAocmVxKSA9PiBbcHJpbWFyeUtleSwgbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhyZXEua2V5cyldLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogZ2V0UmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBnZXRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlbkN1cnNvcjogZ2V0UmFuZ2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBrZXlzKHJlYWRTdWJzY3JpYmVycykuZm9yRWFjaChtZXRob2QgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsb25lW21ldGhvZF0gPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN1YnNjciB9ID0gUFNEO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldFJhbmdlU2V0ID0gKGluZGV4TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gYGlkYjovLyR7ZGJOYW1lfS8ke3RhYmxlTmFtZX0vJHtpbmRleE5hbWV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzdWJzY3JbcGFydF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdWJzY3JbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGtSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbHNSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3F1ZXJpZWRJbmRleCwgcXVlcmllZFJhbmdlc10gPSByZWFkU3Vic2NyaWJlcnNbbWV0aG9kXShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJhbmdlU2V0KHF1ZXJpZWRJbmRleC5uYW1lIHx8IFwiXCIpLmFkZChxdWVyaWVkUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXJpZWRJbmRleC5pc1ByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjb3VudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkKEZVTExfUkFOR0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5c1Byb21pc2UgPSBtZXRob2QgPT09IFwicXVlcnlcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInF1ZXJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kICYmIHJlcS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzUHJvbWlzZS50aGVuKCh7IHJlc3VsdDogcmVzdWx0aW5nS2V5cyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHJlc3VsdGluZ0tleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwS2V5cyA9IHJlcS52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzLnJlc3VsdC5tYXAoZXh0cmFjdEtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhwS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5cyhwS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSBcIm9wZW5DdXJzb3JcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhbnRWYWx1ZXMgPSByZXEudmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGN1cnNvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShjdXJzb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZEtleShjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGtleSA9IGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZEtleShwa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwa2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FudFZhbHVlcyAmJiBwa1JhbmdlU2V0LmFkZEtleShjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlQ2xvbmU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdHJhY2tBZmZlY3RlZEluZGV4ZXMoZ2V0UmFuZ2VTZXQsIHNjaGVtYSwgb2xkT2JqcywgbmV3T2Jqcykge1xuICAgIGZ1bmN0aW9uIGFkZEFmZmVjdGVkSW5kZXgoaXgpIHtcbiAgICAgICAgY29uc3QgcmFuZ2VTZXQgPSBnZXRSYW5nZVNldChpeC5uYW1lIHx8IFwiXCIpO1xuICAgICAgICBmdW5jdGlvbiBleHRyYWN0S2V5KG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8gaXguZXh0cmFjdEtleShvYmopIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRLZXlPcktleXMgPSAoa2V5KSA9PiBpeC5tdWx0aUVudHJ5ICYmIGlzQXJyYXkoa2V5KVxuICAgICAgICAgICAgPyBrZXkuZm9yRWFjaChrZXkgPT4gcmFuZ2VTZXQuYWRkS2V5KGtleSkpXG4gICAgICAgICAgICA6IHJhbmdlU2V0LmFkZEtleShrZXkpO1xuICAgICAgICAob2xkT2JqcyB8fCBuZXdPYmpzKS5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRLZXkgPSBvbGRPYmpzICYmIGV4dHJhY3RLZXkob2xkT2Jqc1tpXSk7XG4gICAgICAgICAgICBjb25zdCBuZXdLZXkgPSBuZXdPYmpzICYmIGV4dHJhY3RLZXkobmV3T2Jqc1tpXSk7XG4gICAgICAgICAgICBpZiAoY21wKG9sZEtleSwgbmV3S2V5KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRLZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYWRkS2V5T3JLZXlzKG9sZEtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0tleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBhZGRLZXlPcktleXMobmV3S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVtYS5pbmRleGVzLmZvckVhY2goYWRkQWZmZWN0ZWRJbmRleCk7XG59XG5cbmNsYXNzIERleGllJDEge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fbWlkZGxld2FyZXMgPSB7fTtcbiAgICAgICAgdGhpcy52ZXJubyA9IDA7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBEZXhpZSQxLmRlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhZGRvbnM6IERleGllJDEuYWRkb25zLFxuICAgICAgICAgICAgYXV0b09wZW46IHRydWUsXG4gICAgICAgICAgICBpbmRleGVkREI6IGRlcHMuaW5kZXhlZERCLFxuICAgICAgICAgICAgSURCS2V5UmFuZ2U6IGRlcHMuSURCS2V5UmFuZ2UsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RlcHMgPSB7XG4gICAgICAgICAgICBpbmRleGVkREI6IG9wdGlvbnMuaW5kZXhlZERCLFxuICAgICAgICAgICAgSURCS2V5UmFuZ2U6IG9wdGlvbnMuSURCS2V5UmFuZ2VcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBhZGRvbnMsIH0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9kYlNjaGVtYSA9IHt9O1xuICAgICAgICB0aGlzLl92ZXJzaW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9zdG9yZU5hbWVzID0gW107XG4gICAgICAgIHRoaXMuX2FsbFRhYmxlcyA9IHt9O1xuICAgICAgICB0aGlzLmlkYmRiID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbm92aXAgPSB0aGlzO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGRiT3BlbkVycm9yOiBudWxsLFxuICAgICAgICAgICAgaXNCZWluZ09wZW5lZDogZmFsc2UsXG4gICAgICAgICAgICBvblJlYWR5QmVpbmdGaXJlZDogbnVsbCxcbiAgICAgICAgICAgIG9wZW5Db21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICBkYlJlYWR5UmVzb2x2ZTogbm9wLFxuICAgICAgICAgICAgZGJSZWFkeVByb21pc2U6IG51bGwsXG4gICAgICAgICAgICBjYW5jZWxPcGVuOiBub3AsXG4gICAgICAgICAgICBvcGVuQ2FuY2VsbGVyOiBudWxsLFxuICAgICAgICAgICAgYXV0b1NjaGVtYTogdHJ1ZSxcbiAgICAgICAgICAgIFBSMTM5OF9tYXhMb29wOiAzXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlID0gbmV3IERleGllUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLm9wZW5DYW5jZWxsZXIgPSBuZXcgRGV4aWVQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm9uID0gRXZlbnRzKHRoaXMsIFwicG9wdWxhdGVcIiwgXCJibG9ja2VkXCIsIFwidmVyc2lvbmNoYW5nZVwiLCBcImNsb3NlXCIsIHsgcmVhZHk6IFtwcm9taXNhYmxlQ2hhaW4sIG5vcF0gfSk7XG4gICAgICAgIHRoaXMub24ucmVhZHkuc3Vic2NyaWJlID0gb3ZlcnJpZGUodGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUsIHN1YnNjcmliZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHN1YnNjcmliZXIsIGJTdGlja3kpID0+IHtcbiAgICAgICAgICAgICAgICBEZXhpZSQxLnZpcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5vcGVuQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuZGJPcGVuRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUoKS50aGVuKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJTdGlja3kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJTdGlja3kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiU3RpY2t5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIub24ucmVhZHkudW5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHVuc3Vic2NyaWJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuQ29sbGVjdGlvbiA9IGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgdGhpcy5UYWJsZSA9IGNyZWF0ZVRhYmxlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIHRoaXMuVHJhbnNhY3Rpb24gPSBjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLlZlcnNpb24gPSBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIHRoaXMuV2hlcmVDbGF1c2UgPSBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLm9uKFwidmVyc2lvbmNoYW5nZVwiLCBldiA9PiB7XG4gICAgICAgICAgICBpZiAoZXYubmV3VmVyc2lvbiA+IDApXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gdXBncmFkZSBkYXRhYmFzZSAnJHt0aGlzLm5hbWV9Jy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSB1cGdyYWRlLmApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIGRlbGV0ZSBkYXRhYmFzZSAnJHt0aGlzLm5hbWV9Jy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSBkZWxldGUgcmVxdWVzdC5gKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oXCJibG9ja2VkXCIsIGV2ID0+IHtcbiAgICAgICAgICAgIGlmICghZXYubmV3VmVyc2lvbiB8fCBldi5uZXdWZXJzaW9uIDwgZXYub2xkVmVyc2lvbilcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYERleGllLmRlbGV0ZSgnJHt0aGlzLm5hbWV9Jykgd2FzIGJsb2NrZWRgKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVwZ3JhZGUgJyR7dGhpcy5uYW1lfScgYmxvY2tlZCBieSBvdGhlciBjb25uZWN0aW9uIGhvbGRpbmcgdmVyc2lvbiAke2V2Lm9sZFZlcnNpb24gLyAxMH1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21heEtleSA9IGdldE1heEtleShvcHRpb25zLklEQktleVJhbmdlKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlVHJhbnNhY3Rpb24gPSAobW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIHBhcmVudFRyYW5zYWN0aW9uKSA9PiBuZXcgdGhpcy5UcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgdGhpcy5fb3B0aW9ucy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksIHBhcmVudFRyYW5zYWN0aW9uKTtcbiAgICAgICAgdGhpcy5fZmlyZU9uQmxvY2tlZCA9IGV2ID0+IHtcbiAgICAgICAgICAgIHRoaXMub24oXCJibG9ja2VkXCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgY29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGMgPT4gYy5uYW1lID09PSB0aGlzLm5hbWUgJiYgYyAhPT0gdGhpcyAmJiAhYy5fc3RhdGUudmNGaXJlZClcbiAgICAgICAgICAgICAgICAubWFwKGMgPT4gYy5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldikpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVzZSh2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlKTtcbiAgICAgICAgdGhpcy51c2UoaG9va3NNaWRkbGV3YXJlKTtcbiAgICAgICAgdGhpcy51c2Uob2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUpO1xuICAgICAgICB0aGlzLnVzZShjYWNoZUV4aXN0aW5nVmFsdWVzTWlkZGxld2FyZSk7XG4gICAgICAgIHRoaXMudmlwID0gT2JqZWN0LmNyZWF0ZSh0aGlzLCB7IF92aXA6IHsgdmFsdWU6IHRydWUgfSB9KTtcbiAgICAgICAgYWRkb25zLmZvckVhY2goYWRkb24gPT4gYWRkb24odGhpcykpO1xuICAgIH1cbiAgICB2ZXJzaW9uKHZlcnNpb25OdW1iZXIpIHtcbiAgICAgICAgaWYgKGlzTmFOKHZlcnNpb25OdW1iZXIpIHx8IHZlcnNpb25OdW1iZXIgPCAwLjEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5UeXBlKGBHaXZlbiB2ZXJzaW9uIGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlcmApO1xuICAgICAgICB2ZXJzaW9uTnVtYmVyID0gTWF0aC5yb3VuZCh2ZXJzaW9uTnVtYmVyICogMTApIC8gMTA7XG4gICAgICAgIGlmICh0aGlzLmlkYmRiIHx8IHRoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJDYW5ub3QgYWRkIHZlcnNpb24gd2hlbiBkYXRhYmFzZSBpcyBvcGVuXCIpO1xuICAgICAgICB0aGlzLnZlcm5vID0gTWF0aC5tYXgodGhpcy52ZXJubywgdmVyc2lvbk51bWJlcik7XG4gICAgICAgIGNvbnN0IHZlcnNpb25zID0gdGhpcy5fdmVyc2lvbnM7XG4gICAgICAgIHZhciB2ZXJzaW9uSW5zdGFuY2UgPSB2ZXJzaW9ucy5maWx0ZXIodiA9PiB2Ll9jZmcudmVyc2lvbiA9PT0gdmVyc2lvbk51bWJlcilbMF07XG4gICAgICAgIGlmICh2ZXJzaW9uSW5zdGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgICAgICB2ZXJzaW9uSW5zdGFuY2UgPSBuZXcgdGhpcy5WZXJzaW9uKHZlcnNpb25OdW1iZXIpO1xuICAgICAgICB2ZXJzaW9ucy5wdXNoKHZlcnNpb25JbnN0YW5jZSk7XG4gICAgICAgIHZlcnNpb25zLnNvcnQobG93ZXJWZXJzaW9uRmlyc3QpO1xuICAgICAgICB2ZXJzaW9uSW5zdGFuY2Uuc3RvcmVzKHt9KTtcbiAgICAgICAgdGhpcy5fc3RhdGUuYXV0b1NjaGVtYSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgIH1cbiAgICBfd2hlblJlYWR5KGZuKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZGJkYiAmJiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlIHx8IFBTRC5sZXRUaHJvdWdoIHx8IHRoaXMuX3ZpcCkpID8gZm4oKSA6IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQodGhpcy5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5hdXRvT3Blbikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuKCkuY2F0Y2gobm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkudGhlbihmbik7XG4gICAgfVxuICAgIHVzZSh7IHN0YWNrLCBjcmVhdGUsIGxldmVsLCBuYW1lIH0pIHtcbiAgICAgICAgaWYgKG5hbWUpXG4gICAgICAgICAgICB0aGlzLnVudXNlKHsgc3RhY2ssIG5hbWUgfSk7XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdIHx8ICh0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gPSBbXSk7XG4gICAgICAgIG1pZGRsZXdhcmVzLnB1c2goeyBzdGFjaywgY3JlYXRlLCBsZXZlbDogbGV2ZWwgPT0gbnVsbCA/IDEwIDogbGV2ZWwsIG5hbWUgfSk7XG4gICAgICAgIG1pZGRsZXdhcmVzLnNvcnQoKGEsIGIpID0+IGEubGV2ZWwgLSBiLmxldmVsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVudXNlKHsgc3RhY2ssIG5hbWUsIGNyZWF0ZSB9KSB7XG4gICAgICAgIGlmIChzdGFjayAmJiB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10pIHtcbiAgICAgICAgICAgIHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXS5maWx0ZXIobXcgPT4gY3JlYXRlID8gbXcuY3JlYXRlICE9PSBjcmVhdGUgOlxuICAgICAgICAgICAgICAgIG5hbWUgPyBtdy5uYW1lICE9PSBuYW1lIDpcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcGVuKCkge1xuICAgICAgICByZXR1cm4gZGV4aWVPcGVuKHRoaXMpO1xuICAgIH1cbiAgICBfY2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGNvbnN0IGlkeCA9IGNvbm5lY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGlmIChpZHggPj0gMClcbiAgICAgICAgICAgIGNvbm5lY3Rpb25zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICBpZiAodGhpcy5pZGJkYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkYmRiLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB0aGlzLl9ub3ZpcC5pZGJkYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UgPSBuZXcgRGV4aWVQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUub3BlbkNhbmNlbGxlciA9IG5ldyBEZXhpZVByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLl9jbG9zZSgpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICB0aGlzLl9vcHRpb25zLmF1dG9PcGVuID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKTtcbiAgICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQpXG4gICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuKHN0YXRlLmRiT3BlbkVycm9yKTtcbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICBjb25zdCBoYXNBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9EZWxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHZhciByZXEgPSB0aGlzLl9kZXBzLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZSh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgX29uRGF0YWJhc2VEZWxldGVkKHRoaXMuX2RlcHMsIHRoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIHJlcS5vbmJsb2NrZWQgPSB0aGlzLl9maXJlT25CbG9ja2VkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoYXNBcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG5vdCBhbGxvd2VkIGluIGRiLmRlbGV0ZSgpXCIpO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKGRvRGVsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvRGVsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBiYWNrZW5kREIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkYmRiO1xuICAgIH1cbiAgICBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkYmRiICE9PSBudWxsO1xuICAgIH1cbiAgICBoYXNCZWVuQ2xvc2VkKCkge1xuICAgICAgICBjb25zdCBkYk9wZW5FcnJvciA9IHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgICAgICByZXR1cm4gZGJPcGVuRXJyb3IgJiYgKGRiT3BlbkVycm9yLm5hbWUgPT09ICdEYXRhYmFzZUNsb3NlZCcpO1xuICAgIH1cbiAgICBoYXNGYWlsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvciAhPT0gbnVsbDtcbiAgICB9XG4gICAgZHluYW1pY2FsbHlPcGVuZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hO1xuICAgIH1cbiAgICBnZXQgdGFibGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyh0aGlzLl9hbGxUYWJsZXMpLm1hcChuYW1lID0+IHRoaXMuX2FsbFRhYmxlc1tuYW1lXSk7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gZXh0cmFjdFRyYW5zYWN0aW9uQXJncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIF90cmFuc2FjdGlvbihtb2RlLCB0YWJsZXMsIHNjb3BlRnVuYykge1xuICAgICAgICBsZXQgcGFyZW50VHJhbnNhY3Rpb24gPSBQU0QudHJhbnM7XG4gICAgICAgIGlmICghcGFyZW50VHJhbnNhY3Rpb24gfHwgcGFyZW50VHJhbnNhY3Rpb24uZGIgIT09IHRoaXMgfHwgbW9kZS5pbmRleE9mKCchJykgIT09IC0xKVxuICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICBjb25zdCBvbmx5SWZDb21wYXRpYmxlID0gbW9kZS5pbmRleE9mKCc/JykgIT09IC0xO1xuICAgICAgICBtb2RlID0gbW9kZS5yZXBsYWNlKCchJywgJycpLnJlcGxhY2UoJz8nLCAnJyk7XG4gICAgICAgIGxldCBpZGJNb2RlLCBzdG9yZU5hbWVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RvcmVOYW1lcyA9IHRhYmxlcy5tYXAodGFibGUgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSB0YWJsZSBpbnN0YW5jZW9mIHRoaXMuVGFibGUgPyB0YWJsZS5uYW1lIDogdGFibGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZU5hbWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0YWJsZSBhcmd1bWVudCB0byBEZXhpZS50cmFuc2FjdGlvbigpLiBPbmx5IFRhYmxlIG9yIFN0cmluZyBhcmUgYWxsb3dlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmVOYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobW9kZSA9PSBcInJcIiB8fCBtb2RlID09PSBSRUFET05MWSlcbiAgICAgICAgICAgICAgICBpZGJNb2RlID0gUkVBRE9OTFk7XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwicndcIiB8fCBtb2RlID09IFJFQURXUklURSlcbiAgICAgICAgICAgICAgICBpZGJNb2RlID0gUkVBRFdSSVRFO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgdHJhbnNhY3Rpb24gbW9kZTogXCIgKyBtb2RlKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbi5tb2RlID09PSBSRUFET05MWSAmJiBpZGJNb2RlID09PSBSRUFEV1JJVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TdWJUcmFuc2FjdGlvbihcIkNhbm5vdCBlbnRlciBhIHN1Yi10cmFuc2FjdGlvbiB3aXRoIFJFQURXUklURSBtb2RlIHdoZW4gcGFyZW50IHRyYW5zYWN0aW9uIGlzIFJFQURPTkxZXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lcy5mb3JFYWNoKHN0b3JlTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24gJiYgcGFyZW50VHJhbnNhY3Rpb24uc3RvcmVOYW1lcy5pbmRleE9mKHN0b3JlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiVGFibGUgXCIgKyBzdG9yZU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgbm90IGluY2x1ZGVkIGluIHBhcmVudCB0cmFuc2FjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSAmJiBwYXJlbnRUcmFuc2FjdGlvbiAmJiAhcGFyZW50VHJhbnNhY3Rpb24uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRUcmFuc2FjdGlvbiA/XG4gICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UobnVsbCwgKF8sIHJlamVjdCkgPT4geyByZWplY3QoZSk7IH0pIDpcbiAgICAgICAgICAgICAgICByZWplY3Rpb24oZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50ZXJUcmFuc2FjdGlvbiA9IGVudGVyVHJhbnNhY3Rpb25TY29wZS5iaW5kKG51bGwsIHRoaXMsIGlkYk1vZGUsIHN0b3JlTmFtZXMsIHBhcmVudFRyYW5zYWN0aW9uLCBzY29wZUZ1bmMpO1xuICAgICAgICByZXR1cm4gKHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKGlkYk1vZGUsIGVudGVyVHJhbnNhY3Rpb24sIFwibG9ja1wiKSA6XG4gICAgICAgICAgICBQU0QudHJhbnMgP1xuICAgICAgICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCAoKSA9PiB0aGlzLl93aGVuUmVhZHkoZW50ZXJUcmFuc2FjdGlvbikpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl93aGVuUmVhZHkoZW50ZXJUcmFuc2FjdGlvbikpO1xuICAgIH1cbiAgICB0YWJsZSh0YWJsZU5hbWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd24odGhpcy5fYWxsVGFibGVzLCB0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkVGFibGUoYFRhYmxlICR7dGFibGVOYW1lfSBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxUYWJsZXNbdGFibGVOYW1lXTtcbiAgICB9XG59XG5cbmNvbnN0IHN5bWJvbE9ic2VydmFibGUgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFwib2JzZXJ2YWJsZVwiIGluIFN5bWJvbFxuICAgID8gU3ltYm9sLm9ic2VydmFibGVcbiAgICA6IFwiQEBvYnNlcnZhYmxlXCI7XG5jbGFzcyBPYnNlcnZhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihzdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoeCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoIXggfHwgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHsgbmV4dDogeCwgZXJyb3IsIGNvbXBsZXRlIH0gOiB4KTtcbiAgICB9XG4gICAgW3N5bWJvbE9ic2VydmFibGVdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodGFyZ2V0LCBuZXdTZXQpIHtcbiAgICBrZXlzKG5ld1NldCkuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgICAgY29uc3QgcmFuZ2VTZXQgPSB0YXJnZXRbcGFydF0gfHwgKHRhcmdldFtwYXJ0XSA9IG5ldyBSYW5nZVNldCgpKTtcbiAgICAgICAgbWVyZ2VSYW5nZXMocmFuZ2VTZXQsIG5ld1NldFtwYXJ0XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gbGl2ZVF1ZXJ5KHF1ZXJpZXIpIHtcbiAgICBsZXQgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICBsZXQgY3VycmVudFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgY29uc3Qgc2NvcGVGdW5jSXNBc3luYyA9IGlzQXN5bmNGdW5jdGlvbihxdWVyaWVyKTtcbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZShzdWJzY3IpIHtcbiAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4ZWMgPSAoKSA9PiBuZXdTY29wZShxdWVyaWVyLCB7IHN1YnNjciwgdHJhbnM6IG51bGwgfSk7XG4gICAgICAgICAgICBjb25zdCBydiA9IFBTRC50cmFuc1xuICAgICAgICAgICAgICAgID9cbiAgICAgICAgICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsIGV4ZWMpXG4gICAgICAgICAgICAgICAgOiBleGVjKCk7XG4gICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgICAgICAgIHJ2LnRoZW4oZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMsIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGxldCBhY2N1bU11dHMgPSB7fTtcbiAgICAgICAgbGV0IGN1cnJlbnRPYnMgPSB7fTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQudW5zdWJzY3JpYmUobXV0YXRpb25MaXN0ZW5lcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBvYnNlcnZlci5zdGFydCAmJiBvYnNlcnZlci5zdGFydChzdWJzY3JpcHRpb24pO1xuICAgICAgICBsZXQgcXVlcnlpbmcgPSBmYWxzZSwgc3RhcnRlZExpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBzaG91bGROb3RpZnkoKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5cyhjdXJyZW50T2JzKS5zb21lKChrZXkpID0+IGFjY3VtTXV0c1trZXldICYmIHJhbmdlc092ZXJsYXAoYWNjdW1NdXRzW2tleV0sIGN1cnJlbnRPYnNba2V5XSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG11dGF0aW9uTGlzdGVuZXIgPSAocGFydHMpID0+IHtcbiAgICAgICAgICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQoYWNjdW1NdXRzLCBwYXJ0cyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KCkpIHtcbiAgICAgICAgICAgICAgICBkb1F1ZXJ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRvUXVlcnkgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocXVlcnlpbmcgfHwgY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyID0ge307XG4gICAgICAgICAgICBjb25zdCByZXQgPSBleGVjdXRlKHN1YnNjcik7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0ZWRMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIG11dGF0aW9uTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWRMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVlcnlpbmcgPSB0cnVlO1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBxdWVyeWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9RdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW1NdXRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPYnMgPSBzdWJzY3I7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBxdWVyeWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgJiYgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBkb1F1ZXJ5KCk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfSk7XG4gICAgb2JzZXJ2YWJsZS5oYXNWYWx1ZSA9ICgpID0+IGhhc1ZhbHVlO1xuICAgIG9ic2VydmFibGUuZ2V0VmFsdWUgPSAoKSA9PiBjdXJyZW50VmFsdWU7XG4gICAgcmV0dXJuIG9ic2VydmFibGU7XG59XG5cbmxldCBkb21EZXBzO1xudHJ5IHtcbiAgICBkb21EZXBzID0ge1xuICAgICAgICBpbmRleGVkREI6IF9nbG9iYWwuaW5kZXhlZERCIHx8IF9nbG9iYWwubW96SW5kZXhlZERCIHx8IF9nbG9iYWwud2Via2l0SW5kZXhlZERCIHx8IF9nbG9iYWwubXNJbmRleGVkREIsXG4gICAgICAgIElEQktleVJhbmdlOiBfZ2xvYmFsLklEQktleVJhbmdlIHx8IF9nbG9iYWwud2Via2l0SURCS2V5UmFuZ2VcbiAgICB9O1xufVxuY2F0Y2ggKGUpIHtcbiAgICBkb21EZXBzID0geyBpbmRleGVkREI6IG51bGwsIElEQktleVJhbmdlOiBudWxsIH07XG59XG5cbmNvbnN0IERleGllID0gRGV4aWUkMTtcbnByb3BzKERleGllLCB7XG4gICAgLi4uZnVsbE5hbWVFeGNlcHRpb25zLFxuICAgIGRlbGV0ZShkYXRhYmFzZU5hbWUpIHtcbiAgICAgICAgY29uc3QgZGIgPSBuZXcgRGV4aWUoZGF0YWJhc2VOYW1lLCB7IGFkZG9uczogW10gfSk7XG4gICAgICAgIHJldHVybiBkYi5kZWxldGUoKTtcbiAgICB9LFxuICAgIGV4aXN0cyhuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWUobmFtZSwgeyBhZGRvbnM6IFtdIH0pLm9wZW4oKS50aGVuKGRiID0+IHtcbiAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSkuY2F0Y2goJ05vU3VjaERhdGFiYXNlRXJyb3InLCAoKSA9PiBmYWxzZSk7XG4gICAgfSxcbiAgICBnZXREYXRhYmFzZU5hbWVzKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RGF0YWJhc2VOYW1lcyhEZXhpZS5kZXBlbmRlbmNpZXMpLnRoZW4oY2IpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZWZpbmVDbGFzcygpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2xhc3MoY29udGVudCkge1xuICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDbGFzcztcbiAgICB9LFxuICAgIGlnbm9yZVRyYW5zYWN0aW9uKHNjb3BlRnVuYykge1xuICAgICAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBzY29wZUZ1bmMpIDpcbiAgICAgICAgICAgIHNjb3BlRnVuYygpO1xuICAgIH0sXG4gICAgdmlwLFxuICAgIGFzeW5jOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocnYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNwYXduOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4sIGFyZ3MsIHRoaXopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpeiwgYXJncyB8fCBbXSkpO1xuICAgICAgICAgICAgaWYgKCFydiB8fCB0eXBlb2YgcnYudGhlbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocnYpO1xuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjdXJyZW50VHJhbnNhY3Rpb246IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBQU0QudHJhbnMgfHwgbnVsbFxuICAgIH0sXG4gICAgd2FpdEZvcjogZnVuY3Rpb24gKHByb21pc2VPckZ1bmN0aW9uLCBvcHRpb25hbFRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHR5cGVvZiBwcm9taXNlT3JGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbihwcm9taXNlT3JGdW5jdGlvbikgOlxuICAgICAgICAgICAgcHJvbWlzZU9yRnVuY3Rpb24pXG4gICAgICAgICAgICAudGltZW91dChvcHRpb25hbFRpbWVvdXQgfHwgNjAwMDApO1xuICAgICAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgICAgICAgIFBTRC50cmFucy53YWl0Rm9yKHByb21pc2UpIDpcbiAgICAgICAgICAgIHByb21pc2U7XG4gICAgfSxcbiAgICBQcm9taXNlOiBEZXhpZVByb21pc2UsXG4gICAgZGVidWc6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBkZWJ1ZyxcbiAgICAgICAgc2V0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzZXREZWJ1Zyh2YWx1ZSwgdmFsdWUgPT09ICdkZXhpZScgPyAoKSA9PiB0cnVlIDogZGV4aWVTdGFja0ZyYW1lRmlsdGVyKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVyaXZlOiBkZXJpdmUsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIG92ZXJyaWRlOiBvdmVycmlkZSxcbiAgICBFdmVudHM6IEV2ZW50cyxcbiAgICBvbjogZ2xvYmFsRXZlbnRzLFxuICAgIGxpdmVRdWVyeSxcbiAgICBleHRlbmRPYnNlcnZhYmlsaXR5U2V0LFxuICAgIGdldEJ5S2V5UGF0aDogZ2V0QnlLZXlQYXRoLFxuICAgIHNldEJ5S2V5UGF0aDogc2V0QnlLZXlQYXRoLFxuICAgIGRlbEJ5S2V5UGF0aDogZGVsQnlLZXlQYXRoLFxuICAgIHNoYWxsb3dDbG9uZTogc2hhbGxvd0Nsb25lLFxuICAgIGRlZXBDbG9uZTogZGVlcENsb25lLFxuICAgIGdldE9iamVjdERpZmY6IGdldE9iamVjdERpZmYsXG4gICAgY21wLFxuICAgIGFzYXA6IGFzYXAkMSxcbiAgICBtaW5LZXk6IG1pbktleSxcbiAgICBhZGRvbnM6IFtdLFxuICAgIGNvbm5lY3Rpb25zOiBjb25uZWN0aW9ucyxcbiAgICBlcnJuYW1lczogZXJybmFtZXMsXG4gICAgZGVwZW5kZW5jaWVzOiBkb21EZXBzLFxuICAgIHNlbVZlcjogREVYSUVfVkVSU0lPTixcbiAgICB2ZXJzaW9uOiBERVhJRV9WRVJTSU9OLnNwbGl0KCcuJylcbiAgICAgICAgLm1hcChuID0+IHBhcnNlSW50KG4pKVxuICAgICAgICAucmVkdWNlKChwLCBjLCBpKSA9PiBwICsgKGMgLyBNYXRoLnBvdygxMCwgaSAqIDIpKSksXG59KTtcbkRleGllLm1heEtleSA9IGdldE1heEtleShEZXhpZS5kZXBlbmRlbmNpZXMuSURCS2V5UmFuZ2UpO1xuXG5pZiAodHlwZW9mIGRpc3BhdGNoRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgdXBkYXRlZFBhcnRzID0+IHtcbiAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgICAgICAgIGxldCBldmVudDtcbiAgICAgICAgICAgIGlmIChpc0lFT3JFZGdlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCB0cnVlLCB0cnVlLCB1cGRhdGVkUGFydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDogdXBkYXRlZFBhcnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB0cnVlO1xuICAgICAgICAgICAgZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCAoeyBkZXRhaWwgfSkgPT4ge1xuICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgcHJvcGFnYXRlTG9jYWxseShkZXRhaWwpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVMb2NhbGx5KHVwZGF0ZVBhcnRzKSB7XG4gICAgbGV0IHdhc01lID0gcHJvcGFnYXRpbmdMb2NhbGx5O1xuICAgIHRyeSB7XG4gICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHRydWU7XG4gICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKHVwZGF0ZVBhcnRzKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHdhc01lO1xuICAgIH1cbn1cbmxldCBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcblxuaWYgKHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FKTtcbiAgICBpZiAodHlwZW9mIGJjLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGJjLnVucmVmKCk7XG4gICAgfVxuICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgKGNoYW5nZWRQYXJ0cykgPT4ge1xuICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgYmMucG9zdE1lc3NhZ2UoY2hhbmdlZFBhcnRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGJjLm9ubWVzc2FnZSA9IChldikgPT4ge1xuICAgICAgICBpZiAoZXYuZGF0YSlcbiAgICAgICAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoZXYuZGF0YSk7XG4gICAgfTtcbn1cbmVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgKGNoYW5nZWRQYXJ0cykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnOiBNYXRoLnJhbmRvbSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFBhcnRzLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZlsnY2xpZW50cyddID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBbLi4uc2VsZlsnY2xpZW50cyddLm1hdGNoQWxsKHsgaW5jbHVkZVVuY29udHJvbGxlZDogdHJ1ZSB9KV0uZm9yRWFjaCgoY2xpZW50KSA9PiBjbGllbnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFBhcnRzLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoZGF0YS5jaGFuZ2VkUGFydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3dDb250YWluZXIgPSBzZWxmLmRvY3VtZW50ICYmIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyO1xuICAgIGlmIChzd0NvbnRhaW5lcikge1xuICAgICAgICBzd0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgcHJvcGFnYXRlTWVzc2FnZUxvY2FsbHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZU1lc3NhZ2VMb2NhbGx5KHsgZGF0YSB9KSB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS50eXBlID09PSBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUpIHtcbiAgICAgICAgcHJvcGFnYXRlTG9jYWxseShkYXRhLmNoYW5nZWRQYXJ0cyk7XG4gICAgfVxufVxuXG5EZXhpZVByb21pc2UucmVqZWN0aW9uTWFwcGVyID0gbWFwRXJyb3I7XG5zZXREZWJ1ZyhkZWJ1ZywgZGV4aWVTdGFja0ZyYW1lRmlsdGVyKTtcblxuZXhwb3J0IHsgRGV4aWUkMSBhcyBEZXhpZSwgUmFuZ2VTZXQsIERleGllJDEgYXMgZGVmYXVsdCwgbGl2ZVF1ZXJ5LCBtZXJnZVJhbmdlcywgcmFuZ2VzT3ZlcmxhcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV4aWUubWpzLm1hcFxuIl0sIm5hbWVzIjpbIl9nbG9iYWwiLCJnbG9iYWxUaGlzIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImtleXMiLCJPYmplY3QiLCJpc0FycmF5IiwiQXJyYXkiLCJQcm9taXNlIiwiZXh0ZW5kIiwib2JqIiwiZXh0ZW5zaW9uIiwiZm9yRWFjaCIsImtleSIsImdldFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJfaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJoYXNPd24iLCJwcm9wIiwiY2FsbCIsInByb3BzIiwicHJvdG8iLCJSZWZsZWN0Iiwib3duS2V5cyIsInNldFByb3AiLCJkZWZpbmVQcm9wZXJ0eSIsImZ1bmN0aW9uT3JHZXRTZXQiLCJvcHRpb25zIiwiZ2V0Iiwic2V0IiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJ3cml0YWJsZSIsImRlcml2ZSIsIkNoaWxkIiwiZnJvbSIsIlBhcmVudCIsInByb3RvdHlwZSIsImNyZWF0ZSIsImJpbmQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRQcm9wZXJ0eURlc2NyaXB0b3IiLCJwZCIsIl9zbGljZSIsInNsaWNlIiwiYXJncyIsInN0YXJ0IiwiZW5kIiwib3ZlcnJpZGUiLCJvcmlnRnVuYyIsIm92ZXJyaWRlZEZhY3RvcnkiLCJhc3NlcnQiLCJiIiwiRXJyb3IiLCJhc2FwJDEiLCJmbiIsInNldEltbWVkaWF0ZSIsInNldFRpbWVvdXQiLCJhcnJheVRvT2JqZWN0IiwiYXJyYXkiLCJleHRyYWN0b3IiLCJyZWR1Y2UiLCJyZXN1bHQiLCJpdGVtIiwiaSIsIm5hbWVBbmRWYWx1ZSIsInRyeUNhdGNoIiwib25lcnJvciIsImFwcGx5IiwiZXgiLCJnZXRCeUtleVBhdGgiLCJrZXlQYXRoIiwicnYiLCJsIiwibGVuZ3RoIiwidmFsIiwicHVzaCIsInBlcmlvZCIsImluZGV4T2YiLCJpbm5lck9iaiIsInN1YnN0ciIsInVuZGVmaW5lZCIsInNldEJ5S2V5UGF0aCIsImlzRnJvemVuIiwiY3VycmVudEtleVBhdGgiLCJyZW1haW5pbmdLZXlQYXRoIiwiaXNOYU4iLCJwYXJzZUludCIsInNwbGljZSIsImRlbEJ5S2V5UGF0aCIsIm1hcCIsImtwIiwic2hhbGxvd0Nsb25lIiwibSIsImNvbmNhdCIsImZsYXR0ZW4iLCJhIiwiaW50cmluc2ljVHlwZU5hbWVzIiwic3BsaXQiLCJudW0iLCJ0IiwiZmlsdGVyIiwiaW50cmluc2ljVHlwZXMiLCJ4IiwiY2lyY3VsYXJSZWZzIiwiZGVlcENsb25lIiwiYW55IiwiV2Vha01hcCIsImlubmVyRGVlcENsb25lIiwiY29uc3RydWN0b3IiLCJ0b1N0cmluZyIsInRvU3RyaW5nVGFnIiwibyIsIml0ZXJhdG9yU3ltYm9sIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJnZXRJdGVyYXRvck9mIiwiTk9fQ0hBUl9BUlJBWSIsImdldEFycmF5T2YiLCJhcnJheUxpa2UiLCJpdCIsImFyZ3VtZW50cyIsIm5leHQiLCJkb25lIiwiaXNBc3luY0Z1bmN0aW9uIiwiZGVidWciLCJsb2NhdGlvbiIsInRlc3QiLCJocmVmIiwic2V0RGVidWciLCJsaWJyYXJ5RmlsdGVyIiwiTkVFRFNfVEhST1dfRk9SX1NUQUNLIiwic3RhY2siLCJnZXRFcnJvcldpdGhTdGFjayIsImUiLCJwcmV0dHlTdGFjayIsImV4Y2VwdGlvbiIsIm51bUlnbm9yZWRGcmFtZXMiLCJuYW1lIiwibWVzc2FnZSIsImZyYW1lIiwiam9pbiIsImRleGllRXJyb3JOYW1lcyIsImlkYkRvbUVycm9yTmFtZXMiLCJlcnJvckxpc3QiLCJkZWZhdWx0VGV4dHMiLCJWZXJzaW9uQ2hhbmdlZCIsIkRhdGFiYXNlQ2xvc2VkIiwiQWJvcnQiLCJUcmFuc2FjdGlvbkluYWN0aXZlIiwiTWlzc2luZ0FQSSIsIkRleGllRXJyb3IiLCJtc2ciLCJfZSIsIl9zdGFjayIsImdldE11bHRpRXJyb3JNZXNzYWdlIiwiZmFpbHVyZXMiLCJ2IiwicyIsIk1vZGlmeUVycm9yIiwic3VjY2Vzc0NvdW50IiwiZmFpbGVkS2V5cyIsIkJ1bGtFcnJvciIsInBvcyIsImZhaWx1cmVzQnlQb3MiLCJlcnJuYW1lcyIsIkJhc2VFeGNlcHRpb24iLCJleGNlcHRpb25zIiwiZnVsbE5hbWUiLCJtc2dPcklubmVyIiwiaW5uZXIiLCJTeW50YXgiLCJTeW50YXhFcnJvciIsIlR5cGUiLCJUeXBlRXJyb3IiLCJSYW5nZSIsIlJhbmdlRXJyb3IiLCJleGNlcHRpb25NYXAiLCJtYXBFcnJvciIsImRvbUVycm9yIiwiZnVsbE5hbWVFeGNlcHRpb25zIiwibm9wIiwibWlycm9yIiwicHVyZUZ1bmN0aW9uQ2hhaW4iLCJmMSIsImYyIiwiY2FsbEJvdGgiLCJvbjEiLCJvbjIiLCJob29rQ3JlYXRpbmdDaGFpbiIsInJlcyIsIm9uc3VjY2VzcyIsInJlczIiLCJob29rRGVsZXRpbmdDaGFpbiIsImhvb2tVcGRhdGluZ0NoYWluIiwibW9kaWZpY2F0aW9ucyIsInJldmVyc2VTdG9wcGFibGVFdmVudENoYWluIiwicHJvbWlzYWJsZUNoYWluIiwidGhlbiIsInRoaXoiLCJJTlRFUk5BTCIsIkxPTkdfU1RBQ0tTX0NMSVBfTElNSVQiLCJNQVhfTE9OR19TVEFDS1MiLCJaT05FX0VDSE9fTElNSVQiLCJyZXNvbHZlZE5hdGl2ZVByb21pc2UiLCJuYXRpdmVQcm9taXNlUHJvdG8iLCJyZXNvbHZlZEdsb2JhbFByb21pc2UiLCJnbG9iYWxQIiwicmVzb2x2ZSIsImNyeXB0byIsInN1YnRsZSIsIm5hdGl2ZVAiLCJkaWdlc3QiLCJVaW50OEFycmF5IiwibmF0aXZlUHJvbWlzZVRoZW4iLCJOYXRpdmVQcm9taXNlIiwicGF0Y2hHbG9iYWxQcm9taXNlIiwic3RhY2tfYmVpbmdfZ2VuZXJhdGVkIiwic2NoZWR1bGVQaHlzaWNhbFRpY2siLCJwaHlzaWNhbFRpY2siLCJNdXRhdGlvbk9ic2VydmVyIiwiaGlkZGVuRGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJzZXRBdHRyaWJ1dGUiLCJhc2FwIiwiY2FsbGJhY2siLCJtaWNyb3RpY2tRdWV1ZSIsIm5lZWRzTmV3UGh5c2ljYWxUaWNrIiwiaXNPdXRzaWRlTWljcm9UaWNrIiwidW5oYW5kbGVkRXJyb3JzIiwicmVqZWN0aW5nRXJyb3JzIiwiY3VycmVudEZ1bGZpbGxlciIsInJlamVjdGlvbk1hcHBlciIsImdsb2JhbFBTRCIsImlkIiwicmVmIiwidW5oYW5kbGVkcyIsIm9udW5oYW5kbGVkIiwiZ2xvYmFsRXJyb3IiLCJwZ3AiLCJlbnYiLCJmaW5hbGl6ZSIsInVoIiwiUFNEIiwibnVtU2NoZWR1bGVkQ2FsbHMiLCJ0aWNrRmluYWxpemVycyIsIkRleGllUHJvbWlzZSIsIl9saXN0ZW5lcnMiLCJvbnVuY2F0Y2hlZCIsIl9saWIiLCJwc2QiLCJfUFNEIiwiX3N0YWNrSG9sZGVyIiwiX3ByZXYiLCJfbnVtUHJldiIsIl9zdGF0ZSIsIl92YWx1ZSIsImhhbmRsZVJlamVjdGlvbiIsImV4ZWN1dGVQcm9taXNlVGFzayIsInRoZW5Qcm9wIiwibWljcm9UYXNrSWQiLCJ0b3RhbEVjaG9lcyIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInBvc3NpYmxlQXdhaXQiLCJjbGVhbnVwIiwiZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMiLCJyZWplY3QiLCJwcm9wYWdhdGVUb0xpc3RlbmVyIiwiTGlzdGVuZXIiLCJuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwIiwibGlua1RvUHJldmlvdXNQcm9taXNlIiwiX3RoZW4iLCJjYXRjaCIsInR5cGUiLCJoYW5kbGVyIiwiZXJyIiwiUHJvbWlzZVJlamVjdCIsImZpbmFsbHkiLCJvbkZpbmFsbHkiLCJzdGFja3MiLCJnZXRTdGFjayIsInRpbWVvdXQiLCJtcyIsIkluZmluaXR5IiwiaGFuZGxlIiwiVGltZW91dCIsImNsZWFyVGltZW91dCIsInNuYXBTaG90Iiwiem9uZSIsImFsbCIsInZhbHVlcyIsIm9uUG9zc2libGVQYXJhbGxlbGxBc3luYyIsInJlbWFpbmluZyIsInJhY2UiLCJuZXdQU0QiLCJuZXdTY29wZSIsInVzZVBTRCIsInNjaGVkdWxlciIsImZvbGxvdyIsInpvbmVQcm9wcyIsInJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2siLCJhbGxTZXR0bGVkIiwicG9zc2libGVQcm9taXNlcyIsInJlc3VsdHMiLCJwIiwic3RhdHVzIiwicmVhc29uIiwiQWdncmVnYXRlRXJyb3IiLCJmYWlsdXJlIiwicHJvbWlzZSIsInNob3VsZEV4ZWN1dGVUaWNrIiwiYmVnaW5NaWNyb1RpY2tTY29wZSIsInByb3BhZ2F0ZUFsbExpc3RlbmVycyIsImVuZE1pY3JvVGlja1Njb3BlIiwiX3Byb21pc2UiLCJvcmlnUHJvcCIsImFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IiLCJsaXN0ZW5lcnMiLCJsZW4iLCJmaW5hbGl6ZVBoeXNpY2FsVGljayIsImxpc3RlbmVyIiwiY2IiLCJjYWxsTGlzdGVuZXIiLCJyZXQiLCJtYXJrRXJyb3JBc0hhbmRsZWQiLCJsaW1pdCIsImVycm9yTmFtZSIsInByZXYiLCJudW1QcmV2Iiwid2FzUm9vdEV4ZWMiLCJjYWxsYmFja3MiLCJ1bmhhbmRsZWRFcnJzIiwiZmluYWxpemVycyIsImZpbmFsaXplciIsInNvbWUiLCJ3cmFwIiwiZXJyb3JDYXRjaGVyIiwib3V0ZXJTY29wZSIsInN3aXRjaFRvWm9uZSIsInRhc2siLCJhd2FpdHMiLCJlY2hvZXMiLCJ0YXNrQ291bnRlciIsInpvbmVTdGFjayIsInpvbmVFY2hvZXMiLCJ6b25lX2lkX2NvdW50ZXIiLCJhMSIsImEyIiwicGFyZW50IiwiZ2xvYmFsRW52IiwiUHJvbWlzZVByb3AiLCJudGhlbiIsImdldFBhdGNoZWRQcm9taXNlVGhlbiIsImd0aGVuIiwiaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMiLCJwb3NzaWJsZVByb21pc2UiLCJyZWplY3Rpb24iLCJ6b25lRW50ZXJFY2hvIiwidGFyZ2V0Wm9uZSIsInpvbmVMZWF2ZUVjaG8iLCJwb3AiLCJiRW50ZXJpbmdab25lIiwiY3VycmVudFpvbmUiLCJlbnF1ZXVlTmF0aXZlTWljcm9UYXNrIiwiR2xvYmFsUHJvbWlzZSIsInRhcmdldEVudiIsImEzIiwiam9iIiwib3V0ZXJab25lIiwib3JpZ1RoZW4iLCJvblJlc29sdmVkIiwiVU5IQU5ETEVEUkVKRUNUSU9OIiwiZXZlbnQiLCJldmVudERhdGEiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiZGlzcGF0Y2hFdmVudCIsIlByb21pc2VSZWplY3Rpb25FdmVudCIsIm9udW5oYW5kbGVkcmVqZWN0aW9uIiwiXyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjb25zb2xlIiwid2FybiIsInRlbXBUcmFuc2FjdGlvbiIsImRiIiwibW9kZSIsInN0b3JlTmFtZXMiLCJpZGJkYiIsIm9wZW5Db21wbGV0ZSIsImxldFRocm91Z2giLCJfdmlwIiwiZGJPcGVuRXJyb3IiLCJpc0JlaW5nT3BlbmVkIiwiX29wdGlvbnMiLCJhdXRvT3BlbiIsIm9wZW4iLCJkYlJlYWR5UHJvbWlzZSIsInRyYW5zIiwiX2NyZWF0ZVRyYW5zYWN0aW9uIiwiX2RiU2NoZW1hIiwiUFIxMzk4X21heExvb3AiLCJJbnZhbGlkU3RhdGUiLCJpc09wZW4iLCJfY2xvc2UiLCJfY29tcGxldGlvbiIsIkRFWElFX1ZFUlNJT04iLCJtYXhTdHJpbmciLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJtaW5LZXkiLCJJTlZBTElEX0tFWV9BUkdVTUVOVCIsIlNUUklOR19FWFBFQ1RFRCIsImNvbm5lY3Rpb25zIiwiaXNJRU9yRWRnZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImhhc0lFRGVsZXRlT2JqZWN0U3RvcmVCdWciLCJoYW5nc09uRGVsZXRlTGFyZ2VLZXlSYW5nZSIsImRleGllU3RhY2tGcmFtZUZpbHRlciIsIkRCTkFNRVNfREIiLCJSRUFET05MWSIsIlJFQURXUklURSIsImNvbWJpbmUiLCJmaWx0ZXIxIiwiZmlsdGVyMiIsIkFueVJhbmdlIiwibG93ZXIiLCJsb3dlck9wZW4iLCJ1cHBlciIsInVwcGVyT3BlbiIsIndvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5IiwiVGFibGUiLCJfdHJhbnMiLCJ3cml0ZUxvY2tlZCIsIl90eCIsInRhYmxlTmFtZSIsImNoZWNrVGFibGVJblRyYW5zYWN0aW9uIiwic2NoZW1hIiwiTm90Rm91bmQiLCJpZGJ0cmFucyIsInRyYW5zbGVzcyIsImtleU9yQ3JpdCIsIndoZXJlIiwiZmlyc3QiLCJjb3JlIiwiaG9vayIsInJlYWRpbmciLCJmaXJlIiwiaW5kZXhPckNyaXQiLCJXaGVyZUNsYXVzZSIsImtleVBhdGhzIiwiZXF1YWxzIiwiY29tcG91bmRJbmRleCIsImluZGV4ZXMiLCJwcmltS2V5IiwiaXgiLCJjb21wb3VuZCIsImV2ZXJ5Iiwic29ydCIsIl9tYXhLZXkiLCJrZXlQYXRoc0luVmFsaWRPcmRlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJpZHhCeU5hbWUiLCJpZGIiLCJfZGVwcyIsImluZGV4ZWREQiIsImNtcCIsImlkeCIsImZpbHRlckZ1bmN0aW9uIiwicHJldkluZGV4IiwicHJldkZpbHRlckZuIiwiaW5kZXgiLCJtdWx0aSIsInRvQ29sbGVjdGlvbiIsImFuZCIsImNvdW50IiwidGhlblNob3J0Y3V0Iiwib2Zmc2V0IiwibnVtUm93cyIsImVhY2giLCJ0b0FycmF5IiwiQ29sbGVjdGlvbiIsIm9yZGVyQnkiLCJyZXZlcnNlIiwibWFwVG9DbGFzcyIsIm1hcHBlZENsYXNzIiwicmVhZEhvb2siLCJ1bnN1YnNjcmliZSIsImRlZmluZUNsYXNzIiwiQ2xhc3MiLCJjb250ZW50IiwiYWRkIiwiYXV0byIsIm9ialRvQWRkIiwibXV0YXRlIiwibnVtRmFpbHVyZXMiLCJsYXN0UmVzdWx0IiwidXBkYXRlIiwia2V5T3JPYmplY3QiLCJJbnZhbGlkQXJndW1lbnQiLCJfYSIsIm1vZGlmeSIsInB1dCIsImRlbGV0ZSIsImNsZWFyIiwicmFuZ2UiLCJidWxrR2V0IiwiZ2V0TWFueSIsImJ1bGtBZGQiLCJvYmplY3RzIiwia2V5c09yT3B0aW9ucyIsIndhbnRSZXN1bHRzIiwiYWxsS2V5cyIsIm51bU9iamVjdHMiLCJvYmplY3RzVG9BZGQiLCJidWxrUHV0Iiwib2JqZWN0c1RvUHV0IiwiYnVsa0RlbGV0ZSIsIm51bUtleXMiLCJFdmVudHMiLCJjdHgiLCJldnMiLCJldmVudE5hbWUiLCJzdWJzY3JpYmVyIiwic3Vic2NyaWJlIiwiYWRkRXZlbnRUeXBlIiwiY2hhaW5GdW5jdGlvbiIsImRlZmF1bHRGdW5jdGlvbiIsImFkZENvbmZpZ3VyZWRFdmVudHMiLCJjb250ZXh0Iiwic3Vic2NyaWJlcnMiLCJjZmciLCJmaXJlRXZlbnQiLCJtYWtlQ2xhc3NDb25zdHJ1Y3RvciIsImNyZWF0ZVRhYmxlQ29uc3RydWN0b3IiLCJ0YWJsZVNjaGVtYSIsIl9hbGxUYWJsZXMiLCJpc1BsYWluS2V5UmFuZ2UiLCJpZ25vcmVMaW1pdEZpbHRlciIsImFsZ29yaXRobSIsIm9yIiwianVzdExpbWl0IiwicmVwbGF5RmlsdGVyIiwiYWRkRmlsdGVyIiwiYWRkUmVwbGF5RmlsdGVyIiwiZmFjdG9yeSIsImlzTGltaXRGaWx0ZXIiLCJjdXJyIiwiYWRkTWF0Y2hGaWx0ZXIiLCJpc01hdGNoIiwiZ2V0SW5kZXhPclN0b3JlIiwiY29yZVNjaGVtYSIsImlzUHJpbUtleSIsInByaW1hcnlLZXkiLCJnZXRJbmRleEJ5S2V5UGF0aCIsIlNjaGVtYSIsIm9wZW5DdXJzb3IiLCJjb3JlVGFibGUiLCJrZXlzT25seSIsImRpciIsInVuaXF1ZSIsInF1ZXJ5IiwiaXRlciIsImNvcmVUcmFucyIsIml0ZXJhdGUiLCJ2YWx1ZU1hcHBlciIsInVuaW9uIiwiY3Vyc29yIiwiYWR2YW5jZSIsInN0b3AiLCJmYWlsIiwiX2l0ZXJhdGUiLCJjdXJzb3JQcm9taXNlIiwibWFwcGVkRm4iLCJjIiwid3JhcHBlZEZuIiwiY29udGludWUiLCJhZHZhbmNlciIsInRhIiwidGIiLCJOYU4iLCJjb21wYXJlVWludDhBcnJheXMiLCJnZXRVaW50OEFycmF5IiwiY29tcGFyZUFycmF5cyIsImFsIiwiYmwiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsInRzVGFnIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJfcmVhZCIsIl9jdHgiLCJlcnJvciIsInRhYmxlIiwiX3dyaXRlIiwiX2FkZEFsZ29yaXRobSIsImNsb25lIiwicmF3IiwiTWF0aCIsIm1pbiIsInNvcnRCeSIsInBhcnRzIiwibGFzdFBhcnQiLCJsYXN0SW5kZXgiLCJnZXR2YWwiLCJvcmRlciIsInNvcnRlciIsImFWYWwiLCJiVmFsIiwib2Zmc2V0TGVmdCIsInJvd3NMZWZ0IiwidW50aWwiLCJiSW5jbHVkZVN0b3BFbnRyeSIsImxhc3QiLCJpbmRleE5hbWUiLCJfb25kaXJlY3Rpb25jaGFuZ2UiLCJkZXNjIiwiZWFjaEtleSIsImVhY2hVbmlxdWVLZXkiLCJlYWNoUHJpbWFyeUtleSIsInByaW1hcnlLZXlzIiwidW5pcXVlS2V5cyIsImZpcnN0S2V5IiwibGFzdEtleSIsImRpc3RpbmN0Iiwic3RyS2V5IiwiZm91bmQiLCJjaGFuZ2VzIiwibW9kaWZ5ZXIiLCJhbnl0aGluZ01vZGlmaWVkIiwib3V0Ym91bmQiLCJleHRyYWN0S2V5IiwibW9kaWZ5Q2h1bmtTaXplIiwidG90YWxGYWlsdXJlcyIsImFwcGx5TXV0YXRlUmVzdWx0IiwiZXhwZWN0ZWRDb3VudCIsIm5leHRDaHVuayIsImNhY2hlIiwiYWRkVmFsdWVzIiwicHV0VmFsdWVzIiwicHV0S2V5cyIsImRlbGV0ZUtleXMiLCJvcmlnVmFsdWUiLCJjcml0ZXJpYSIsImRlbGV0ZUNhbGxiYWNrIiwiY2hhbmdlU3BlYyIsImNvcmVSYW5nZSIsImNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3RvciIsIndoZXJlQ2xhdXNlIiwia2V5UmFuZ2VHZW5lcmF0b3IiLCJrZXlSYW5nZSIsIndoZXJlQ3R4IiwicmVhZGluZ0hvb2siLCJzaW1wbGVDb21wYXJlIiwic2ltcGxlQ29tcGFyZVJldmVyc2UiLCJjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSIsIlQiLCJjb2xsZWN0aW9uIiwiZW1wdHlDb2xsZWN0aW9uIiwicmFuZ2VFcXVhbCIsInVwcGVyRmFjdG9yeSIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJsb3dlckZhY3RvcnkiLCJuZXh0Q2FzaW5nIiwibG93ZXJLZXkiLCJ1cHBlck5lZWRsZSIsImxvd2VyTmVlZGxlIiwibGxwIiwibHdyS2V5Q2hhciIsImFkZElnbm9yZUNhc2VBbGdvcml0aG0iLCJtYXRjaCIsIm5lZWRsZXMiLCJzdWZmaXgiLCJjb21wYXJlIiwidXBwZXJOZWVkbGVzIiwibG93ZXJOZWVkbGVzIiwiZGlyZWN0aW9uIiwibmV4dEtleVN1ZmZpeCIsIm5lZWRsZXNMZW4iLCJpbml0RGlyZWN0aW9uIiwibmVlZGxlQm91bmRzIiwibmVlZGxlIiwibmIiLCJjcmVhdGVSYW5nZSIsImZpcnN0UG9zc2libGVOZWVkbGUiLCJsb3dlc3RQb3NzaWJsZUNhc2luZyIsImNhc2luZyIsImJldHdlZW4iLCJpbmNsdWRlTG93ZXIiLCJpbmNsdWRlVXBwZXIiLCJfY21wIiwiYWJvdmUiLCJhYm92ZU9yRXF1YWwiLCJiZWxvdyIsImJlbG93T3JFcXVhbCIsInN0YXJ0c1dpdGgiLCJzdHIiLCJzdGFydHNXaXRoSWdub3JlQ2FzZSIsImVxdWFsc0lnbm9yZUNhc2UiLCJhbnlPZklnbm9yZUNhc2UiLCJzdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlIiwibiIsImFueU9mIiwiX2FzY2VuZGluZyIsIl9kZXNjZW5kaW5nIiwibm90RXF1YWwiLCJpbkFueVJhbmdlIiwiaW5jbHVkZUxvd2VycyIsImluY2x1ZGVVcHBlcnMiLCJub25lT2YiLCJyYW5nZXMiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiX21pbiIsIm1heCIsIl9tYXgiLCJhZGRSYW5nZSIsIm5ld1JhbmdlIiwic29ydERpcmVjdGlvbiIsInJhbmdlU29ydGVyIiwicmFuZ2VQb3MiLCJrZXlJc0JleW9uZEN1cnJlbnRFbnRyeSIsImtleUlzQmVmb3JlQ3VycmVudEVudHJ5Iiwia2V5V2l0aGluQ3VycmVudFJhbmdlIiwiY2hlY2tLZXkiLCJzdGFydHNXaXRoQW55T2YiLCJjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yIiwib3JDb2xsZWN0aW9uIiwiX0lEQktleVJhbmdlIiwiSURCS2V5UmFuZ2UiLCJldmVudFJlamVjdEhhbmRsZXIiLCJwcmV2ZW50RGVmYXVsdCIsInRhcmdldCIsInN0b3BQcm9wYWdhdGlvbiIsIkRFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FIiwiU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FIiwiZ2xvYmFsRXZlbnRzIiwiVHJhbnNhY3Rpb24iLCJfbG9jayIsIl9yZWN1bG9jayIsImxvY2tPd25lckZvciIsIl91bmxvY2siLCJfYmxvY2tlZEZ1bmNzIiwiX2xvY2tlZCIsImZuQW5kUFNEIiwic2hpZnQiLCJPcGVuRmFpbGVkIiwiYWN0aXZlIiwidHJhbnNhY3Rpb24iLCJkdXJhYmlsaXR5IiwiY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IiwiZXYiLCJfcmVqZWN0Iiwib25hYm9ydCIsIm9uIiwib25jb21wbGV0ZSIsIl9yZXNvbHZlIiwic3RvcmFnZW11dGF0ZWQiLCJiV3JpdGVMb2NrIiwiUmVhZE9ubHkiLCJfcm9vdCIsIndhaXRGb3IiLCJwcm9taXNlTGlrZSIsInJvb3QiLCJfd2FpdGluZ0ZvciIsIl93YWl0aW5nUXVldWUiLCJzdG9yZSIsIm9iamVjdFN0b3JlIiwic3BpbiIsIl9zcGluQ291bnQiLCJjdXJyZW50V2FpdFByb21pc2UiLCJhYm9ydCIsIm1lbW9pemVkVGFibGVzIiwiX21lbW9pemVkVGFibGVzIiwidHJhbnNhY3Rpb25Cb3VuZFRhYmxlIiwiY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3RvciIsImRic2NoZW1hIiwiY29tcGxldGUiLCJ3YXNBY3RpdmUiLCJjcmVhdGVJbmRleFNwZWMiLCJzcmMiLCJuYW1lRnJvbUtleVBhdGgiLCJjcmVhdGVUYWJsZVNjaGVtYSIsInNhZmFyaU11bHRpU3RvcmVGaXgiLCJnZXRNYXhLZXkiLCJJZGJLZXlSYW5nZSIsIm9ubHkiLCJnZXRLZXlFeHRyYWN0b3IiLCJnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yIiwiYXJyYXlpZnkiLCJfaWRfY291bnRlciIsImdldEtleVBhdGhBbGlhcyIsImNyZWF0ZURCQ29yZSIsInRtcFRyYW5zIiwiZXh0cmFjdFNjaGVtYSIsInRhYmxlcyIsIm9iamVjdFN0b3JlTmFtZXMiLCJhdXRvSW5jcmVtZW50IiwiaW5kZXhCeUtleVBhdGgiLCJpc1ByaW1hcnlLZXkiLCJpbmRleE5hbWVzIiwibXVsdGlFbnRyeSIsImhhc0dldEFsbCIsIm1ha2VJREJLZXlSYW5nZSIsImlkYlJhbmdlIiwidXBwZXJCb3VuZCIsImxvd2VyQm91bmQiLCJib3VuZCIsImNyZWF0ZURiQ29yZVRhYmxlIiwiaXNBZGRPclB1dCIsInJlcSIsInJlcXMiLCJlcnJvckhhbmRsZXIiLCJhcmdzMSIsImFyZ3MyIiwic291cmNlIiwib3BlbktleUN1cnNvciIsIl9fX2lkIiwiX2N1cnNvckNvbnRpbnVlIiwiX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSIsImNvbnRpbnVlUHJpbWFyeUtleSIsIl9jdXJzb3JBZHZhbmNlIiwiZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZCIsImRvVGhyb3dDdXJzb3JJc1N0b3BwZWQiLCJnb3RPbmUiLCJpdGVyYXRpb25Qcm9taXNlIiwicmVzb2x2ZUl0ZXJhdGlvbiIsInJlamVjdEl0ZXJhdGlvbiIsImd1YXJkZWRDYWxsYmFjayIsInJlcXVlc3QiLCJub25JbmZpbml0TGltaXQiLCJpZGJLZXlSYW5nZSIsImdldEFsbCIsImdldEFsbEtleXMiLCJrZXlDb3VudCIsImNhbGxiYWNrQ291bnQiLCJzdWNjZXNzSGFuZGxlciIsIl9wb3MiLCJ0YWJsZU1hcCIsIk1JTl9LRVkiLCJNQVhfS0VZIiwiY3JlYXRlTWlkZGxld2FyZVN0YWNrIiwic3RhY2tJbXBsIiwibWlkZGxld2FyZXMiLCJkb3duIiwiY3JlYXRlTWlkZGxld2FyZVN0YWNrcyIsImRiY29yZSIsImdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyIsIl9ub3ZpcCIsIl9taWRkbGV3YXJlcyIsInRibCIsInNldEFwaU9uUGxhY2UiLCJvYmpzIiwidGFibGVOYW1lcyIsInByb3BEZXNjIiwiZW51bWVyYWJsZSIsInJlbW92ZVRhYmxlc0FwaSIsImxvd2VyVmVyc2lvbkZpcnN0IiwiX2NmZyIsInZlcnNpb24iLCJydW5VcGdyYWRlcnMiLCJvbGRWZXJzaW9uIiwiaWRiVXBncmFkZVRyYW5zIiwiZ2xvYmFsU2NoZW1hIiwiX3N0b3JlTmFtZXMiLCJyZWplY3RUcmFuc2FjdGlvbiIsImNyZWF0ZVRhYmxlIiwicG9wdWxhdGUiLCJ1cGRhdGVUYWJsZXNBbmRJbmRleGVzIiwicXVldWUiLCJ2ZXJzaW9ucyIsIl92ZXJzaW9ucyIsImJ1aWxkR2xvYmFsU2NoZW1hIiwiYW55Q29udGVudFVwZ3JhZGVySGFzUnVuIiwidmVyc1RvUnVuIiwib2xkU2NoZW1hIiwibmV3U2NoZW1hIiwiYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMiLCJkaWZmIiwiZ2V0U2NoZW1hRGlmZiIsInR1cGxlIiwiY2hhbmdlIiwicmVjcmVhdGUiLCJVcGdyYWRlIiwiYWRkSW5kZXgiLCJkZWxldGVJbmRleCIsImRlbCIsImlkeE5hbWUiLCJjb250ZW50VXBncmFkZSIsInVwZ3JhZGVTY2hlbWEiLCJjb250ZW50VXBncmFkZUlzQXN5bmMiLCJyZXR1cm5WYWx1ZSIsInByb21pc2VGb2xsb3dlZCIsImRlY3JlbWVudG9yIiwiZGVsZXRlUmVtb3ZlZFRhYmxlcyIsInJ1blF1ZXVlIiwiY3JlYXRlTWlzc2luZ1RhYmxlcyIsIm9sZERlZiIsIm5ld0RlZiIsImRlZiIsIm9sZEluZGV4ZXMiLCJuZXdJbmRleGVzIiwib2xkSWR4IiwibmV3SWR4IiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJjb250YWlucyIsInN0b3JlTmFtZSIsImRlbGV0ZU9iamVjdFN0b3JlIiwiY3JlYXRlSW5kZXgiLCJkYlN0b3JlTmFtZXMiLCJqIiwiaWRiaW5kZXgiLCJyZWFkR2xvYmFsU2NoZW1hIiwidmVybm8iLCJ2ZXJpZnlJbnN0YWxsZWRTY2hlbWEiLCJpbnN0YWxsZWRTY2hlbWEiLCJjaCIsIl9oYXNHZXRBbGwiLCJkZXhpZU5hbWUiLCJpbmRleFNwZWMiLCJXb3JrZXJHbG9iYWxTY29wZSIsInBhcnNlSW5kZXhTeW50YXgiLCJwcmltS2V5QW5kSW5kZXhlcyIsImluZGV4TnVtIiwidHJpbSIsInJlcGxhY2UiLCJWZXJzaW9uIiwiX3BhcnNlU3RvcmVzU3BlYyIsInN0b3JlcyIsIm91dFNjaGVtYSIsInN0b3Jlc1NvdXJjZSIsInN0b3Jlc1NwZWMiLCJ1cGdyYWRlIiwidXBncmFkZUZ1bmN0aW9uIiwiY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yIiwidmVyc2lvbk51bWJlciIsImdldERiTmFtZXNUYWJsZSIsImRiTmFtZXNEQiIsIkRleGllJDEiLCJhZGRvbnMiLCJkYm5hbWVzIiwiaGFzRGF0YWJhc2VzTmF0aXZlIiwiZGF0YWJhc2VzIiwiZ2V0RGF0YWJhc2VOYW1lcyIsImluZm9zIiwiaW5mbyIsIl9vbkRhdGFiYXNlQ3JlYXRlZCIsIl9vbkRhdGFiYXNlRGVsZXRlZCIsInZpcCIsImlkYlJlYWR5IiwiaXNTYWZhcmkiLCJ1c2VyQWdlbnREYXRhIiwiaW50ZXJ2YWxJZCIsInRyeUlkYiIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImRleGllT3BlbiIsInN0YXRlIiwib3BlbkNhbmNlbGxlciIsInRocm93SWZDYW5jZWxsZWQiLCJyZXNvbHZlRGJSZWFkeSIsImRiUmVhZHlSZXNvbHZlIiwidXBncmFkZVRyYW5zYWN0aW9uIiwid2FzQ3JlYXRlZCIsInRyeU9wZW5EQiIsImRiTmFtZSIsImF1dG9TY2hlbWEiLCJyb3VuZCIsIm9uYmxvY2tlZCIsIl9maXJlT25CbG9ja2VkIiwib251cGdyYWRlbmVlZGVkIiwiYWxsb3dFbXB0eURCIiwiY2xvc2UiLCJkZWxyZXEiLCJkZWxldGVEYXRhYmFzZSIsIk5vU3VjaERhdGFiYXNlIiwib2xkVmVyIiwicG93Iiwib252ZXJzaW9uY2hhbmdlIiwidmNGaXJlZCIsIm9uY2xvc2UiLCJvblJlYWR5QmVpbmdGaXJlZCIsInJlYWR5IiwiZmlyZVJlbWFpbmRlcnMiLCJyZW1haW5kZXJzIiwiYXdhaXRJdGVyYXRvciIsImNhbGxOZXh0IiwiZG9UaHJvdyIsInRocm93Iiwib25TdWNjZXNzIiwic3RlcCIsIm9uRXJyb3IiLCJnZXROZXh0IiwiZXh0cmFjdFRyYW5zYWN0aW9uQXJncyIsIl90YWJsZUFyZ3NfIiwic2NvcGVGdW5jIiwiZW50ZXJUcmFuc2FjdGlvblNjb3BlIiwicGFyZW50VHJhbnNhY3Rpb24iLCJzY29wZUZ1bmNJc0FzeW5jIiwiUHJlbWF0dXJlQ29tbWl0IiwicGFkIiwiY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZSIsImluZGV4TG9va3VwIiwiYWxsVmlydHVhbEluZGV4ZXMiLCJhZGRWaXJ0dWFsSW5kZXhlcyIsImtleVRhaWwiLCJsb3dMZXZlbEluZGV4Iiwia2V5UGF0aEFsaWFzIiwiaW5kZXhMaXN0Iiwia2V5TGVuZ3RoIiwiaXNWaXJ0dWFsIiwidmlydHVhbEluZGV4IiwidmlydHVhbEtleVBhdGgiLCJmaW5kQmVzdEluZGV4IiwidHJhbnNsYXRlUmFuZ2UiLCJ0cmFuc2xhdGVSZXF1ZXN0IiwiY3JlYXRlVmlydHVhbEN1cnNvciIsIl9jb250aW51ZSIsInZpcnR1YWxDdXJzb3IiLCJ2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlIiwibGV2ZWwiLCJnZXRPYmplY3REaWZmIiwicHJmeCIsImFwIiwiYnAiLCJhcFR5cGVOYW1lIiwiYnBUeXBlTmFtZSIsImdldEVmZmVjdGl2ZUtleXMiLCJob29rc01pZGRsZXdhcmUiLCJkb3duQ29yZSIsImRvd25UYWJsZSIsInRhYmxlTWlkZGxld2FyZSIsImR4VHJhbnMiLCJkZWxldGluZyIsImNyZWF0aW5nIiwidXBkYXRpbmciLCJhZGRQdXRPckRlbGV0ZSIsImRlbGV0ZVJhbmdlIiwiZ2V0RXhpc3RpbmdWYWx1ZXMiLCJleGlzdGluZ1ZhbHVlcyIsImNvbnRleHRzIiwiZXhpc3RpbmdWYWx1ZSIsImdlbmVyYXRlZFByaW1hcnlLZXkiLCJvYmplY3REaWZmIiwiYWRkaXRpb25hbENoYW5nZXMiLCJyZXF1ZXN0ZWRWYWx1ZSIsImRlbGV0ZU5leHRDaHVuayIsImVmZmVjdGl2ZUtleXMiLCJnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZSIsImNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlIiwiY2FjaGVkUmVzdWx0IiwiaXNFbXB0eVJhbmdlIiwibm9kZSIsIlJhbmdlU2V0IiwiZnJvbU9yVHJlZSIsInRvIiwiZCIsInJhbmdlU2V0IiwibWVyZ2VSYW5nZXMiLCJhZGRLZXkiLCJhZGRLZXlzIiwiZ2V0UmFuZ2VTZXRJdGVyYXRvciIsImxlZnQiLCJyaWdodCIsInIiLCJyZWJhbGFuY2UiLCJyaWdodFdhc0N1dE9mZiIsIm5ld1NldCIsIl9hZGRSYW5nZVNldCIsInJhbmdlc092ZXJsYXAiLCJyYW5nZVNldDEiLCJyYW5nZVNldDIiLCJpMSIsIm5leHRSZXN1bHQxIiwiaTIiLCJuZXh0UmVzdWx0MiIsImtleVByb3ZpZGVkIiwidXAiLCJfYiIsInJvb3RDbG9uZSIsIm9sZFJvb3RSaWdodCIsImNvbXB1dGVEZXB0aCIsIm9ic2VydmFiaWxpdHlNaWRkbGV3YXJlIiwiRlVMTF9SQU5HRSIsInRhYmxlQ2xvbmUiLCJtdXRhdGVkUGFydHMiLCJnZXRSYW5nZVNldCIsInBhcnQiLCJwa1JhbmdlU2V0IiwiZGVsc1JhbmdlU2V0IiwibmV3T2JqcyIsIm9sZENhY2hlIiwib2xkT2JqcyIsInRyYWNrQWZmZWN0ZWRJbmRleGVzIiwiZ2V0UmFuZ2UiLCJyZWFkU3Vic2NyaWJlcnMiLCJtZXRob2QiLCJzdWJzY3IiLCJxdWVyaWVkSW5kZXgiLCJxdWVyaWVkUmFuZ2VzIiwia2V5c1Byb21pc2UiLCJyZXN1bHRpbmdLZXlzIiwicEtleXMiLCJ3YW50VmFsdWVzIiwicGtleSIsImFkZEFmZmVjdGVkSW5kZXgiLCJhZGRLZXlPcktleXMiLCJvbGRLZXkiLCJuZXdLZXkiLCJ2ZXJzaW9uSW5zdGFuY2UiLCJfd2hlblJlYWR5IiwidXNlIiwidW51c2UiLCJtdyIsImNhbmNlbE9wZW4iLCJoYXNBcmd1bWVudHMiLCJkb0RlbGV0ZSIsImJhY2tlbmREQiIsImhhc0JlZW5DbG9zZWQiLCJoYXNGYWlsZWQiLCJkeW5hbWljYWxseU9wZW5lZCIsIl90cmFuc2FjdGlvbiIsIm9ubHlJZkNvbXBhdGlibGUiLCJpZGJNb2RlIiwiU3ViVHJhbnNhY3Rpb24iLCJlbnRlclRyYW5zYWN0aW9uIiwiSW52YWxpZFRhYmxlIiwiZGVwcyIsImRlcGVuZGVuY2llcyIsImJTdGlja3kiLCJuZXdWZXJzaW9uIiwiYWRkb24iLCJzeW1ib2xPYnNlcnZhYmxlIiwib2JzZXJ2YWJsZSIsIk9ic2VydmFibGUiLCJfc3Vic2NyaWJlIiwiZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCIsImxpdmVRdWVyeSIsInF1ZXJpZXIiLCJoYXNWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsIm9ic2VydmVyIiwiZXhlY3V0ZSIsImV4ZWMiLCJjbG9zZWQiLCJhY2N1bU11dHMiLCJjdXJyZW50T2JzIiwic3Vic2NyaXB0aW9uIiwibXV0YXRpb25MaXN0ZW5lciIsInF1ZXJ5aW5nIiwic3RhcnRlZExpc3RlbmluZyIsInNob3VsZE5vdGlmeSIsImRvUXVlcnkiLCJnZXRWYWx1ZSIsImRvbURlcHMiLCJtb3pJbmRleGVkREIiLCJ3ZWJraXRJbmRleGVkREIiLCJtc0luZGV4ZWREQiIsIndlYmtpdElEQktleVJhbmdlIiwiRGV4aWUiLCJkYXRhYmFzZU5hbWUiLCJleGlzdHMiLCJpZ25vcmVUcmFuc2FjdGlvbiIsImFzeW5jIiwiZ2VuZXJhdG9yRm4iLCJzcGF3biIsImN1cnJlbnRUcmFuc2FjdGlvbiIsInByb21pc2VPckZ1bmN0aW9uIiwib3B0aW9uYWxUaW1lb3V0Iiwic2VtVmVyIiwibWF4S2V5IiwiYWRkRXZlbnRMaXN0ZW5lciIsInVwZGF0ZWRQYXJ0cyIsInByb3BhZ2F0aW5nTG9jYWxseSIsImluaXRDdXN0b21FdmVudCIsInByb3BhZ2F0ZUxvY2FsbHkiLCJ1cGRhdGVQYXJ0cyIsIndhc01lIiwiQnJvYWRjYXN0Q2hhbm5lbCIsImJjIiwidW5yZWYiLCJjaGFuZ2VkUGFydHMiLCJwb3N0TWVzc2FnZSIsIm9ubWVzc2FnZSIsImRhdGEiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwidHJpZyIsInJhbmRvbSIsIm1hdGNoQWxsIiwiaW5jbHVkZVVuY29udHJvbGxlZCIsImNsaWVudCIsInBhcnNlIiwibmV3VmFsdWUiLCJzd0NvbnRhaW5lciIsInNlcnZpY2VXb3JrZXIiLCJwcm9wYWdhdGVNZXNzYWdlTG9jYWxseSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/dexie@3.2.7/node_modules/dexie/dist/modern/dexie.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsam%2Fprojects%2Fvericard-scan-pro%2Fapps%2Fweb%2Fsrc%2Fapp%2Fscanner%2Fpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);