"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dexie@3.2.7";
exports.ids = ["vendor-chunks/dexie@3.2.7"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/dexie@3.2.7/node_modules/dexie/dist/modern/dexie.mjs":
/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/dexie@3.2.7/node_modules/dexie/dist/modern/dexie.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dexie: () => (/* binding */ Dexie$1),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   \"default\": () => (/* binding */ Dexie$1),\n/* harmony export */   liveQuery: () => (/* binding */ liveQuery),\n/* harmony export */   mergeRanges: () => (/* binding */ mergeRanges),\n/* harmony export */   rangesOverlap: () => (/* binding */ rangesOverlap)\n/* harmony export */ });\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.7, Wed Mar 20 2024\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */ const _global = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self :  false ? 0 : global;\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== \"undefined\" && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== \"object\") return obj;\n    keys(extension).forEach(function(key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === \"function\") extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach((key)=>{\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === \"function\" ? {\n        get: functionOrGetSet.get,\n        set: functionOrGetSet.set,\n        configurable: true\n    } : {\n        value: functionOrGetSet,\n        configurable: true,\n        writable: true\n    }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function(Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b) throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate) setImmediate(fn);\n    else setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i)=>{\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    } catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (typeof keyPath === \"string\" && hasOwn(obj, keyPath)) return obj[keyPath];\n    if (!keyPath) return obj;\n    if (typeof keyPath !== \"string\") {\n        var rv = [];\n        for(var i = 0, l = keyPath.length; i < l; ++i){\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf(\".\");\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined) return;\n    if (\"isFrozen\" in Object && Object.isFrozen(obj)) return;\n    if (typeof keyPath !== \"string\" && \"length\" in keyPath) {\n        assert(typeof value !== \"string\" && \"length\" in value);\n        for(var i = 0, l = keyPath.length; i < l; ++i){\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    } else {\n        var period = keyPath.indexOf(\".\");\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\") if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);\n                else delete obj[currentKeyPath];\n            } else obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = obj[currentKeyPath] = {};\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        } else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);\n                else delete obj[keyPath];\n            } else obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === \"string\") setByKeyPath(obj, keyPath, undefined);\n    else if (\"length\" in keyPath) [].map.call(keyPath, function(kp) {\n        setByKeyPath(obj, kp, undefined);\n    });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for(var m in obj){\n        if (hasOwn(obj, m)) rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(\",\").concat(flatten([\n    8,\n    16,\n    32,\n    64\n].map((num)=>[\n        \"Int\",\n        \"Uint\",\n        \"Float\"\n    ].map((t)=>t + num + \"Array\")))).filter((t)=>_global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map((t)=>_global[t]);\narrayToObject(intrinsicTypeNames, (x)=>[\n        x,\n        true\n    ]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== \"undefined\" && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== \"object\") return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv) return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for(var i = 0, l = any.length; i < l; ++i){\n            rv.push(innerDeepClone(any[i]));\n        }\n    } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    } else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for(var prop in any){\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function(x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function() {\n    return null;\n};\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike)) return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === \"string\") return [\n            arrayLike\n        ];\n        if (it = getIteratorOf(arrayLike)) {\n            a = [];\n            while(x = it.next(), !x.done)a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null) return [\n            arrayLike\n        ];\n        i = arrayLike.length;\n        if (typeof i === \"number\") {\n            a = new Array(i);\n            while(i--)a[i] = arrayLike[i];\n            return a;\n        }\n        return [\n            arrayLike\n        ];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while(i--)a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== \"undefined\" ? (fn)=>fn[Symbol.toStringTag] === \"AsyncFunction\" : ()=>false;\nvar debug = typeof location !== \"undefined\" && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = ()=>true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK) try {\n        getErrorWithStack.arguments;\n        throw new Error();\n    } catch (e) {\n        return e;\n    }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack) return \"\";\n    numIgnoredFrames = numIgnoredFrames || 0;\n    if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split(\"\\n\").length;\n    return stack.split(\"\\n\").slice(numIgnoredFrames).filter(libraryFilter).map((frame)=>\"\\n\" + frame).join(\"\");\n}\nvar dexieErrorNames = [\n    \"Modify\",\n    \"Bulk\",\n    \"OpenFailed\",\n    \"VersionChange\",\n    \"Schema\",\n    \"Upgrade\",\n    \"InvalidTable\",\n    \"MissingAPI\",\n    \"NoSuchDatabase\",\n    \"InvalidArgument\",\n    \"SubTransaction\",\n    \"Unsupported\",\n    \"Internal\",\n    \"DatabaseClosed\",\n    \"PrematureCommit\",\n    \"ForeignAwait\"\n];\nvar idbDomErrorNames = [\n    \"Unknown\",\n    \"Constraint\",\n    \"Data\",\n    \"TransactionInactive\",\n    \"ReadOnly\",\n    \"Version\",\n    \"NotFound\",\n    \"InvalidState\",\n    \"InvalidAccess\",\n    \"Abort\",\n    \"Timeout\",\n    \"QuotaExceeded\",\n    \"Syntax\",\n    \"DataClone\"\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function() {\n            return this._stack || (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function() {\n        return this.name + \": \" + this.message;\n    }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures).map((key)=>failures[key].toString()).filter((v, i, s)=>s.indexOf(v) === i).join(\"\\n\");\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map((pos)=>failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name)=>(obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name)=>{\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        } else if (typeof msgOrInner === \"string\") {\n            this.message = `${msgOrInner}${!inner ? \"\" : \"\\n \" + inner}`;\n            this.inner = inner || null;\n        } else if (typeof msgOrInner === \"object\") {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name)=>{\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", {\n            get: function() {\n                return this.inner.stack;\n            }\n        });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name)=>{\n    if ([\n        \"Syntax\",\n        \"Type\",\n        \"Range\"\n    ].indexOf(name) === -1) obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\nfunction nop() {}\nfunction mirror(val) {\n    return val;\n}\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror) return f2;\n    return function(val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function() {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined) arguments[0] = res;\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function(modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        if (f2.apply(this, arguments) === false) return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === \"function\") {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while(i--)args[i] = arguments[i];\n            return res.then(function() {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100, MAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === \"undefined\" ? [] : (()=>{\n    let globalP = Promise.resolve();\n    if (typeof crypto === \"undefined\" || !crypto.subtle) return [\n        globalP,\n        getProto(globalP),\n        globalP\n    ];\n    const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([\n        0\n    ]));\n    return [\n        nativeP,\n        getProto(nativeP),\n        globalP\n    ];\n})(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ? ()=>{\n    resolvedGlobalPromise.then(physicalTick);\n} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? ()=>{\n    var hiddenDiv = document.createElement(\"div\");\n    new MutationObserver(()=>{\n        physicalTick();\n        hiddenDiv = null;\n    }).observe(hiddenDiv, {\n        attributes: true\n    });\n    hiddenDiv.setAttribute(\"i\", \"1\");\n} : ()=>{\n    setTimeout(physicalTick, 0);\n};\nvar asap = function(callback, args) {\n    microtickQueue.push([\n        callback,\n        args\n    ]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], currentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: \"global\",\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function() {\n        this.unhandleds.forEach((uh)=>{\n            try {\n                globalError(uh[0], uh[1]);\n            } catch (e) {}\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== \"object\") throw new TypeError(\"Promises must be constructed via new\");\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = this._PSD = PSD;\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== \"function\") {\n        if (fn !== INTERNAL) throw new TypeError(\"Not a function\");\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false) handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function() {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject)=>{\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function(value) {\n        setProp(this, \"then\", value && value.prototype === INTERNAL ? thenProp : {\n            get: function() {\n                return value;\n            },\n            set: thenProp.set\n        });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function(onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function(onRejected) {\n        if (arguments.length === 1) return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === \"function\" ? this.then(null, (err)=>err instanceof type ? handler(err) : PromiseReject(err)) : this.then(null, (err)=>err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function(onFinally) {\n        return this.then((value)=>{\n            onFinally();\n            return value;\n        }, (err)=>{\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function() {\n            if (this._stack) return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null) this._stack = stack;\n                return stack;\n            } finally{\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function(ms, msg) {\n        return ms < Infinity ? new DexiePromise((resolve, reject)=>{\n            var handle = setTimeout(()=>reject(new exceptions.Timeout(msg)), ms);\n            this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n        }) : this;\n    }\n});\nif (typeof Symbol !== \"undefined\" && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, \"Dexie.Promise\");\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : null;\n    this.onRejected = typeof onRejected === \"function\" ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function() {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise(function(resolve, reject) {\n            if (values.length === 0) resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i)=>DexiePromise.resolve(a).then((x)=>{\n                    values[i] = x;\n                    if (!--remaining) resolve(values);\n                }, reject));\n        });\n    },\n    resolve: (value)=>{\n        if (value instanceof DexiePromise) return value;\n        if (value && typeof value.then === \"function\") return new DexiePromise((resolve, reject)=>{\n            value.then(resolve, reject);\n        });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function() {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject)=>{\n            values.map((value)=>DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: ()=>PSD,\n        set: (value)=>PSD = value\n    },\n    totalEchoes: {\n        get: ()=>totalEchoes\n    },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: ()=>asap,\n        set: (value)=>{\n            asap = value;\n        }\n    },\n    rejectionMapper: {\n        get: ()=>rejectionMapper,\n        set: (value)=>{\n            rejectionMapper = value;\n        }\n    },\n    follow: (fn, zoneProps)=>{\n        return new DexiePromise((resolve, reject)=>{\n            return newScope((resolve, reject)=>{\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function() {\n                    run_at_end_of_this_or_next_physical_tick(()=>{\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled) setProp(DexiePromise, \"allSettled\", function() {\n        const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve)=>{\n            if (possiblePromises.length === 0) resolve([]);\n            let remaining = possiblePromises.length;\n            const results = new Array(remaining);\n            possiblePromises.forEach((p, i)=>DexiePromise.resolve(p).then((value)=>results[i] = {\n                        status: \"fulfilled\",\n                        value\n                    }, (reason)=>results[i] = {\n                        status: \"rejected\",\n                        reason\n                    }).then(()=>--remaining || resolve(results)));\n        });\n    });\n    if (NativePromise.any && typeof AggregateError !== \"undefined\") setProp(DexiePromise, \"any\", function() {\n        const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject)=>{\n            if (possiblePromises.length === 0) reject(new AggregateError([]));\n            let remaining = possiblePromises.length;\n            const failures = new Array(remaining);\n            possiblePromises.forEach((p, i)=>DexiePromise.resolve(p).then((value)=>resolve(value), (failure)=>{\n                    failures[i] = failure;\n                    if (!--remaining) reject(new AggregateError(failures));\n                }));\n        });\n    });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn((value)=>{\n            if (promise._state !== null) return;\n            if (value === promise) throw new TypeError(\"A promise cannot be resolved with itself.\");\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === \"function\") {\n                executePromiseTask(promise, (resolve, reject)=>{\n                    value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);\n                });\n            } else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick) endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    } catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null) return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === \"object\" && !reason._promise && tryCatch(()=>{\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: ()=>stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick) endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for(var i = 0, len = listeners.length; i < len; ++i){\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(()=>{\n            if (--numScheduledCalls === 0) finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [\n        cb,\n        promise,\n        listener\n    ]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        } else {\n            if (rejectingErrors.length) rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    } catch (e) {\n        listener.reject(e);\n    } finally{\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit) return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        } else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);\n        if (promise._prev) getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while(microtickQueue.length > 0){\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for(i = 0; i < l; ++i){\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    }while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach((p)=>{\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while(i)finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(()=>{\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some((p)=>p._value === promise._value)) unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while(i)if (unhandledErrors[--i]._value === promise._value) {\n        unhandledErrors.splice(i, 1);\n        return;\n    }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function() {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        } catch (e) {\n            errorCatcher && errorCatcher(e);\n        } finally{\n            switchToZone(outerScope, false);\n            if (wasRootExec) endMicroTickScope();\n        }\n    };\n}\nconst task = {\n    awaits: 0,\n    echoes: 0,\n    id: 0\n};\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: {\n            value: DexiePromise,\n            configurable: true,\n            writable: true\n        },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props) extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function() {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0) psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id) task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits) return false;\n    if (--task.awaits === 0) task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif ((\"\" + nativePromiseThen).indexOf(\"[native code]\") === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then((x)=>{\n            decrementExpectedAwaits();\n            return x;\n        }, (e)=>{\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD) return;\n    PSD = targetZone;\n    if (currentZone === globalPSD) globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, \"Promise\", targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled) GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any) GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    } finally{\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== \"function\" ? fn : function() {\n        var outerZone = PSD;\n        if (possibleAwait) incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        } finally{\n            switchToZone(outerZone, false);\n            if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function(onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    } catch (e) {}\n    if (rv !== false) try {\n        var event, eventData = {\n            promise: promise,\n            reason: err\n        };\n        if (_global.document && document.createEvent) {\n            event = document.createEvent(\"Event\");\n            event.initEvent(UNHANDLEDREJECTION, true, true);\n            extend(event, eventData);\n        } else if (_global.CustomEvent) {\n            event = new CustomEvent(UNHANDLEDREJECTION, {\n                detail: eventData\n            });\n            extend(event, eventData);\n        }\n        if (event && _global.dispatchEvent) {\n            dispatchEvent(event);\n            if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {\n                _global.onunhandledrejection(event);\n            } catch (_) {}\n        }\n        if (debug && event && !event.defaultPrevented) {\n            console.warn(`Unhandled rejection: ${err.stack || err}`);\n        }\n    } catch (e) {}\n}\nvar rejection = DexiePromise.reject;\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(()=>tempTransaction(db, mode, storeNames, fn));\n    } else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n            db._state.PR1398_maxLoop = 3;\n        } catch (ex) {\n            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                console.warn(\"Dexie: Need to reopen db\");\n                db._close();\n                return db.open().then(()=>tempTransaction(db, mode, storeNames, fn));\n            }\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject)=>{\n            return newScope(()=>{\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then((result)=>{\n            return trans._completion.then(()=>result);\n        });\n    }\n}\nconst DEXIE_VERSION = \"3.2.7\";\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== \"undefined\" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = (frame)=>!/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = \"__dbnames\";\nconst READONLY = \"readonly\";\nconst READWRITE = \"readwrite\";\nfunction combine(filter1, filter2) {\n    return filter1 ? filter2 ? function() {\n        return filter1.apply(this, arguments) && filter2.apply(this, arguments);\n    } : filter1 : filter2;\n}\nconst AnyRange = {\n    type: 3,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [\n        []\n    ],\n    upperOpen: false\n};\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath) ? (obj)=>{\n        if (obj[keyPath] === undefined && keyPath in obj) {\n            obj = deepClone(obj);\n            delete obj[keyPath];\n        }\n        return obj;\n    } : (obj)=>obj;\n}\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName]) throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(()=>trans._promise(mode, checkTableInTransaction, writeLocked), {\n                trans: trans,\n                transless: PSD.transless || PSD\n            }) : tempTransaction(this.db, mode, [\n                this.name\n            ], checkTableInTransaction);\n        } finally{\n            if (wasRootExec) endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);\n        return this._trans(\"readonly\", (trans)=>{\n            return this.core.get({\n                trans,\n                key: keyOrCrit\n            }).then((res)=>this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === \"string\") return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit)) return new this.db.WhereClause(this, `[${indexOrCrit.join(\"+\")}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter((ix)=>{\n            if (ix.compound && keyPaths.every((keyPath)=>ix.keyPath.indexOf(keyPath) >= 0)) {\n                for(let i = 0; i < keyPaths.length; ++i){\n                    if (keyPaths.indexOf(ix.keyPath[i]) === -1) return false;\n                }\n                return true;\n            }\n            return false;\n        }).sort((a, b)=>a.keyPath.length - b.keyPath.length)[0];\n        if (compoundIndex && this.db._maxKey !== maxString) {\n            const keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n            return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map((kp)=>indexOrCrit[kp]));\n        }\n        if (!compoundIndex && debug) console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` + `compound index [${keyPaths.join(\"+\")}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            } catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath)=>{\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ? combine(prevFilterFn, index && index.multi ? (x)=>{\n                    const prop = getByKeyPath(x, keyPath);\n                    return isArray(prop) && prop.some((item)=>equals(value, item));\n                } : (x)=>equals(value, getByKeyPath(x, keyPath))) : prevFilterFn\n            ];\n        }, [\n            null,\n            null\n        ]);\n        return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals(\"\");\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? `[${index.join(\"+\")}]` : index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = (obj)=>{\n            if (!obj) return obj;\n            const res = Object.create(constructor.prototype);\n            for(var m in obj)if (hasOwn(obj, m)) try {\n                res[m] = obj[m];\n            } catch (_) {}\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans(\"readwrite\", (trans)=>{\n            return this.core.mutate({\n                trans,\n                type: \"add\",\n                keys: key != null ? [\n                    key\n                ] : null,\n                values: [\n                    objToAdd\n                ]\n            });\n        }).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult)=>{\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                } catch (_) {}\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === \"object\" && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined) return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach((keyPath)=>{\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                } else {\n                    modifications(keyOrObject, {\n                        value: keyOrObject,\n                        primKey: key\n                    });\n                }\n            } catch (_a) {}\n            return this.where(\":id\").equals(key).modify(modifications);\n        } else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"put\",\n                values: [\n                    objToAdd\n                ],\n                keys: key != null ? [\n                    key\n                ] : null\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult)=>{\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                } catch (_) {}\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"delete\",\n                keys: [\n                    key\n                ]\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"deleteRange\",\n                range: AnyRange\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans(\"readonly\", (trans)=>{\n            return this.core.getMany({\n                keys,\n                trans\n            }).then((result)=>result.map((res)=>this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans(\"readwrite\", (trans)=>{\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n            return this.core.mutate({\n                trans,\n                type: \"add\",\n                keys: keys,\n                values: objectsToAdd,\n                wantResults\n            }).then(({ numFailures, results, lastResult, failures })=>{\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0) return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans(\"readwrite\", (trans)=>{\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n            return this.core.mutate({\n                trans,\n                type: \"put\",\n                keys: keys,\n                values: objectsToPut,\n                wantResults\n            }).then(({ numFailures, results, lastResult, failures })=>{\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0) return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans(\"readwrite\", (trans)=>{\n            return this.core.mutate({\n                trans,\n                type: \"delete\",\n                keys: keys\n            });\n        }).then(({ numFailures, lastResult, failures })=>{\n            if (numFailures === 0) return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function(eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while(--i)args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        } else if (typeof eventName === \"string\") {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for(var i = 1, l = arguments.length; i < l; ++i){\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === \"object\") return addConfiguredEvents(eventName);\n        if (!chainFunction) chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction) defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function(cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function(cb) {\n                context.subscribers = context.subscribers.filter(function(fn) {\n                    return fn !== cb;\n                });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function(eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            } else if (args === \"asap\") {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while(i--)args[i] = arguments[i];\n                    context.subscribers.forEach(function(fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            } else throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({\n        prototype\n    });\n    return constructor;\n}\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [\n                hookCreatingChain,\n                nop\n            ],\n            \"reading\": [\n                pureFunctionChain,\n                mirror\n            ],\n            \"updating\": [\n                hookUpdatingChain,\n                nop\n            ],\n            \"deleting\": [\n                hookDeletingChain,\n                nop\n            ]\n        });\n    });\n}\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? ()=>combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey) return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index) throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === \"prev\",\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    } else {\n        const set = {};\n        const union = (item, cursor, advance)=>{\n            if (!filter || filter(cursor, advance, (result)=>cursor.stop(result), (err)=>cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = \"\" + primaryKey;\n                if (key === \"[object ArrayBuffer]\") key = \"\" + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a)=>fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then((cursor)=>{\n        if (cursor) {\n            return cursor.start(()=>{\n                var c = ()=>cursor.continue();\n                if (!filter || filter(cursor, (advancer)=>c = advancer, (val)=>{\n                    cursor.stop(val);\n                    c = nop;\n                }, (e)=>{\n                    cursor.fail(e);\n                    c = nop;\n                })) wrappedFn(cursor.value, cursor, (advancer)=>c = advancer);\n                c();\n            });\n        }\n    });\n}\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === \"Array\") return 1;\n            if (tb === \"Array\") return -1;\n            if (ta === \"binary\") return 1;\n            if (tb === \"binary\") return -1;\n            if (ta === \"string\") return 1;\n            if (tb === \"string\") return -1;\n            if (ta === \"Date\") return 1;\n            if (tb !== \"Date\") return NaN;\n            return -1;\n        }\n        switch(ta){\n            case \"number\":\n            case \"Date\":\n            case \"string\":\n                return a > b ? 1 : a < b ? -1 : 0;\n            case \"binary\":\n                {\n                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n                }\n            case \"Array\":\n                return compareArrays(a, b);\n        }\n    } catch (_a) {}\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for(let i = 0; i < l; ++i){\n        const res = cmp(a[i], b[i]);\n        if (res !== 0) return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for(let i = 0; i < l; ++i){\n        if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== \"object\") return t;\n    if (ArrayBuffer.isView(x)) return \"binary\";\n    const tsTag = toStringTag(x);\n    return tsTag === \"ArrayBuffer\" ? \"binary\" : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array) return a;\n    if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans(\"readonly\", fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans(\"readwrite\", fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props) extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read((trans)=>iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read((trans)=>{\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then((count)=>Math.min(count, ctx.limit));\n            } else {\n                var count = 0;\n                return iter(ctx, ()=>{\n                    ++count;\n                    return false;\n                }, trans, coreTable).then(()=>count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split(\".\").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i) return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function(a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read((trans)=>{\n            var ctx = this._ctx;\n            if (ctx.dir === \"next\" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result })=>valueMapper ? result.map(valueMapper) : result);\n            } else {\n                const a = [];\n                return iter(ctx, (item)=>a.push(item), trans, ctx.table.core).then(()=>a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0) return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, ()=>{\n                var offsetLeft = offset;\n                return (cursor, advance)=>{\n                    if (offsetLeft === 0) return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(()=>{\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        } else {\n            addReplayFilter(ctx, ()=>{\n                var offsetLeft = offset;\n                return ()=>--offsetLeft < 0;\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, ()=>{\n            var rowsLeft = numRows;\n            return function(cursor, advance, resolve) {\n                if (--rowsLeft <= 0) advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function(cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            } else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function(a) {\n            return a[0];\n        }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function(cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = this._ctx.dir === \"prev\" ? \"next\" : \"prev\";\n        if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function(val, cursor) {\n            cb(cursor.key, cursor);\n        });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function(val, cursor) {\n            cb(cursor.primaryKey, cursor);\n        });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function(item, cursor) {\n            a.push(cursor.key);\n        }).then(function() {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === \"next\" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read((trans)=>{\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result })=>result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function(item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function() {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function(a) {\n            return a[0];\n        }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi) return this;\n        var set = {};\n        addFilter(this._ctx, function(cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write((trans)=>{\n            var modifyer;\n            if (typeof changes === \"function\") {\n                modifyer = changes;\n            } else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function(item) {\n                    var anythingModified = false;\n                    for(var i = 0; i < numKeys; ++i){\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res)=>{\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)){\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then((keys)=>{\n                const nextChunk = (offset)=>{\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then((values)=>{\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for(let i = 0; i < count; ++i){\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                } else {\n                                    putValues.push(ctx.value);\n                                    if (outbound) putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== \"function\" || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 && coreTable.mutate({\n                            trans,\n                            type: \"add\",\n                            values: addValues\n                        }).then((res)=>{\n                            for(let pos in res.failures){\n                                deleteKeys.splice(parseInt(pos), 1);\n                            }\n                            applyMutateResult(addValues.length, res);\n                        })).then(()=>(putValues.length > 0 || criteria && typeof changes === \"object\") && coreTable.mutate({\n                                trans,\n                                type: \"put\",\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== \"function\" && changes\n                            }).then((res)=>applyMutateResult(putValues.length, res))).then(()=>(deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({\n                                trans,\n                                type: \"delete\",\n                                keys: deleteKeys,\n                                criteria\n                            }).then((res)=>applyMutateResult(deleteKeys.length, res))).then(()=>{\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(()=>{\n                    if (totalFailures.length > 0) throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {\n            return this._write((trans)=>{\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({\n                    trans,\n                    query: {\n                        index: primaryKey,\n                        range: coreRange\n                    }\n                }).then((count)=>{\n                    return ctx.table.core.mutate({\n                        trans,\n                        type: \"deleteRange\",\n                        range: coreRange\n                    }).then(({ failures, lastResult, results, numFailures })=>{\n                        if (numFailures) throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map((pos)=>failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx)=>ctx.value = null;\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator) try {\n            keyRange = keyRangeGenerator();\n        } catch (ex) {\n            error = ex;\n        }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, ()=>rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ? (s)=>s.toUpperCase() : (s)=>s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ? (s)=>s.toLowerCase() : (s)=>s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for(var i = 0; i < length; ++i){\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0) llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\") return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\") return key.substr(0, upperNeedle.length);\n    return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every((s)=>typeof s === \"string\")) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = dir === \"next\" ? simpleCompare : simpleCompareReverse;\n        var needleBounds = needles.map(function(needle) {\n            return {\n                lower: lower(needle),\n                upper: upper(needle)\n            };\n        }).sort(function(a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function(nb) {\n            return nb.upper;\n        });\n        lowerNeedles = needleBounds.map(function(nb) {\n            return nb.lower;\n        });\n        direction = dir;\n        nextKeySuffix = dir === \"next\" ? \"\" : suffix;\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, ()=>createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function(direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function(cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== \"string\") return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        } else {\n            var lowestPossibleCasing = null;\n            for(var i = firstPossibleNeedle; i < needlesLen; ++i){\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function() {\n                    cursor.continue(lowestPossibleCasing + nextKeySuffix);\n                });\n            } else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1,\n        lower: value,\n        upper: value\n    };\n}\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);\n            return new this.Collection(this, ()=>createRange(lower, upper, !includeLower, !includeUpper));\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>rangeEqual(value));\n    }\n    above(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== \"string\") return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\") return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>x.indexOf(a[0]) === 0, [\n            str\n        ], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a)=>x === a[0], [\n            str\n        ], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>a.some((n)=>x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0) return emptyCollection(this);\n        const c = new this.Collection(this, ()=>createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = (direction)=>{\n            compare = direction === \"next\" ? this._ascending : this._descending;\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve)=>{\n            const key = cursor.key;\n            while(compare(key, set[i]) > 0){\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            } else {\n                advance(()=>{\n                    cursor.continue(set[i]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([\n            [\n                minKey,\n                value\n            ],\n            [\n                value,\n                this.db._maxKey\n            ]\n        ], {\n            includeLowers: false,\n            includeUppers: false\n        });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val)=>res ? res.concat([\n                [\n                    res[res.length - 1][1],\n                    val\n                ]\n            ]) : [\n                [\n                    minKey,\n                    val\n                ]\n            ], null);\n        ranges.push([\n            set[set.length - 1],\n            this.db._maxKey\n        ]);\n        return this.inAnyRange(ranges, {\n            includeLowers: false,\n            includeUppers: false\n        });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0) return emptyCollection(this);\n        if (!ranges.every((range)=>range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for(; i < l; ++i){\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l) ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) {\n            return sortDirection(a[0], b[0]);\n        }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        } catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ? (key)=>ascending(key, set[rangePos][1]) > 0 : (key)=>ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ? (key)=>descending(key, set[rangePos][0]) > 0 : (key)=>descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, ()=>createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = (direction)=>{\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            } else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve)=>{\n            var key = cursor.key;\n            while(checkKey(key)){\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            } else {\n                advance(()=>{\n                    if (sortDirection === ascending) cursor.continue(set[rangePos][0]);\n                    else cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every((s)=>typeof s === \"string\")) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0) return emptyCollection(this);\n        return this.inAnyRange(set.map((str)=>[\n                str,\n                str + maxString\n            ]));\n    }\n}\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB1 = db._deps.indexedDB;\n        if (!indexedDB1) throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB1.cmp.bind(indexedDB1);\n        this._descending = (a, b)=>indexedDB1.cmp(b, a);\n        this._max = (a, b)=>indexedDB1.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b)=>indexedDB1.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\nfunction eventRejectHandler(reject) {\n    return wrap(function(event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation) event.stopPropagation();\n    if (event.preventDefault) event.preventDefault();\n}\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = \"storagemutated\";\nconst STORAGE_MUTATED_DOM_EVENT_NAME = \"x-storagemutated-1\";\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global) PSD.lockOwnerFor = null;\n            while(this._blockedFuncs.length > 0 && !this._locked()){\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                } catch (e) {}\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode) return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch(dbOpenError && dbOpenError.name){\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active) throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n            durability: this.chromeTransactionDurability\n        }) : idbdb.transaction(this.storeNames, this.mode, {\n            durability: this.chromeTransactionDurability\n        }));\n        idbtrans.onerror = wrap((ev)=>{\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap((ev)=>{\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(()=>{\n            this.active = false;\n            this._resolve();\n            if (\"mutatedParts\" in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === \"readwrite\" && this.mode !== \"readwrite\") return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active) return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject)=>{\n                this._blockedFuncs.push([\n                    ()=>{\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    },\n                    PSD\n                ]);\n            });\n        } else if (bWriteLock) {\n            return newScope(()=>{\n                var p = new DexiePromise((resolve, reject)=>{\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then) rv.then(resolve, reject);\n                });\n                p.finally(()=>this._unlock());\n                p._lib = true;\n                return p;\n            });\n        } else {\n            var p = new DexiePromise((resolve, reject)=>{\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then) rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(()=>promise);\n        } else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while(root._waitingQueue.length)root._waitingQueue.shift()();\n                if (root._waitingFor) store.get(-Infinity).onsuccess = spin;\n            })();\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject)=>{\n            promise.then((res)=>root._waitingQueue.push(wrap(resolve.bind(null, res))), (err)=>root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(()=>{\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans) this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = this._memoizedTables || (this._memoizedTables = {});\n        if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject)=>{\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(()=>{\n            this.active = false;\n            this.on.complete.fire();\n        }, (e)=>{\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? \"&\" : \"\") + (multi ? \"*\" : \"\") + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === \"string\" ? keyPath : keyPath ? \"[\" + [].join.call(keyPath, \"+\") + \"]\" : \"\";\n}\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, (index)=>[\n                index.name,\n                index\n            ])\n    };\n}\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange)=>{\n    try {\n        IdbKeyRange.only([\n            []\n        ]);\n        getMaxKey = ()=>[\n                []\n            ];\n        return [\n            []\n        ];\n    } catch (e) {\n        getMaxKey = ()=>maxString;\n        return maxString;\n    }\n};\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return ()=>undefined;\n    } else if (typeof keyPath === \"string\") {\n        return getSinglePathKeyExtractor(keyPath);\n    } else {\n        return (obj)=>getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split(\".\");\n    if (split.length === 1) {\n        return (obj)=>obj[keyPath];\n    } else {\n        return (obj)=>getByKeyPath(obj, keyPath);\n    }\n}\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ? \":id\" : typeof keyPath === \"string\" ? keyPath : `[${keyPath.join(\"+\")}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map((table)=>trans.objectStore(table)).map((store)=>{\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map((indexName)=>store.index(indexName)).map((index)=>{\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath)=>indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && \"getAll\" in trans.objectStore(tables[0]) && !(typeof navigator !== \"undefined\" && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3) return null;\n        if (range.type === 4) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject)=>{\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== \"delete\" && type !== \"deleteRange\") throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || {\n                    length: 1\n                };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0) return resolve({\n                    numFailures: 0,\n                    failures: {},\n                    results: [],\n                    lastResult: undefined\n                });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = (event)=>{\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === \"deleteRange\") {\n                    if (range.type === 4) return resolve({\n                        numFailures,\n                        failures,\n                        results: [],\n                        lastResult: undefined\n                    });\n                    if (range.type === 3) reqs.push(req = store.clear());\n                    else reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                } else {\n                    const [args1, args2] = isAddOrPut ? outbound ? [\n                        values,\n                        keys\n                    ] : [\n                        values,\n                        null\n                    ] : [\n                        keys,\n                        null\n                    ];\n                    if (isAddOrPut) {\n                        for(let i = 0; i < length; ++i){\n                            reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    } else {\n                        for(let i = 0; i < length; ++i){\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = (event)=>{\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i)=>req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map((req)=>req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = (event)=>{\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject)=>{\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ? store : store.index(index.name);\n                const direction = reverse ? unique ? \"prevunique\" : \"prev\" : unique ? \"nextunique\" : \"next\";\n                const req = values || !(\"openKeyCursor\" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap((ev)=>{\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = ()=>{\n                        throw new Error(\"Cursor not started\");\n                    };\n                    const doThrowCursorIsStopped = ()=>{\n                        throw new Error(\"Cursor not stopped\");\n                    };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function() {\n                        let gotOne = 1;\n                        return this.start(()=>gotOne-- ? this.continue() : this.stop()).then(()=>this);\n                    };\n                    cursor.start = (callback)=>{\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration)=>{\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = (value)=>{\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = ()=>{\n                            if (req.result) {\n                                try {\n                                    callback();\n                                } catch (err) {\n                                    cursor.fail(err);\n                                }\n                            } else {\n                                cursor.done = true;\n                                cursor.start = ()=>{\n                                    throw new Error(\"Cursor behind last entry\");\n                                };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap((ev)=>{\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request)=>{\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0) return resolve({\n                        result: []\n                    });\n                    if (hasGetAll) {\n                        const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = (event)=>resolve({\n                                result: event.target.result\n                            });\n                        req.onerror = eventRejectHandler(reject);\n                    } else {\n                        let count = 0;\n                        const req = values || !(\"openKeyCursor\" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = (event)=>{\n                            const cursor = req.result;\n                            if (!cursor) return resolve({\n                                result\n                            });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit) return resolve({\n                                result\n                            });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany ({ trans, keys }) {\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = (event)=>{\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null) ;\n                        if (++callbackCount === keyCount) resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for(let i = 0; i < length; ++i){\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0) resolve(result);\n                });\n            },\n            get ({ trans, key }) {\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = (event)=>resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count ({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject)=>{\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap((ev)=>resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map((tableSchema)=>createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach((table)=>tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table (name) {\n            const result = tableMap[name];\n            if (!result) throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create })=>({\n            ...down,\n            ...create(down)\n        }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB: indexedDB1 }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach((table)=>{\n        const tableName = table.name;\n        if (db.core.schema.tables.some((tbl)=>tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach((tableName)=>{\n        const schema = dbschema[tableName];\n        objs.forEach((obj)=>{\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || \"value\" in propDesc && propDesc.value === undefined) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get () {\n                            return this.table(tableName);\n                        },\n                        set (value) {\n                            defineProperty(this, tableName, {\n                                value,\n                                writable: true,\n                                configurable: true,\n                                enumerable: true\n                            });\n                        }\n                    });\n                } else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach((obj)=>{\n        for(let key in obj){\n            if (obj[key] instanceof db.Table) delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction(\"readwrite\", db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(()=>{\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach((tableName)=>{\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(()=>db.on.populate.fire(trans)).catch(rejectTransaction);\n        } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter((v)=>v._cfg.version >= oldVersion);\n    versToRun.forEach((version)=>{\n        queue.push(()=>{\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach((tuple)=>{\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach((change)=>{\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                } else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach((idx)=>addIndex(store, idx));\n                    change.change.forEach((idx)=>{\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach((idxName)=>store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach((table)=>{\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [\n                    db.Transaction.prototype\n                ]);\n                setApiOnPlace(db, [\n                    db.Transaction.prototype\n                ], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(()=>{\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return returnValue && typeof returnValue.then === \"function\" ? DexiePromise.resolve(returnValue) : promiseFollowed.then(()=>returnValue);\n            }\n        });\n        queue.push((idbtrans)=>{\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [\n                db.Transaction.prototype\n            ]);\n            setApiOnPlace(db, [\n                db.Transaction.prototype\n            ], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();\n    }\n    return runQueue().then(()=>{\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for(table in oldSchema){\n        if (!newSchema[table]) diff.del.push(table);\n    }\n    for(table in newSchema){\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([\n                table,\n                newDef\n            ]);\n        } else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if (\"\" + (oldDef.primKey.keyPath || \"\") !== \"\" + (newDef.primKey.keyPath || \"\") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {\n                change.recreate = true;\n                diff.change.push(change);\n            } else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for(idxName in oldIndexes){\n                    if (!newIndexes[idxName]) change.del.push(idxName);\n                }\n                for(idxName in newIndexes){\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx) change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {\n        keyPath: primKey.keyPath,\n        autoIncrement: primKey.auto\n    } : {\n        autoIncrement: primKey.auto\n    });\n    indexes.forEach((idx)=>addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach((tableName)=>{\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach((storeName)=>newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, {\n        unique: idx.unique,\n        multiEntry: idx.multi\n    });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach((storeName)=>{\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for(let j = 0; j < store.indexNames.length; ++j){\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [\n        db._allTables\n    ], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some((ch)=>ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for(let i = 0; i < storeNames.length; ++i){\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = \"getAll\" in store;\n        for(let j = 0; j < store.indexNames.length; ++j){\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === \"string\" ? keyPath : \"[\" + slice(keyPath).join(\"+\") + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== \"undefined\" && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(\",\").map((index, indexNum)=>{\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split(\"+\") : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach((tableName)=>{\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi) throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach((idx)=>{\n                    if (idx.auto) throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath) throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach((version)=>{\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = version._cfg.dbschema = {};\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [\n            db._allTables,\n            db,\n            db.Transaction.prototype\n        ]);\n        setApiOnPlace(db, [\n            db._allTables,\n            db,\n            db.Transaction.prototype,\n            this._cfg.tables\n        ], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\nfunction getDbNamesTable(indexedDB1, IDBKeyRange) {\n    let dbNamesDB = indexedDB1[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB1[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB: indexedDB1,\n            IDBKeyRange\n        });\n        dbNamesDB.version(1).stores({\n            dbnames: \"name\"\n        });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB1) {\n    return indexedDB1 && typeof indexedDB1.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB: indexedDB1, IDBKeyRange }) {\n    return hasDatabasesNative(indexedDB1) ? Promise.resolve(indexedDB1.databases()).then((infos)=>infos.map((info)=>info.name).filter((name)=>name !== DBNAMES_DB)) : getDbNamesTable(indexedDB1, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB: indexedDB1, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).put({\n        name\n    }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB: indexedDB1, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).delete(name).catch(nop);\n}\nfunction vip(fn) {\n    return newScope(function() {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases) return Promise.resolve();\n    var intervalId;\n    return new Promise(function(resolve) {\n        var tryIdb = function() {\n            return indexedDB.databases().finally(resolve);\n        };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function() {\n        return clearInterval(intervalId);\n    });\n}\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB: indexedDB1 } = db._deps;\n    if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(()=>state.dbOpenError ? rejection(state.dbOpenError) : db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed(\"db.open() was cancelled\");\n    }\n    let resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;\n    const tryOpenDB = ()=>new DexiePromise((resolve, reject)=>{\n            throwIfCancelled();\n            if (!indexedDB1) throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ? indexedDB1.open(dbName) : indexedDB1.open(dbName, Math.round(db.verno * 10));\n            if (!req) throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap((e)=>{\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB1.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(()=>{\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                } else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(()=>{\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0) try {\n                    const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), \"readonly\");\n                    if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);\n                    else {\n                        adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                        if (!verifyInstalledSchema(db, tmpTrans)) {\n                            console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                        }\n                    }\n                    generateMiddlewareStacks(db, tmpTrans);\n                } catch (e) {}\n                connections.push(db);\n                idbdb.onversionchange = wrap((ev)=>{\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap((ev)=>{\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated) _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }).catch((err)=>{\n            if (err && err.name === \"UnknownError\" && state.PR1398_maxLoop > 0) {\n                state.PR1398_maxLoop--;\n                console.warn(\"Dexie: Workaround for Chrome UnknownError on open()\");\n                return tryOpenDB();\n            } else {\n                return DexiePromise.reject(err);\n            }\n        });\n    return DexiePromise.race([\n        openCanceller,\n        (typeof navigator === \"undefined\" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n    ]).then(()=>{\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(()=>db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(()=>remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(()=>{\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(()=>{\n        return db;\n    }).catch((err)=>{\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        } catch (_a) {}\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(()=>{\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\nfunction awaitIterator(iterator) {\n    var callNext = (result)=>iterator.next(result), doThrow = (error)=>iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val)=>{\n            var next = getNext(val), value = next.value;\n            return next.done ? value : !value || typeof value.then !== \"function\" ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);\n        };\n    }\n    return step(callNext)();\n}\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2) throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while(--i)args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [\n        mode,\n        tables,\n        scopeFunc\n    ];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(()=>{\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        } else {\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            } catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn(\"Dexie: Need to reopen db\");\n                    db._close();\n                    return db.open().then(()=>enterTransactionScope(db, mode, storeNames, null, scopeFunc));\n                }\n                return rejection(ex);\n            }\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(()=>{\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                } else if (typeof returnValue.next === \"function\" && typeof returnValue.throw === \"function\") {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === \"function\" ? DexiePromise.resolve(returnValue).then((x)=>trans.active ? x : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"))) : promiseFollowed.then(()=>returnValue)).then((x)=>{\n            if (parentTransaction) trans._resolve();\n            return trans._completion.then(()=>x);\n        }).catch((e)=>{\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [\n        a\n    ];\n    for(let i = 0; i < count; ++i)result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table (tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];\n                const keyLength = keyPath == null ? 0 : typeof keyPath === \"string\" ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b)=>a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [\n                primaryKey\n            ];\n            for (const index of schema.indexes){\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1 ? 2 : range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count (req) {\n                    return table.count(translateRequest(req));\n                },\n                query (req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor (req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual) return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: {\n                                value: _continue\n                            },\n                            continuePrimaryKey: {\n                                value (key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get () {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get () {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ? key[0] : key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get () {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req)).then((cursor)=>cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || \"\";\n    keys(a).forEach((prop)=>{\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        } else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === \"object\" && typeof bp === \"object\" && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                } else if (apTypeName === \"Object\") {\n                    getObjectDiff(ap, bp, rv, prfx + prop + \".\");\n                } else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            } else if (ap !== bp) rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop)=>{\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === \"delete\") return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore)=>({\n            ...downCore,\n            table (tableName) {\n                const downTable = downCore.table(tableName);\n                const { primaryKey } = downTable.schema;\n                const tableMiddleware = {\n                    ...downTable,\n                    mutate (req) {\n                        const dxTrans = PSD.trans;\n                        const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                        switch(req.type){\n                            case \"add\":\n                                if (creating.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"put\":\n                                if (creating.fire === nop && updating.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"delete\":\n                                if (deleting.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"deleteRange\":\n                                if (deleting.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>deleteRange(req), true);\n                        }\n                        return downTable.mutate(req);\n                        function addPutOrDelete(req) {\n                            const dxTrans = PSD.trans;\n                            const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                            if (!keys) throw new Error(\"Keys missing\");\n                            req = req.type === \"add\" || req.type === \"put\" ? {\n                                ...req,\n                                keys\n                            } : {\n                                ...req\n                            };\n                            if (req.type !== \"delete\") req.values = [\n                                ...req.values\n                            ];\n                            if (req.keys) req.keys = [\n                                ...req.keys\n                            ];\n                            return getExistingValues(downTable, req, keys).then((existingValues)=>{\n                                const contexts = keys.map((key, i)=>{\n                                    const existingValue = existingValues[i];\n                                    const ctx = {\n                                        onerror: null,\n                                        onsuccess: null\n                                    };\n                                    if (req.type === \"delete\") {\n                                        deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                    } else if (req.type === \"add\" || existingValue === undefined) {\n                                        const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                        if (key == null && generatedPrimaryKey != null) {\n                                            key = generatedPrimaryKey;\n                                            req.keys[i] = key;\n                                            if (!primaryKey.outbound) {\n                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                            }\n                                        }\n                                    } else {\n                                        const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                        const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                        if (additionalChanges) {\n                                            const requestedValue = req.values[i];\n                                            Object.keys(additionalChanges).forEach((keyPath)=>{\n                                                if (hasOwn(requestedValue, keyPath)) {\n                                                    requestedValue[keyPath] = additionalChanges[keyPath];\n                                                } else {\n                                                    setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                                }\n                                            });\n                                        }\n                                    }\n                                    return ctx;\n                                });\n                                return downTable.mutate(req).then(({ failures, results, numFailures, lastResult })=>{\n                                    for(let i = 0; i < keys.length; ++i){\n                                        const primKey = results ? results[i] : keys[i];\n                                        const ctx = contexts[i];\n                                        if (primKey == null) {\n                                            ctx.onerror && ctx.onerror(failures[i]);\n                                        } else {\n                                            ctx.onsuccess && ctx.onsuccess(req.type === \"put\" && existingValues[i] ? req.values[i] : primKey);\n                                        }\n                                    }\n                                    return {\n                                        failures,\n                                        results,\n                                        numFailures,\n                                        lastResult\n                                    };\n                                }).catch((error)=>{\n                                    contexts.forEach((ctx)=>ctx.onerror && ctx.onerror(error));\n                                    return Promise.reject(error);\n                                });\n                            });\n                        }\n                        function deleteRange(req) {\n                            return deleteNextChunk(req.trans, req.range, 10000);\n                        }\n                        function deleteNextChunk(trans, range, limit) {\n                            return downTable.query({\n                                trans,\n                                values: false,\n                                query: {\n                                    index: primaryKey,\n                                    range\n                                },\n                                limit\n                            }).then(({ result })=>{\n                                return addPutOrDelete({\n                                    type: \"delete\",\n                                    keys: result,\n                                    trans\n                                }).then((res)=>{\n                                    if (res.numFailures > 0) return Promise.reject(res.failures[0]);\n                                    if (result.length < limit) {\n                                        return {\n                                            failures: [],\n                                            numFailures: 0,\n                                            lastResult: undefined\n                                        };\n                                    } else {\n                                        return deleteNextChunk(trans, {\n                                            ...range,\n                                            lower: result[result.length - 1],\n                                            lowerOpen: true\n                                        }, limit);\n                                    }\n                                });\n                            });\n                        }\n                    }\n                };\n                return tableMiddleware;\n            }\n        })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\" ? Promise.resolve([]) : table.getMany({\n        trans: req.trans,\n        keys: effectiveKeys,\n        cache: \"immutable\"\n    });\n}\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache) return null;\n        if (cache.keys.length < keys.length) return null;\n        const result = [];\n        for(let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i){\n            if (cmp(cache.keys[i], keys[j]) !== 0) continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    } catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core)=>{\n        return {\n            table: (tableName)=>{\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req)=>{\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res)=>{\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req)=>{\n                        if (req.type !== \"add\") req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    }\n                };\n            }\n        };\n    }\n};\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function(fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? {\n            d: 1,\n            from: fromOrTree,\n            to: arguments.length > 1 ? to : fromOrTree\n        } : {\n            d: 0\n        });\n    } else {\n        const rv = new RangeSet();\n        if (fromOrTree && \"d\" in fromOrTree) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add (rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey (key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys (keys) {\n        keys.forEach((key)=>addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol] () {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff)) return;\n    if (diff > 0) throw RangeError();\n    if (isEmptyRange(target)) return extend(target, {\n        from,\n        to,\n        d: 1\n    });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left ? addRange(left, from, to) : target.l = {\n            from,\n            to,\n            d: 1,\n            l: null,\n            r: null\n        };\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right ? addRange(right, from, to) : target.r = {\n            from,\n            to,\n            d: 1,\n            l: null,\n            r: null\n        };\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l) _addRangeSet(target, l);\n        if (r) _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done) return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while(!nextResult1.done && !nextResult2.done){\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;\n        cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : {\n        s: 0,\n        n: node\n    };\n    return {\n        next (key) {\n            const keyProvided = arguments.length > 0;\n            while(state){\n                switch(state.s){\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while(state.n.l && cmp(key, state.n.from) < 0)state = {\n                                up: state,\n                                n: state.n.l,\n                                s: 1\n                            };\n                        } else {\n                            while(state.n.l)state = {\n                                up: state,\n                                n: state.n.l,\n                                s: 1\n                            };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0) return {\n                            value: state.n,\n                            done: false\n                        };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = {\n                                up: state,\n                                n: state.n.r,\n                                s: 0\n                            };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return {\n                done: true\n            };\n        }\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = {\n            ...target\n        };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;\n}\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core)=>{\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName)=>{\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req)=>{\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName)=>{\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return mutatedParts[part] || (mutatedParts[part] = new RangeSet());\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\" ? [\n                            req.range\n                        ] : req.type === \"delete\" ? [\n                            req.keys\n                        ] : req.values.length < 50 ? [\n                            [],\n                            req.values\n                        ] : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res)=>{\n                            if (isArray(keys)) {\n                                if (type !== \"delete\") keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            } else if (keys) {\n                                const range = {\n                                    from: keys.lower,\n                                    to: keys.upper\n                                };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            } else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach((idx)=>getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    }\n                };\n                const getRange = ({ query: { index, range } })=>{\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req)=>[\n                            primaryKey,\n                            new RangeSet(req.key)\n                        ],\n                    getMany: (req)=>[\n                            primaryKey,\n                            new RangeSet().addKeys(req.keys)\n                        ],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange\n                };\n                keys(readSubscribers).forEach((method)=>{\n                    tableClone[method] = function(req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName)=>{\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return subscr[part] || (subscr[part] = new RangeSet());\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                } else {\n                                    const keysPromise = method === \"query\" && outbound && req.values && table.query({\n                                        ...req,\n                                        values: false\n                                    });\n                                    return table[method].apply(this, arguments).then((res)=>{\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys })=>{\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values ? res.result.map(extractKey) : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            } else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        } else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return cursor && Object.create(cursor, {\n                                                key: {\n                                                    get () {\n                                                        delsRangeSet.addKey(cursor.primaryKey);\n                                                        return cursor.key;\n                                                    }\n                                                },\n                                                primaryKey: {\n                                                    get () {\n                                                        const pkey = cursor.primaryKey;\n                                                        delsRangeSet.addKey(pkey);\n                                                        return pkey;\n                                                    }\n                                                },\n                                                value: {\n                                                    get () {\n                                                        wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                        return cursor.value;\n                                                    }\n                                                }\n                                            });\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            }\n        };\n    }\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key)=>ix.multiEntry && isArray(key) ? key.forEach((key)=>rangeSet.addKey(key)) : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i)=>{\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null) addKeyOrKeys(oldKey);\n                if (newKey != null) addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\nclass Dexie$1 {\n    constructor(name, options){\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true,\n            PR1398_maxLoop: 3\n        };\n        state.dbReadyPromise = new DexiePromise((resolve)=>{\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject)=>{\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n            ready: [\n                promisableChain,\n                nop\n            ]\n        });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, (subscribe)=>{\n            return (subscriber, bSticky)=>{\n                Dexie$1.vip(()=>{\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);\n                        if (bSticky) subscribe(subscriber);\n                    } else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky) subscribe(subscriber);\n                    } else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky) subscribe(function unsubscribe() {\n                            db.on.ready.unsubscribe(subscriber);\n                            db.on.ready.unsubscribe(unsubscribe);\n                        });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", (ev)=>{\n            if (ev.newVersion > 0) console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", (ev)=>{\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction)=>new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = (ev)=>{\n            this.on(\"blocked\").fire(ev);\n            connections.filter((c)=>c.name === this.name && c !== this && !c._state.vcFired).map((c)=>c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, {\n            _vip: {\n                value: true\n            }\n        });\n        addons.forEach((addon)=>addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter((v)=>v._cfg.version === versionNumber)[0];\n        if (versionInstance) return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve, reject)=>{\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name) this.unuse({\n            stack,\n            name\n        });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({\n            stack,\n            create,\n            level: level == null ? 10 : level,\n            name\n        });\n        middlewares.sort((a, b)=>a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter((mw)=>create ? mw.create !== create : name ? mw.name !== name : false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0) connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            } catch (e) {}\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise((resolve)=>{\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject)=>{\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject)=>{\n            const doDelete = ()=>{\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(()=>{\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments) throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            } else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && dbOpenError.name === \"DatabaseClosed\";\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map((name)=>this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf(\"!\") !== -1) parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf(\"?\") !== -1;\n        mode = mode.replace(\"!\", \"\").replace(\"?\", \"\");\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map((table)=>{\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== \"string\") throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY) idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE) idbMode = READWRITE;\n            else throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    } else throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach((storeName)=>{\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            } else throw new exceptions.SubTransaction(\"Table \" + storeName + \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        } catch (e) {\n            return parentTransaction ? parentTransaction._promise(null, (_, reject)=>{\n                reject(e);\n            }) : rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, \"lock\") : PSD.trans ? usePSD(PSD.transless, ()=>this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\nclass Observable {\n    constructor(subscribe){\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? {\n            next: x,\n            error,\n            complete\n        } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach((part)=>{\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\nfunction liveQuery(querier) {\n    let hasValue = false;\n    let currentValue = undefined;\n    const observable = new Observable((observer)=>{\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = ()=>newScope(querier, {\n                    subscr,\n                    trans: null\n                });\n            const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed () {\n                return closed;\n            },\n            unsubscribe: ()=>{\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            }\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key)=>accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts)=>{\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = ()=>{\n            if (querying || closed) return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result)=>{\n                hasValue = true;\n                currentValue = result;\n                querying = false;\n                if (closed) return;\n                if (shouldNotify()) {\n                    doQuery();\n                } else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err)=>{\n                querying = false;\n                hasValue = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n    observable.hasValue = ()=>hasValue;\n    observable.getValue = ()=>currentValue;\n    return observable;\n}\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n} catch (e) {\n    domDeps = {\n        indexedDB: null,\n        IDBKeyRange: null\n    };\n}\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete (databaseName) {\n        const db = new Dexie(databaseName, {\n            addons: []\n        });\n        return db.delete();\n    },\n    exists (name) {\n        return new Dexie(name, {\n            addons: []\n        }).open().then((db)=>{\n            db.close();\n            return true;\n        }).catch(\"NoSuchDatabaseError\", ()=>false);\n    },\n    getDatabaseNames (cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        } catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass () {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction (scopeFunc) {\n        return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();\n    },\n    vip,\n    async: function(generatorFn) {\n        return function() {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== \"function\") return DexiePromise.resolve(rv);\n                return rv;\n            } catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function(generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== \"function\") return DexiePromise.resolve(rv);\n            return rv;\n        } catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: ()=>PSD.trans || null\n    },\n    waitFor: function(promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === \"function\" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);\n        return PSD.trans ? PSD.trans.waitFor(promise) : promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: ()=>debug,\n        set: (value)=>{\n            setDebug(value, value === \"dexie\" ? ()=>true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split(\".\").map((n)=>parseInt(n)).reduce((p, c, i)=>p + c / Math.pow(10, i * 2))\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\nif (typeof dispatchEvent !== \"undefined\" && typeof addEventListener !== \"undefined\") {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (updatedParts)=>{\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            } else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail })=>{\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    } finally{\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\nif (typeof BroadcastChannel !== \"undefined\") {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    if (typeof bc.unref === \"function\") {\n        bc.unref();\n    }\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts)=>{\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev)=>{\n        if (ev.data) propagateLocally(ev.data);\n    };\n} else if (typeof self !== \"undefined\" && typeof navigator !== \"undefined\") {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts)=>{\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts\n                    }));\n                }\n                if (typeof self[\"clients\"] === \"object\") {\n                    [\n                        ...self[\"clients\"].matchAll({\n                            includeUncontrolled: true\n                        })\n                    ].forEach((client)=>client.postMessage({\n                            type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                            changedParts\n                        }));\n                }\n            }\n        } catch (_a) {}\n    });\n    if (typeof addEventListener !== \"undefined\") {\n        addEventListener(\"storage\", (ev)=>{\n            if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n                const data = JSON.parse(ev.newValue);\n                if (data) propagateLocally(data.changedParts);\n            }\n        });\n    }\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener(\"message\", propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n //# sourceMappingURL=dexie.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RleGllQDMuMi43L25vZGVfbW9kdWxlcy9kZXhpZS9kaXN0L21vZGVybi9kZXhpZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FFRCxNQUFNQSxVQUFVLE9BQU9DLGVBQWUsY0FBY0EsYUFDaEQsT0FBT0MsU0FBUyxjQUFjQSxPQUMxQixNQUFrQixHQUFjQyxDQUFNQSxHQUNsQ0M7QUFFWixNQUFNQyxPQUFPQyxPQUFPRCxJQUFJO0FBQ3hCLE1BQU1FLFVBQVVDLE1BQU1ELE9BQU87QUFDN0IsSUFBSSxPQUFPRSxZQUFZLGVBQWUsQ0FBQ1QsUUFBUVMsT0FBTyxFQUFFO0lBQ3BEVCxRQUFRUyxPQUFPLEdBQUdBO0FBQ3RCO0FBQ0EsU0FBU0MsT0FBT0MsR0FBRyxFQUFFQyxTQUFTO0lBQzFCLElBQUksT0FBT0EsY0FBYyxVQUNyQixPQUFPRDtJQUNYTixLQUFLTyxXQUFXQyxPQUFPLENBQUMsU0FBVUMsR0FBRztRQUNqQ0gsR0FBRyxDQUFDRyxJQUFJLEdBQUdGLFNBQVMsQ0FBQ0UsSUFBSTtJQUM3QjtJQUNBLE9BQU9IO0FBQ1g7QUFDQSxNQUFNSSxXQUFXVCxPQUFPVSxjQUFjO0FBQ3RDLE1BQU1DLFVBQVUsQ0FBQyxFQUFFQyxjQUFjO0FBQ2pDLFNBQVNDLE9BQU9SLEdBQUcsRUFBRVMsSUFBSTtJQUNyQixPQUFPSCxRQUFRSSxJQUFJLENBQUNWLEtBQUtTO0FBQzdCO0FBQ0EsU0FBU0UsTUFBTUMsS0FBSyxFQUFFWCxTQUFTO0lBQzNCLElBQUksT0FBT0EsY0FBYyxZQUNyQkEsWUFBWUEsVUFBVUcsU0FBU1E7SUFDbEMsUUFBT0MsWUFBWSxjQUFjbkIsT0FBT21CLFFBQVFDLE9BQU8sRUFBRWIsV0FBV0MsT0FBTyxDQUFDQyxDQUFBQTtRQUN6RVksUUFBUUgsT0FBT1QsS0FBS0YsU0FBUyxDQUFDRSxJQUFJO0lBQ3RDO0FBQ0o7QUFDQSxNQUFNYSxpQkFBaUJy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LEdBQUc3dUIsR0FBRyxLQUFLNnRCLGdDQUFnQztnQkFDM0MsTUFBTWljLE9BQU92dEIsS0FBSyt0QixLQUFLLENBQUN6YixHQUFHMGIsUUFBUTtnQkFDbkMsSUFBSVQsTUFDQVQsaUJBQWlCUyxLQUFLSCxZQUFZO1lBQzFDO1FBQ0o7SUFDSjtJQUNBLE1BQU1hLGNBQWNwckMsS0FBSzhOLFFBQVEsSUFBSXNNLFVBQVVpeEIsYUFBYTtJQUM1RCxJQUFJRCxhQUFhO1FBQ2JBLFlBQVl2QixnQkFBZ0IsQ0FBQyxXQUFXeUI7SUFDNUM7QUFDSjtBQUNBLFNBQVNBLHdCQUF3QixFQUFFWixJQUFJLEVBQUU7SUFDckMsSUFBSUEsUUFBUUEsS0FBS3I1QixJQUFJLEtBQUtvZCxnQ0FBZ0M7UUFDdER3YixpQkFBaUJTLEtBQUtILFlBQVk7SUFDdEM7QUFDSjtBQUVBOTZCLGFBQWFkLGVBQWUsR0FBR3pEO0FBQy9CakQsU0FBU0osT0FBTzJTO0FBRWlGLENBQ2pHLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL0B2ZXJpY2FyZC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RleGllQDMuMi43L25vZGVfbW9kdWxlcy9kZXhpZS9kaXN0L21vZGVybi9kZXhpZS5tanM/NWJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogRGV4aWUuanMgLSBhIG1pbmltYWxpc3RpYyB3cmFwcGVyIGZvciBJbmRleGVkREJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQnkgRGF2aWQgRmFobGFuZGVyLCBkYXZpZC5mYWhsYW5kZXJAZ21haWwuY29tXG4gKlxuICogVmVyc2lvbiAzLjIuNywgV2VkIE1hciAyMCAyMDI0XG4gKlxuICogaHR0cHM6Ly9kZXhpZS5vcmdcbiAqXG4gKiBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgSmFudWFyeSAyMDA0LCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvXG4gKi9cbiBcbmNvbnN0IF9nbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDpcbiAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDpcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOlxuICAgICAgICAgICAgZ2xvYmFsO1xuXG5jb25zdCBrZXlzID0gT2JqZWN0LmtleXM7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIV9nbG9iYWwuUHJvbWlzZSkge1xuICAgIF9nbG9iYWwuUHJvbWlzZSA9IFByb21pc2U7XG59XG5mdW5jdGlvbiBleHRlbmQob2JqLCBleHRlbnNpb24pIHtcbiAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAga2V5cyhleHRlbnNpb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBvYmpba2V5XSA9IGV4dGVuc2lvbltrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG5jb25zdCBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbmNvbnN0IF9oYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093bihvYmosIHByb3ApIHtcbiAgICByZXR1cm4gX2hhc093bi5jYWxsKG9iaiwgcHJvcCk7XG59XG5mdW5jdGlvbiBwcm9wcyhwcm90bywgZXh0ZW5zaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbihnZXRQcm90byhwcm90bykpO1xuICAgICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiA/IGtleXMgOiBSZWZsZWN0Lm93bktleXMpKGV4dGVuc2lvbikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBzZXRQcm9wKHByb3RvLCBrZXksIGV4dGVuc2lvbltrZXldKTtcbiAgICB9KTtcbn1cbmNvbnN0IGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuZnVuY3Rpb24gc2V0UHJvcChvYmosIHByb3AsIGZ1bmN0aW9uT3JHZXRTZXQsIG9wdGlvbnMpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGV4dGVuZChmdW5jdGlvbk9yR2V0U2V0ICYmIGhhc093bihmdW5jdGlvbk9yR2V0U2V0LCBcImdldFwiKSAmJiB0eXBlb2YgZnVuY3Rpb25PckdldFNldC5nZXQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICB7IGdldDogZnVuY3Rpb25PckdldFNldC5nZXQsIHNldDogZnVuY3Rpb25PckdldFNldC5zZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IDpcbiAgICAgICAgeyB2YWx1ZTogZnVuY3Rpb25PckdldFNldCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiBkZXJpdmUoQ2hpbGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBmdW5jdGlvbiAoUGFyZW50KSB7XG4gICAgICAgICAgICBDaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgc2V0UHJvcChDaGlsZC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgQ2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBleHRlbmQ6IHByb3BzLmJpbmQobnVsbCwgQ2hpbGQucHJvdG90eXBlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICAgIGNvbnN0IHBkID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgbGV0IHByb3RvO1xuICAgIHJldHVybiBwZCB8fCAocHJvdG8gPSBnZXRQcm90byhvYmopKSAmJiBnZXRQcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApO1xufVxuY29uc3QgX3NsaWNlID0gW10uc2xpY2U7XG5mdW5jdGlvbiBzbGljZShhcmdzLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIF9zbGljZS5jYWxsKGFyZ3MsIHN0YXJ0LCBlbmQpO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGUob3JpZ0Z1bmMsIG92ZXJyaWRlZEZhY3RvcnkpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVkRmFjdG9yeShvcmlnRnVuYyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoYikge1xuICAgIGlmICghYilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIEZhaWxlZFwiKTtcbn1cbmZ1bmN0aW9uIGFzYXAkMShmbikge1xuICAgIGlmIChfZ2xvYmFsLnNldEltbWVkaWF0ZSlcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICBlbHNlXG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnJheSwgZXh0cmFjdG9yKSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgocmVzdWx0LCBpdGVtLCBpKSA9PiB7XG4gICAgICAgIHZhciBuYW1lQW5kVmFsdWUgPSBleHRyYWN0b3IoaXRlbSwgaSk7XG4gICAgICAgIGlmIChuYW1lQW5kVmFsdWUpXG4gICAgICAgICAgICByZXN1bHRbbmFtZUFuZFZhbHVlWzBdXSA9IG5hbWVBbmRWYWx1ZVsxXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiB0cnlDYXRjaChmbiwgb25lcnJvciwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgb25lcnJvciAmJiBvbmVycm9yKGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyAmJiBoYXNPd24ob2JqLCBrZXlQYXRoKSlcbiAgICAgICAgcmV0dXJuIG9ialtrZXlQYXRoXTtcbiAgICBpZiAoIWtleVBhdGgpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0pO1xuICAgICAgICAgICAgcnYucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpXTtcbiAgICAgICAgcmV0dXJuIGlubmVyT2JqID09IG51bGwgPyB1bmRlZmluZWQgOiBnZXRCeUtleVBhdGgoaW5uZXJPYmosIGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKSB7XG4gICAgaWYgKCFvYmogfHwga2V5UGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCdpc0Zyb3plbicgaW4gT2JqZWN0ICYmIE9iamVjdC5pc0Zyb3plbihvYmopKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiBrZXlQYXRoKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICdsZW5ndGgnIGluIHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSwgdmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcGVyaW9kID0ga2V5UGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEtleVBhdGggPSBrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZ0tleVBhdGggPSBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdLZXlQYXRoID09PSBcIlwiKVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG9iaikgJiYgIWlzTmFOKHBhcnNlSW50KGN1cnJlbnRLZXlQYXRoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouc3BsaWNlKGN1cnJlbnRLZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtjdXJyZW50S2V5UGF0aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqW2N1cnJlbnRLZXlQYXRoXSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyT2JqIHx8ICFoYXNPd24ob2JqLCBjdXJyZW50S2V5UGF0aCkpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyT2JqID0gKG9ialtjdXJyZW50S2V5UGF0aF0gPSB7fSk7XG4gICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGlubmVyT2JqLCByZW1haW5pbmdLZXlQYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG9iaikgJiYgIWlzTmFOKHBhcnNlSW50KGtleVBhdGgpKSlcbiAgICAgICAgICAgICAgICAgICAgb2JqLnNwbGljZShrZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb2JqW2tleVBhdGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkZWxCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJylcbiAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdW5kZWZpbmVkKTtcbiAgICBlbHNlIGlmICgnbGVuZ3RoJyBpbiBrZXlQYXRoKVxuICAgICAgICBbXS5tYXAuY2FsbChrZXlQYXRoLCBmdW5jdGlvbiAoa3ApIHtcbiAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtwLCB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmopIHtcbiAgICB2YXIgcnYgPSB7fTtcbiAgICBmb3IgKHZhciBtIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duKG9iaiwgbSkpXG4gICAgICAgICAgICBydlttXSA9IG9ialttXTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufVxuY29uc3QgY29uY2F0ID0gW10uY29uY2F0O1xuZnVuY3Rpb24gZmxhdHRlbihhKSB7XG4gICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgYSk7XG59XG5jb25zdCBpbnRyaW5zaWNUeXBlTmFtZXMgPSBcIkJpZ1VpbnQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQXJyYXksQm9vbGVhbixTdHJpbmcsRGF0ZSxSZWdFeHAsQmxvYixGaWxlLEZpbGVMaXN0LEZpbGVTeXN0ZW1GaWxlSGFuZGxlLEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUsQXJyYXlCdWZmZXIsRGF0YVZpZXcsVWludDhDbGFtcGVkQXJyYXksSW1hZ2VCaXRtYXAsSW1hZ2VEYXRhLE1hcCxTZXQsQ3J5cHRvS2V5XCJcbiAgICAuc3BsaXQoJywnKS5jb25jYXQoZmxhdHRlbihbOCwgMTYsIDMyLCA2NF0ubWFwKG51bSA9PiBbXCJJbnRcIiwgXCJVaW50XCIsIFwiRmxvYXRcIl0ubWFwKHQgPT4gdCArIG51bSArIFwiQXJyYXlcIikpKSkuZmlsdGVyKHQgPT4gX2dsb2JhbFt0XSk7XG5jb25zdCBpbnRyaW5zaWNUeXBlcyA9IGludHJpbnNpY1R5cGVOYW1lcy5tYXAodCA9PiBfZ2xvYmFsW3RdKTtcbmFycmF5VG9PYmplY3QoaW50cmluc2ljVHlwZU5hbWVzLCB4ID0+IFt4LCB0cnVlXSk7XG5sZXQgY2lyY3VsYXJSZWZzID0gbnVsbDtcbmZ1bmN0aW9uIGRlZXBDbG9uZShhbnkpIHtcbiAgICBjaXJjdWxhclJlZnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBydiA9IGlubmVyRGVlcENsb25lKGFueSk7XG4gICAgY2lyY3VsYXJSZWZzID0gbnVsbDtcbiAgICByZXR1cm4gcnY7XG59XG5mdW5jdGlvbiBpbm5lckRlZXBDbG9uZShhbnkpIHtcbiAgICBpZiAoIWFueSB8fCB0eXBlb2YgYW55ICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGFueTtcbiAgICBsZXQgcnYgPSBjaXJjdWxhclJlZnMgJiYgY2lyY3VsYXJSZWZzLmdldChhbnkpO1xuICAgIGlmIChydilcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIGlmIChpc0FycmF5KGFueSkpIHtcbiAgICAgICAgcnYgPSBbXTtcbiAgICAgICAgY2lyY3VsYXJSZWZzICYmIGNpcmN1bGFyUmVmcy5zZXQoYW55LCBydik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYW55Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgcnYucHVzaChpbm5lckRlZXBDbG9uZShhbnlbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnRyaW5zaWNUeXBlcy5pbmRleE9mKGFueS5jb25zdHJ1Y3RvcikgPj0gMCkge1xuICAgICAgICBydiA9IGFueTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8oYW55KTtcbiAgICAgICAgcnYgPSBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHt9IDogT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICAgIGNpcmN1bGFyUmVmcyAmJiBjaXJjdWxhclJlZnMuc2V0KGFueSwgcnYpO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGFueSkge1xuICAgICAgICAgICAgaWYgKGhhc093bihhbnksIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcnZbcHJvcF0gPSBpbm5lckRlZXBDbG9uZShhbnlbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cbmNvbnN0IHsgdG9TdHJpbmcgfSA9IHt9O1xuZnVuY3Rpb24gdG9TdHJpbmdUYWcobykge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbn1cbmNvbnN0IGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgIFN5bWJvbC5pdGVyYXRvciA6XG4gICAgJ0BAaXRlcmF0b3InO1xuY29uc3QgZ2V0SXRlcmF0b3JPZiA9IHR5cGVvZiBpdGVyYXRvclN5bWJvbCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIGk7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiAoaSA9IHhbaXRlcmF0b3JTeW1ib2xdKSAmJiBpLmFwcGx5KHgpO1xufSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG5jb25zdCBOT19DSEFSX0FSUkFZID0ge307XG5mdW5jdGlvbiBnZXRBcnJheU9mKGFycmF5TGlrZSkge1xuICAgIHZhciBpLCBhLCB4LCBpdDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoaXNBcnJheShhcnJheUxpa2UpKVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5TGlrZS5zbGljZSgpO1xuICAgICAgICBpZiAodGhpcyA9PT0gTk9fQ0hBUl9BUlJBWSAmJiB0eXBlb2YgYXJyYXlMaWtlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgICAgaWYgKChpdCA9IGdldEl0ZXJhdG9yT2YoYXJyYXlMaWtlKSkpIHtcbiAgICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICgoeCA9IGl0Lm5leHQoKSksICF4LmRvbmUpXG4gICAgICAgICAgICAgICAgYS5wdXNoKHgudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5TGlrZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgICAgICBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYSA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgYVtpXSA9IGFycmF5TGlrZVtpXTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICB9XG4gICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYSA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBhW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBhO1xufVxuY29uc3QgaXNBc3luY0Z1bmN0aW9uID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IChmbikgPT4gZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jRnVuY3Rpb24nXG4gICAgOiAoKSA9PiBmYWxzZTtcblxudmFyIGRlYnVnID0gdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC9eKGh0dHB8aHR0cHMpOlxcL1xcLyhsb2NhbGhvc3R8MTI3XFwuMFxcLjBcXC4xKS8udGVzdChsb2NhdGlvbi5ocmVmKTtcbmZ1bmN0aW9uIHNldERlYnVnKHZhbHVlLCBmaWx0ZXIpIHtcbiAgICBkZWJ1ZyA9IHZhbHVlO1xuICAgIGxpYnJhcnlGaWx0ZXIgPSBmaWx0ZXI7XG59XG52YXIgbGlicmFyeUZpbHRlciA9ICgpID0+IHRydWU7XG5jb25zdCBORUVEU19USFJPV19GT1JfU1RBQ0sgPSAhbmV3IEVycm9yKFwiXCIpLnN0YWNrO1xuZnVuY3Rpb24gZ2V0RXJyb3JXaXRoU3RhY2soKSB7XG4gICAgaWYgKE5FRURTX1RIUk9XX0ZPUl9TVEFDSylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdldEVycm9yV2l0aFN0YWNrLmFyZ3VtZW50cztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoKTtcbn1cbmZ1bmN0aW9uIHByZXR0eVN0YWNrKGV4Y2VwdGlvbiwgbnVtSWdub3JlZEZyYW1lcykge1xuICAgIHZhciBzdGFjayA9IGV4Y2VwdGlvbi5zdGFjaztcbiAgICBpZiAoIXN0YWNrKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICBudW1JZ25vcmVkRnJhbWVzID0gKG51bUlnbm9yZWRGcmFtZXMgfHwgMCk7XG4gICAgaWYgKHN0YWNrLmluZGV4T2YoZXhjZXB0aW9uLm5hbWUpID09PSAwKVxuICAgICAgICBudW1JZ25vcmVkRnJhbWVzICs9IChleGNlcHRpb24ubmFtZSArIGV4Y2VwdGlvbi5tZXNzYWdlKS5zcGxpdCgnXFxuJykubGVuZ3RoO1xuICAgIHJldHVybiBzdGFjay5zcGxpdCgnXFxuJylcbiAgICAgICAgLnNsaWNlKG51bUlnbm9yZWRGcmFtZXMpXG4gICAgICAgIC5maWx0ZXIobGlicmFyeUZpbHRlcilcbiAgICAgICAgLm1hcChmcmFtZSA9PiBcIlxcblwiICsgZnJhbWUpXG4gICAgICAgIC5qb2luKCcnKTtcbn1cblxudmFyIGRleGllRXJyb3JOYW1lcyA9IFtcbiAgICAnTW9kaWZ5JyxcbiAgICAnQnVsaycsXG4gICAgJ09wZW5GYWlsZWQnLFxuICAgICdWZXJzaW9uQ2hhbmdlJyxcbiAgICAnU2NoZW1hJyxcbiAgICAnVXBncmFkZScsXG4gICAgJ0ludmFsaWRUYWJsZScsXG4gICAgJ01pc3NpbmdBUEknLFxuICAgICdOb1N1Y2hEYXRhYmFzZScsXG4gICAgJ0ludmFsaWRBcmd1bWVudCcsXG4gICAgJ1N1YlRyYW5zYWN0aW9uJyxcbiAgICAnVW5zdXBwb3J0ZWQnLFxuICAgICdJbnRlcm5hbCcsXG4gICAgJ0RhdGFiYXNlQ2xvc2VkJyxcbiAgICAnUHJlbWF0dXJlQ29tbWl0JyxcbiAgICAnRm9yZWlnbkF3YWl0J1xuXTtcbnZhciBpZGJEb21FcnJvck5hbWVzID0gW1xuICAgICdVbmtub3duJyxcbiAgICAnQ29uc3RyYWludCcsXG4gICAgJ0RhdGEnLFxuICAgICdUcmFuc2FjdGlvbkluYWN0aXZlJyxcbiAgICAnUmVhZE9ubHknLFxuICAgICdWZXJzaW9uJyxcbiAgICAnTm90Rm91bmQnLFxuICAgICdJbnZhbGlkU3RhdGUnLFxuICAgICdJbnZhbGlkQWNjZXNzJyxcbiAgICAnQWJvcnQnLFxuICAgICdUaW1lb3V0JyxcbiAgICAnUXVvdGFFeGNlZWRlZCcsXG4gICAgJ1N5bnRheCcsXG4gICAgJ0RhdGFDbG9uZSdcbl07XG52YXIgZXJyb3JMaXN0ID0gZGV4aWVFcnJvck5hbWVzLmNvbmNhdChpZGJEb21FcnJvck5hbWVzKTtcbnZhciBkZWZhdWx0VGV4dHMgPSB7XG4gICAgVmVyc2lvbkNoYW5nZWQ6IFwiRGF0YWJhc2UgdmVyc2lvbiBjaGFuZ2VkIGJ5IG90aGVyIGRhdGFiYXNlIGNvbm5lY3Rpb25cIixcbiAgICBEYXRhYmFzZUNsb3NlZDogXCJEYXRhYmFzZSBoYXMgYmVlbiBjbG9zZWRcIixcbiAgICBBYm9ydDogXCJUcmFuc2FjdGlvbiBhYm9ydGVkXCIsXG4gICAgVHJhbnNhY3Rpb25JbmFjdGl2ZTogXCJUcmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBjb21wbGV0ZWQgb3IgZmFpbGVkXCIsXG4gICAgTWlzc2luZ0FQSTogXCJJbmRleGVkREIgQVBJIG1pc3NpbmcuIFBsZWFzZSB2aXNpdCBodHRwczovL3Rpbnl1cmwuY29tL3kydXV2c2tiXCJcbn07XG5mdW5jdGlvbiBEZXhpZUVycm9yKG5hbWUsIG1zZykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xufVxuZGVyaXZlKERleGllRXJyb3IpLmZyb20oRXJyb3IpLmV4dGVuZCh7XG4gICAgc3RhY2s6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2sgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5fc3RhY2sgPSB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBwcmV0dHlTdGFjayh0aGlzLl9lLCAyKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH1cbn0pO1xuZnVuY3Rpb24gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcykge1xuICAgIHJldHVybiBtc2cgKyBcIi4gRXJyb3JzOiBcIiArIE9iamVjdC5rZXlzKGZhaWx1cmVzKVxuICAgICAgICAubWFwKGtleSA9PiBmYWlsdXJlc1trZXldLnRvU3RyaW5nKCkpXG4gICAgICAgIC5maWx0ZXIoKHYsIGksIHMpID0+IHMuaW5kZXhPZih2KSA9PT0gaSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuZnVuY3Rpb24gTW9kaWZ5RXJyb3IobXNnLCBmYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzKSB7XG4gICAgdGhpcy5fZSA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgdGhpcy5mYWlsdXJlcyA9IGZhaWx1cmVzO1xuICAgIHRoaXMuZmFpbGVkS2V5cyA9IGZhaWxlZEtleXM7XG4gICAgdGhpcy5zdWNjZXNzQ291bnQgPSBzdWNjZXNzQ291bnQ7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcyk7XG59XG5kZXJpdmUoTW9kaWZ5RXJyb3IpLmZyb20oRGV4aWVFcnJvcik7XG5mdW5jdGlvbiBCdWxrRXJyb3IobXNnLCBmYWlsdXJlcykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMubmFtZSA9IFwiQnVsa0Vycm9yXCI7XG4gICAgdGhpcy5mYWlsdXJlcyA9IE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAocG9zID0+IGZhaWx1cmVzW3Bvc10pO1xuICAgIHRoaXMuZmFpbHVyZXNCeVBvcyA9IGZhaWx1cmVzO1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpO1xufVxuZGVyaXZlKEJ1bGtFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcbnZhciBlcnJuYW1lcyA9IGVycm9yTGlzdC5yZWR1Y2UoKG9iaiwgbmFtZSkgPT4gKG9ialtuYW1lXSA9IG5hbWUgKyBcIkVycm9yXCIsIG9iaiksIHt9KTtcbmNvbnN0IEJhc2VFeGNlcHRpb24gPSBEZXhpZUVycm9yO1xudmFyIGV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKChvYmosIG5hbWUpID0+IHtcbiAgICB2YXIgZnVsbE5hbWUgPSBuYW1lICsgXCJFcnJvclwiO1xuICAgIGZ1bmN0aW9uIERleGllRXJyb3IobXNnT3JJbm5lciwgaW5uZXIpIHtcbiAgICAgICAgdGhpcy5fZSA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IGZ1bGxOYW1lO1xuICAgICAgICBpZiAoIW1zZ09ySW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGRlZmF1bHRUZXh0c1tuYW1lXSB8fCBmdWxsTmFtZTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtc2dPcklubmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7bXNnT3JJbm5lcn0keyFpbm5lciA/ICcnIDogJ1xcbiAnICsgaW5uZXJ9YDtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lciB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtc2dPcklubmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7bXNnT3JJbm5lci5uYW1lfSAke21zZ09ySW5uZXIubWVzc2FnZX1gO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG1zZ09ySW5uZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVyaXZlKERleGllRXJyb3IpLmZyb20oQmFzZUV4Y2VwdGlvbik7XG4gICAgb2JqW25hbWVdID0gRGV4aWVFcnJvcjtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuZXhjZXB0aW9ucy5TeW50YXggPSBTeW50YXhFcnJvcjtcbmV4Y2VwdGlvbnMuVHlwZSA9IFR5cGVFcnJvcjtcbmV4Y2VwdGlvbnMuUmFuZ2UgPSBSYW5nZUVycm9yO1xudmFyIGV4Y2VwdGlvbk1hcCA9IGlkYkRvbUVycm9yTmFtZXMucmVkdWNlKChvYmosIG5hbWUpID0+IHtcbiAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgIHJldHVybiBvYmo7XG59LCB7fSk7XG5mdW5jdGlvbiBtYXBFcnJvcihkb21FcnJvciwgbWVzc2FnZSkge1xuICAgIGlmICghZG9tRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBEZXhpZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgU3ludGF4RXJyb3IgfHwgIWRvbUVycm9yLm5hbWUgfHwgIWV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXSlcbiAgICAgICAgcmV0dXJuIGRvbUVycm9yO1xuICAgIHZhciBydiA9IG5ldyBleGNlcHRpb25NYXBbZG9tRXJyb3IubmFtZV0obWVzc2FnZSB8fCBkb21FcnJvci5tZXNzYWdlLCBkb21FcnJvcik7XG4gICAgaWYgKFwic3RhY2tcIiBpbiBkb21FcnJvcikge1xuICAgICAgICBzZXRQcm9wKHJ2LCBcInN0YWNrXCIsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXIuc3RhY2s7XG4gICAgICAgICAgICB9IH0pO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG52YXIgZnVsbE5hbWVFeGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLCBuYW1lKSA9PiB7XG4gICAgaWYgKFtcIlN5bnRheFwiLCBcIlR5cGVcIiwgXCJSYW5nZVwiXS5pbmRleE9mKG5hbWUpID09PSAtMSlcbiAgICAgICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuZnVsbE5hbWVFeGNlcHRpb25zLk1vZGlmeUVycm9yID0gTW9kaWZ5RXJyb3I7XG5mdWxsTmFtZUV4Y2VwdGlvbnMuRGV4aWVFcnJvciA9IERleGllRXJyb3I7XG5mdWxsTmFtZUV4Y2VwdGlvbnMuQnVsa0Vycm9yID0gQnVsa0Vycm9yO1xuXG5mdW5jdGlvbiBub3AoKSB7IH1cbmZ1bmN0aW9uIG1pcnJvcih2YWwpIHsgcmV0dXJuIHZhbDsgfVxuZnVuY3Rpb24gcHVyZUZ1bmN0aW9uQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09IG51bGwgfHwgZjEgPT09IG1pcnJvcilcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBmMihmMSh2YWwpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY2FsbEJvdGgob24xLCBvbjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tDcmVhdGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IHJlcztcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcylcbiAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgaWYgKG9uZXJyb3IpXG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICAgICAgcmV0dXJuIHJlczIgIT09IHVuZGVmaW5lZCA/IHJlczIgOiByZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tEZWxldGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChvbnN1Y2Nlc3MpXG4gICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgIGlmIChvbmVycm9yKVxuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tVcGRhdGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZmljYXRpb25zKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBleHRlbmQobW9kaWZpY2F0aW9ucywgcmVzKTtcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcylcbiAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgaWYgKG9uZXJyb3IpXG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICAgICAgcmV0dXJuIHJlcyA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIChyZXMyID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZXMyKSA6XG4gICAgICAgICAgICAoZXh0ZW5kKHJlcywgcmVzMikpO1xuICAgIH07XG59XG5mdW5jdGlvbiByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByb21pc2FibGVDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHRoaXogPSB0aGlzLCBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIHJldHVybiByZXMudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXosIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxudmFyIElOVEVSTkFMID0ge307XG5jb25zdCBMT05HX1NUQUNLU19DTElQX0xJTUlUID0gMTAwLFxuTUFYX0xPTkdfU1RBQ0tTID0gMjAsIFpPTkVfRUNIT19MSU1JVCA9IDEwMCwgW3Jlc29sdmVkTmF0aXZlUHJvbWlzZSwgbmF0aXZlUHJvbWlzZVByb3RvLCByZXNvbHZlZEdsb2JhbFByb21pc2VdID0gdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID9cbiAgICBbXSA6XG4gICAgKCgpID0+IHtcbiAgICAgICAgbGV0IGdsb2JhbFAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnIHx8ICFjcnlwdG8uc3VidGxlKVxuICAgICAgICAgICAgcmV0dXJuIFtnbG9iYWxQLCBnZXRQcm90byhnbG9iYWxQKSwgZ2xvYmFsUF07XG4gICAgICAgIGNvbnN0IG5hdGl2ZVAgPSBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS01MTJcIiwgbmV3IFVpbnQ4QXJyYXkoWzBdKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuYXRpdmVQLFxuICAgICAgICAgICAgZ2V0UHJvdG8obmF0aXZlUCksXG4gICAgICAgICAgICBnbG9iYWxQXG4gICAgICAgIF07XG4gICAgfSkoKSwgbmF0aXZlUHJvbWlzZVRoZW4gPSBuYXRpdmVQcm9taXNlUHJvdG8gJiYgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW47XG5jb25zdCBOYXRpdmVQcm9taXNlID0gcmVzb2x2ZWROYXRpdmVQcm9taXNlICYmIHJlc29sdmVkTmF0aXZlUHJvbWlzZS5jb25zdHJ1Y3RvcjtcbmNvbnN0IHBhdGNoR2xvYmFsUHJvbWlzZSA9ICEhcmVzb2x2ZWRHbG9iYWxQcm9taXNlO1xudmFyIHN0YWNrX2JlaW5nX2dlbmVyYXRlZCA9IGZhbHNlO1xudmFyIHNjaGVkdWxlUGh5c2ljYWxUaWNrID0gcmVzb2x2ZWRHbG9iYWxQcm9taXNlID9cbiAgICAoKSA9PiB7IHJlc29sdmVkR2xvYmFsUHJvbWlzZS50aGVuKHBoeXNpY2FsVGljayk7IH1cbiAgICA6XG4gICAgICAgIF9nbG9iYWwuc2V0SW1tZWRpYXRlID9cbiAgICAgICAgICAgIHNldEltbWVkaWF0ZS5iaW5kKG51bGwsIHBoeXNpY2FsVGljaykgOlxuICAgICAgICAgICAgX2dsb2JhbC5NdXRhdGlvbk9ic2VydmVyID9cbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAobmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGh5c2ljYWxUaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5EaXYgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KSkub2JzZXJ2ZShoaWRkZW5EaXYsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2LnNldEF0dHJpYnV0ZSgnaScsICcxJyk7XG4gICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgKCkgPT4geyBzZXRUaW1lb3V0KHBoeXNpY2FsVGljaywgMCk7IH07XG52YXIgYXNhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgIG1pY3JvdGlja1F1ZXVlLnB1c2goW2NhbGxiYWNrLCBhcmdzXSk7XG4gICAgaWYgKG5lZWRzTmV3UGh5c2ljYWxUaWNrKSB7XG4gICAgICAgIHNjaGVkdWxlUGh5c2ljYWxUaWNrKCk7XG4gICAgICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gZmFsc2U7XG4gICAgfVxufTtcbnZhciBpc091dHNpZGVNaWNyb1RpY2sgPSB0cnVlLFxubmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlLFxudW5oYW5kbGVkRXJyb3JzID0gW10sXG5yZWplY3RpbmdFcnJvcnMgPSBbXSxcbmN1cnJlbnRGdWxmaWxsZXIgPSBudWxsLCByZWplY3Rpb25NYXBwZXIgPSBtaXJyb3I7XG52YXIgZ2xvYmFsUFNEID0ge1xuICAgIGlkOiAnZ2xvYmFsJyxcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgcmVmOiAwLFxuICAgIHVuaGFuZGxlZHM6IFtdLFxuICAgIG9udW5oYW5kbGVkOiBnbG9iYWxFcnJvcixcbiAgICBwZ3A6IGZhbHNlLFxuICAgIGVudjoge30sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmhhbmRsZWRzLmZvckVhY2godWggPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBnbG9iYWxFcnJvcih1aFswXSwgdWhbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xudmFyIFBTRCA9IGdsb2JhbFBTRDtcbnZhciBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xudmFyIG51bVNjaGVkdWxlZENhbGxzID0gMDtcbnZhciB0aWNrRmluYWxpemVycyA9IFtdO1xuZnVuY3Rpb24gRGV4aWVQcm9taXNlKGZuKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5vbnVuY2F0Y2hlZCA9IG5vcDtcbiAgICB0aGlzLl9saWIgPSBmYWxzZTtcbiAgICB2YXIgcHNkID0gKHRoaXMuX1BTRCA9IFBTRCk7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIHRoaXMuX3N0YWNrSG9sZGVyID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICAgICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuX251bVByZXYgPSAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChmbiAhPT0gSU5URVJOQUwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICBoYW5kbGVSZWplY3Rpb24odGhpcywgdGhpcy5fdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgKytwc2QucmVmO1xuICAgIGV4ZWN1dGVQcm9taXNlVGFzayh0aGlzLCBmbik7XG59XG5jb25zdCB0aGVuUHJvcCA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBzZCA9IFBTRCwgbWljcm9UYXNrSWQgPSB0b3RhbEVjaG9lcztcbiAgICAgICAgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgdmFyIHBvc3NpYmxlQXdhaXQgPSAhcHNkLmdsb2JhbCAmJiAocHNkICE9PSBQU0QgfHwgbWljcm9UYXNrSWQgIT09IHRvdGFsRWNob2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBwb3NzaWJsZUF3YWl0ICYmICFkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcih0aGlzLCBuZXcgTGlzdGVuZXIobmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvbkZ1bGZpbGxlZCwgcHNkLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSwgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlamVjdGVkLCBwc2QsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApLCByZXNvbHZlLCByZWplY3QsIHBzZCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWJ1ZyAmJiBsaW5rVG9QcmV2aW91c1Byb21pc2UocnYsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgICAgIHRoZW4ucHJvdG90eXBlID0gSU5URVJOQUw7XG4gICAgICAgIHJldHVybiB0aGVuO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc2V0UHJvcCh0aGlzLCAndGhlbicsIHZhbHVlICYmIHZhbHVlLnByb3RvdHlwZSA9PT0gSU5URVJOQUwgP1xuICAgICAgICAgICAgdGhlblByb3AgOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IHRoZW5Qcm9wLnNldFxuICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcbnByb3BzKERleGllUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICB0aGVuOiB0aGVuUHJvcCxcbiAgICBfdGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIodGhpcywgbmV3IExpc3RlbmVyKG51bGwsIG51bGwsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBQU0QpKTtcbiAgICB9LFxuICAgIGNhdGNoOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLCBoYW5kbGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0aGlzLnRoZW4obnVsbCwgZXJyID0+XG4gICAgICAgIGVyciBpbnN0YW5jZW9mIHR5cGUgPyBoYW5kbGVyKGVycikgOiBQcm9taXNlUmVqZWN0KGVycikpXG4gICAgICAgICAgICA6IHRoaXMudGhlbihudWxsLCBlcnIgPT5cbiAgICAgICAgICAgIGVyciAmJiBlcnIubmFtZSA9PT0gdHlwZSA/IGhhbmRsZXIoZXJyKSA6IFByb21pc2VSZWplY3QoZXJyKSk7XG4gICAgfSxcbiAgICBmaW5hbGx5OiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBvbkZpbmFsbHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlUmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgc3RhY2s6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGFja19iZWluZ19nZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBzdGFja3MgPSBnZXRTdGFjayh0aGlzLCBbXSwgTUFYX0xPTkdfU1RBQ0tTKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBzdGFja3Muam9pbihcIlxcbkZyb20gcHJldmlvdXM6IFwiKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRpbWVvdXQ6IGZ1bmN0aW9uIChtcywgbXNnKSB7XG4gICAgICAgIHJldHVybiBtcyA8IEluZmluaXR5ID9cbiAgICAgICAgICAgIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgZXhjZXB0aW9ucy5UaW1lb3V0KG1zZykpLCBtcyk7XG4gICAgICAgICAgICAgICAgdGhpcy50aGVuKHJlc29sdmUsIHJlamVjdCkuZmluYWxseShjbGVhclRpbWVvdXQuYmluZChudWxsLCBoYW5kbGUpKTtcbiAgICAgICAgICAgIH0pIDogdGhpcztcbiAgICB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpXG4gICAgc2V0UHJvcChEZXhpZVByb21pc2UucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsICdEZXhpZS5Qcm9taXNlJyk7XG5nbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcbmZ1bmN0aW9uIExpc3RlbmVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3QsIHpvbmUpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICAgIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB0aGlzLnBzZCA9IHpvbmU7XG59XG5wcm9wcyhEZXhpZVByb21pc2UsIHtcbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKGEsIGkpID0+IERleGllUHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldID0geDtcbiAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgICB9LCByZWplY3QpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICByZXNvbHZlOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgcnYgPSBuZXcgRGV4aWVQcm9taXNlKElOVEVSTkFMLCB0cnVlLCB2YWx1ZSk7XG4gICAgICAgIGxpbmtUb1ByZXZpb3VzUHJvbWlzZShydiwgY3VycmVudEZ1bGZpbGxlcik7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9LFxuICAgIHJlamVjdDogUHJvbWlzZVJlamVjdCxcbiAgICByYWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5tYXAodmFsdWUgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgUFNEOiB7XG4gICAgICAgIGdldDogKCkgPT4gUFNELFxuICAgICAgICBzZXQ6IHZhbHVlID0+IFBTRCA9IHZhbHVlXG4gICAgfSxcbiAgICB0b3RhbEVjaG9lczogeyBnZXQ6ICgpID0+IHRvdGFsRWNob2VzIH0sXG4gICAgbmV3UFNEOiBuZXdTY29wZSxcbiAgICB1c2VQU0Q6IHVzZVBTRCxcbiAgICBzY2hlZHVsZXI6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBhc2FwLFxuICAgICAgICBzZXQ6IHZhbHVlID0+IHsgYXNhcCA9IHZhbHVlOyB9XG4gICAgfSxcbiAgICByZWplY3Rpb25NYXBwZXI6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiByZWplY3Rpb25NYXBwZXIsXG4gICAgICAgIHNldDogdmFsdWUgPT4geyByZWplY3Rpb25NYXBwZXIgPSB2YWx1ZTsgfVxuICAgIH0sXG4gICAgZm9sbG93OiAoZm4sIHpvbmVQcm9wcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBwc2QgPSBQU0Q7XG4gICAgICAgICAgICAgICAgcHNkLnVuaGFuZGxlZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBwc2Qub251bmhhbmRsZWQgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgcHNkLmZpbmFsaXplID0gY2FsbEJvdGgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5oYW5kbGVkcy5sZW5ndGggPT09IDAgPyByZXNvbHZlKCkgOiByZWplY3QodGhpcy51bmhhbmRsZWRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgcHNkLmZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSwgem9uZVByb3BzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmlmIChOYXRpdmVQcm9taXNlKSB7XG4gICAgaWYgKE5hdGl2ZVByb21pc2UuYWxsU2V0dGxlZClcbiAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYWxsU2V0dGxlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlUHJvbWlzZXMuZm9yRWFjaCgocCwgaSkgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUocCkudGhlbih2YWx1ZSA9PiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwiZnVsZmlsbGVkXCIsIHZhbHVlIH0sIHJlYXNvbiA9PiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29uIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IC0tcmVtYWluaW5nIHx8IHJlc29sdmUocmVzdWx0cykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbnkgJiYgdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYW55XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlUHJvbWlzZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKFtdKSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKChwLCBpKSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKHZhbHVlID0+IHJlc29sdmUodmFsdWUpLCBmYWlsdXJlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXNbaV0gPSBmYWlsdXJlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihmYWlsdXJlcykpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVQcm9taXNlVGFzayhwcm9taXNlLCBmbikge1xuICAgIHRyeSB7XG4gICAgICAgIGZuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHByb21pc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fdGhlbihyZXNvbHZlLCByZWplY3QpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3N0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRFeGVjdXRlVGljaylcbiAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9LCBoYW5kbGVSZWplY3Rpb24uYmluZChudWxsLCBwcm9taXNlKSk7XG4gICAgfVxuICAgIGNhdGNoIChleCkge1xuICAgICAgICBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVJlamVjdGlvbihwcm9taXNlLCByZWFzb24pIHtcbiAgICByZWplY3RpbmdFcnJvcnMucHVzaChyZWFzb24pO1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgcmVhc29uID0gcmVqZWN0aW9uTWFwcGVyKHJlYXNvbik7XG4gICAgcHJvbWlzZS5fc3RhdGUgPSBmYWxzZTtcbiAgICBwcm9taXNlLl92YWx1ZSA9IHJlYXNvbjtcbiAgICBkZWJ1ZyAmJiByZWFzb24gIT09IG51bGwgJiYgdHlwZW9mIHJlYXNvbiA9PT0gJ29iamVjdCcgJiYgIXJlYXNvbi5fcHJvbWlzZSAmJiB0cnlDYXRjaCgoKSA9PiB7XG4gICAgICAgIHZhciBvcmlnUHJvcCA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihyZWFzb24sIFwic3RhY2tcIik7XG4gICAgICAgIHJlYXNvbi5fcHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHNldFByb3AocmVhc29uLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIGdldDogKCkgPT4gc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID9cbiAgICAgICAgICAgICAgICBvcmlnUHJvcCAmJiAob3JpZ1Byb3AuZ2V0ID9cbiAgICAgICAgICAgICAgICAgICAgb3JpZ1Byb3AuZ2V0LmFwcGx5KHJlYXNvbikgOlxuICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcC52YWx1ZSkgOlxuICAgICAgICAgICAgICAgIHByb21pc2Uuc3RhY2tcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKTtcbiAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG4gICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xufVxuZnVuY3Rpb24gcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gcHJvbWlzZS5fbGlzdGVuZXJzO1xuICAgIHByb21pc2UuX2xpc3RlbmVycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcnNbaV0pO1xuICAgIH1cbiAgICB2YXIgcHNkID0gcHJvbWlzZS5fUFNEO1xuICAgIC0tcHNkLnJlZiB8fCBwc2QuZmluYWxpemUoKTtcbiAgICBpZiAobnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIHtcbiAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgICAgYXNhcCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBwcm9taXNlLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNiID0gcHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5vbkZ1bGZpbGxlZCA6IGxpc3RlbmVyLm9uUmVqZWN0ZWQ7XG4gICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAocHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5yZXNvbHZlIDogbGlzdGVuZXIucmVqZWN0KShwcm9taXNlLl92YWx1ZSk7XG4gICAgfVxuICAgICsrbGlzdGVuZXIucHNkLnJlZjtcbiAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgIGFzYXAoY2FsbExpc3RlbmVyLCBbY2IsIHByb21pc2UsIGxpc3RlbmVyXSk7XG59XG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIoY2IsIHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY3VycmVudEZ1bGZpbGxlciA9IHByb21pc2U7XG4gICAgICAgIHZhciByZXQsIHZhbHVlID0gcHJvbWlzZS5fdmFsdWU7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSkge1xuICAgICAgICAgICAgcmV0ID0gY2IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlamVjdGluZ0Vycm9ycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVqZWN0aW5nRXJyb3JzID0gW107XG4gICAgICAgICAgICByZXQgPSBjYih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVqZWN0aW5nRXJyb3JzLmluZGV4T2YodmFsdWUpID09PSAtMSlcbiAgICAgICAgICAgICAgICBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIucmVzb2x2ZShyZXQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsaXN0ZW5lci5yZWplY3QoZSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50RnVsZmlsbGVyID0gbnVsbDtcbiAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG4gICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgICAgICAtLWxpc3RlbmVyLnBzZC5yZWYgfHwgbGlzdGVuZXIucHNkLmZpbmFsaXplKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U3RhY2socHJvbWlzZSwgc3RhY2tzLCBsaW1pdCkge1xuICAgIGlmIChzdGFja3MubGVuZ3RoID09PSBsaW1pdClcbiAgICAgICAgcmV0dXJuIHN0YWNrcztcbiAgICB2YXIgc3RhY2sgPSBcIlwiO1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGZhaWx1cmUgPSBwcm9taXNlLl92YWx1ZSwgZXJyb3JOYW1lLCBtZXNzYWdlO1xuICAgICAgICBpZiAoZmFpbHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBlcnJvck5hbWUgPSBmYWlsdXJlLm5hbWUgfHwgXCJFcnJvclwiO1xuICAgICAgICAgICAgbWVzc2FnZSA9IGZhaWx1cmUubWVzc2FnZSB8fCBmYWlsdXJlO1xuICAgICAgICAgICAgc3RhY2sgPSBwcmV0dHlTdGFjayhmYWlsdXJlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yTmFtZSA9IGZhaWx1cmU7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBzdGFja3MucHVzaChlcnJvck5hbWUgKyAobWVzc2FnZSA/IFwiOiBcIiArIG1lc3NhZ2UgOiBcIlwiKSArIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIHN0YWNrID0gcHJldHR5U3RhY2socHJvbWlzZS5fc3RhY2tIb2xkZXIsIDIpO1xuICAgICAgICBpZiAoc3RhY2sgJiYgc3RhY2tzLmluZGV4T2Yoc3RhY2spID09PSAtMSlcbiAgICAgICAgICAgIHN0YWNrcy5wdXNoKHN0YWNrKTtcbiAgICAgICAgaWYgKHByb21pc2UuX3ByZXYpXG4gICAgICAgICAgICBnZXRTdGFjayhwcm9taXNlLl9wcmV2LCBzdGFja3MsIGxpbWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrcztcbn1cbmZ1bmN0aW9uIGxpbmtUb1ByZXZpb3VzUHJvbWlzZShwcm9taXNlLCBwcmV2KSB7XG4gICAgdmFyIG51bVByZXYgPSBwcmV2ID8gcHJldi5fbnVtUHJldiArIDEgOiAwO1xuICAgIGlmIChudW1QcmV2IDwgTE9OR19TVEFDS1NfQ0xJUF9MSU1JVCkge1xuICAgICAgICBwcm9taXNlLl9wcmV2ID0gcHJldjtcbiAgICAgICAgcHJvbWlzZS5fbnVtUHJldiA9IG51bVByZXY7XG4gICAgfVxufVxuZnVuY3Rpb24gcGh5c2ljYWxUaWNrKCkge1xuICAgIGJlZ2luTWljcm9UaWNrU2NvcGUoKSAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xufVxuZnVuY3Rpb24gYmVnaW5NaWNyb1RpY2tTY29wZSgpIHtcbiAgICB2YXIgd2FzUm9vdEV4ZWMgPSBpc091dHNpZGVNaWNyb1RpY2s7XG4gICAgaXNPdXRzaWRlTWljcm9UaWNrID0gZmFsc2U7XG4gICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICByZXR1cm4gd2FzUm9vdEV4ZWM7XG59XG5mdW5jdGlvbiBlbmRNaWNyb1RpY2tTY29wZSgpIHtcbiAgICB2YXIgY2FsbGJhY2tzLCBpLCBsO1xuICAgIGRvIHtcbiAgICAgICAgd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IG1pY3JvdGlja1F1ZXVlO1xuICAgICAgICAgICAgbWljcm90aWNrUXVldWUgPSBbXTtcbiAgICAgICAgICAgIGwgPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGl0ZW1bMF0uYXBwbHkobnVsbCwgaXRlbVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKTtcbiAgICBpc091dHNpZGVNaWNyb1RpY2sgPSB0cnVlO1xuICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplUGh5c2ljYWxUaWNrKCkge1xuICAgIHZhciB1bmhhbmRsZWRFcnJzID0gdW5oYW5kbGVkRXJyb3JzO1xuICAgIHVuaGFuZGxlZEVycm9ycyA9IFtdO1xuICAgIHVuaGFuZGxlZEVycnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgcC5fUFNELm9udW5oYW5kbGVkLmNhbGwobnVsbCwgcC5fdmFsdWUsIHApO1xuICAgIH0pO1xuICAgIHZhciBmaW5hbGl6ZXJzID0gdGlja0ZpbmFsaXplcnMuc2xpY2UoMCk7XG4gICAgdmFyIGkgPSBmaW5hbGl6ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSlcbiAgICAgICAgZmluYWxpemVyc1stLWldKCk7XG59XG5mdW5jdGlvbiBydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrKGZuKSB7XG4gICAgZnVuY3Rpb24gZmluYWxpemVyKCkge1xuICAgICAgICBmbigpO1xuICAgICAgICB0aWNrRmluYWxpemVycy5zcGxpY2UodGlja0ZpbmFsaXplcnMuaW5kZXhPZihmaW5hbGl6ZXIpLCAxKTtcbiAgICB9XG4gICAgdGlja0ZpbmFsaXplcnMucHVzaChmaW5hbGl6ZXIpO1xuICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG4gICAgYXNhcCgoKSA9PiB7XG4gICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICB9LCBbXSk7XG59XG5mdW5jdGlvbiBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpIHtcbiAgICBpZiAoIXVuaGFuZGxlZEVycm9ycy5zb21lKHAgPT4gcC5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlKSlcbiAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnB1c2gocHJvbWlzZSk7XG59XG5mdW5jdGlvbiBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSkge1xuICAgIHZhciBpID0gdW5oYW5kbGVkRXJyb3JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSlcbiAgICAgICAgaWYgKHVuaGFuZGxlZEVycm9yc1stLWldLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWUpIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZEVycm9ycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbn1cbmZ1bmN0aW9uIFByb21pc2VSZWplY3QocmVhc29uKSB7XG4gICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIGZhbHNlLCByZWFzb24pO1xufVxuZnVuY3Rpb24gd3JhcChmbiwgZXJyb3JDYXRjaGVyKSB7XG4gICAgdmFyIHBzZCA9IFBTRDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCksIG91dGVyU2NvcGUgPSBQU0Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckNhdGNoZXIgJiYgZXJyb3JDYXRjaGVyKGUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh3YXNSb290RXhlYylcbiAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IHRhc2sgPSB7IGF3YWl0czogMCwgZWNob2VzOiAwLCBpZDogMCB9O1xudmFyIHRhc2tDb3VudGVyID0gMDtcbnZhciB6b25lU3RhY2sgPSBbXTtcbnZhciB6b25lRWNob2VzID0gMDtcbnZhciB0b3RhbEVjaG9lcyA9IDA7XG52YXIgem9uZV9pZF9jb3VudGVyID0gMDtcbmZ1bmN0aW9uIG5ld1Njb3BlKGZuLCBwcm9wcywgYTEsIGEyKSB7XG4gICAgdmFyIHBhcmVudCA9IFBTRCwgcHNkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIHBzZC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcHNkLnJlZiA9IDA7XG4gICAgcHNkLmdsb2JhbCA9IGZhbHNlO1xuICAgIHBzZC5pZCA9ICsrem9uZV9pZF9jb3VudGVyO1xuICAgIHZhciBnbG9iYWxFbnYgPSBnbG9iYWxQU0QuZW52O1xuICAgIHBzZC5lbnYgPSBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgIFByb21pc2U6IERleGllUHJvbWlzZSxcbiAgICAgICAgUHJvbWlzZVByb3A6IHsgdmFsdWU6IERleGllUHJvbWlzZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgICAgICBhbGw6IERleGllUHJvbWlzZS5hbGwsXG4gICAgICAgIHJhY2U6IERleGllUHJvbWlzZS5yYWNlLFxuICAgICAgICBhbGxTZXR0bGVkOiBEZXhpZVByb21pc2UuYWxsU2V0dGxlZCxcbiAgICAgICAgYW55OiBEZXhpZVByb21pc2UuYW55LFxuICAgICAgICByZXNvbHZlOiBEZXhpZVByb21pc2UucmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBEZXhpZVByb21pc2UucmVqZWN0LFxuICAgICAgICBudGhlbjogZ2V0UGF0Y2hlZFByb21pc2VUaGVuKGdsb2JhbEVudi5udGhlbiwgcHNkKSxcbiAgICAgICAgZ3RoZW46IGdldFBhdGNoZWRQcm9taXNlVGhlbihnbG9iYWxFbnYuZ3RoZW4sIHBzZClcbiAgICB9IDoge307XG4gICAgaWYgKHByb3BzKVxuICAgICAgICBleHRlbmQocHNkLCBwcm9wcyk7XG4gICAgKytwYXJlbnQucmVmO1xuICAgIHBzZC5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLS10aGlzLnBhcmVudC5yZWYgfHwgdGhpcy5wYXJlbnQuZmluYWxpemUoKTtcbiAgICB9O1xuICAgIHZhciBydiA9IHVzZVBTRChwc2QsIGZuLCBhMSwgYTIpO1xuICAgIGlmIChwc2QucmVmID09PSAwKVxuICAgICAgICBwc2QuZmluYWxpemUoKTtcbiAgICByZXR1cm4gcnY7XG59XG5mdW5jdGlvbiBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcbiAgICBpZiAoIXRhc2suaWQpXG4gICAgICAgIHRhc2suaWQgPSArK3Rhc2tDb3VudGVyO1xuICAgICsrdGFzay5hd2FpdHM7XG4gICAgdGFzay5lY2hvZXMgKz0gWk9ORV9FQ0hPX0xJTUlUO1xuICAgIHJldHVybiB0YXNrLmlkO1xufVxuZnVuY3Rpb24gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgaWYgKCF0YXNrLmF3YWl0cylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgtLXRhc2suYXdhaXRzID09PSAwKVxuICAgICAgICB0YXNrLmlkID0gMDtcbiAgICB0YXNrLmVjaG9lcyA9IHRhc2suYXdhaXRzICogWk9ORV9FQ0hPX0xJTUlUO1xuICAgIHJldHVybiB0cnVlO1xufVxuaWYgKCgnJyArIG5hdGl2ZVByb21pc2VUaGVuKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgPT09IC0xKSB7XG4gICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyA9IG5vcDtcbn1cbmZ1bmN0aW9uIG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyhwb3NzaWJsZVByb21pc2UpIHtcbiAgICBpZiAodGFzay5lY2hvZXMgJiYgcG9zc2libGVQcm9taXNlICYmIHBvc3NpYmxlUHJvbWlzZS5jb25zdHJ1Y3RvciA9PT0gTmF0aXZlUHJvbWlzZSkge1xuICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICByZXR1cm4gcG9zc2libGVQcm9taXNlLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0sIGUgPT4ge1xuICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9zc2libGVQcm9taXNlO1xufVxuZnVuY3Rpb24gem9uZUVudGVyRWNobyh0YXJnZXRab25lKSB7XG4gICAgKyt0b3RhbEVjaG9lcztcbiAgICBpZiAoIXRhc2suZWNob2VzIHx8IC0tdGFzay5lY2hvZXMgPT09IDApIHtcbiAgICAgICAgdGFzay5lY2hvZXMgPSB0YXNrLmlkID0gMDtcbiAgICB9XG4gICAgem9uZVN0YWNrLnB1c2goUFNEKTtcbiAgICBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiB6b25lTGVhdmVFY2hvKCkge1xuICAgIHZhciB6b25lID0gem9uZVN0YWNrW3pvbmVTdGFjay5sZW5ndGggLSAxXTtcbiAgICB6b25lU3RhY2sucG9wKCk7XG4gICAgc3dpdGNoVG9ab25lKHpvbmUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHN3aXRjaFRvWm9uZSh0YXJnZXRab25lLCBiRW50ZXJpbmdab25lKSB7XG4gICAgdmFyIGN1cnJlbnRab25lID0gUFNEO1xuICAgIGlmIChiRW50ZXJpbmdab25lID8gdGFzay5lY2hvZXMgJiYgKCF6b25lRWNob2VzKysgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSA6IHpvbmVFY2hvZXMgJiYgKCEtLXpvbmVFY2hvZXMgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSkge1xuICAgICAgICBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGJFbnRlcmluZ1pvbmUgPyB6b25lRW50ZXJFY2hvLmJpbmQobnVsbCwgdGFyZ2V0Wm9uZSkgOiB6b25lTGVhdmVFY2hvKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldFpvbmUgPT09IFBTRClcbiAgICAgICAgcmV0dXJuO1xuICAgIFBTRCA9IHRhcmdldFpvbmU7XG4gICAgaWYgKGN1cnJlbnRab25lID09PSBnbG9iYWxQU0QpXG4gICAgICAgIGdsb2JhbFBTRC5lbnYgPSBzbmFwU2hvdCgpO1xuICAgIGlmIChwYXRjaEdsb2JhbFByb21pc2UpIHtcbiAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBnbG9iYWxQU0QuZW52LlByb21pc2U7XG4gICAgICAgIHZhciB0YXJnZXRFbnYgPSB0YXJnZXRab25lLmVudjtcbiAgICAgICAgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW4gPSB0YXJnZXRFbnYubnRoZW47XG4gICAgICAgIEdsb2JhbFByb21pc2UucHJvdG90eXBlLnRoZW4gPSB0YXJnZXRFbnYuZ3RoZW47XG4gICAgICAgIGlmIChjdXJyZW50Wm9uZS5nbG9iYWwgfHwgdGFyZ2V0Wm9uZS5nbG9iYWwpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZ2xvYmFsLCAnUHJvbWlzZScsIHRhcmdldEVudi5Qcm9taXNlUHJvcCk7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFsbCA9IHRhcmdldEVudi5hbGw7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJhY2UgPSB0YXJnZXRFbnYucmFjZTtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmVzb2x2ZSA9IHRhcmdldEVudi5yZXNvbHZlO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZWplY3QgPSB0YXJnZXRFbnYucmVqZWN0O1xuICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbGxTZXR0bGVkKVxuICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCA9IHRhcmdldEVudi5hbGxTZXR0bGVkO1xuICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbnkpXG4gICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbnkgPSB0YXJnZXRFbnYuYW55O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc25hcFNob3QoKSB7XG4gICAgdmFyIEdsb2JhbFByb21pc2UgPSBfZ2xvYmFsLlByb21pc2U7XG4gICAgcmV0dXJuIHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgUHJvbWlzZTogR2xvYmFsUHJvbWlzZSxcbiAgICAgICAgUHJvbWlzZVByb3A6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2dsb2JhbCwgXCJQcm9taXNlXCIpLFxuICAgICAgICBhbGw6IEdsb2JhbFByb21pc2UuYWxsLFxuICAgICAgICByYWNlOiBHbG9iYWxQcm9taXNlLnJhY2UsXG4gICAgICAgIGFsbFNldHRsZWQ6IEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCxcbiAgICAgICAgYW55OiBHbG9iYWxQcm9taXNlLmFueSxcbiAgICAgICAgcmVzb2x2ZTogR2xvYmFsUHJvbWlzZS5yZXNvbHZlLFxuICAgICAgICByZWplY3Q6IEdsb2JhbFByb21pc2UucmVqZWN0LFxuICAgICAgICBudGhlbjogbmF0aXZlUHJvbWlzZVByb3RvLnRoZW4sXG4gICAgICAgIGd0aGVuOiBHbG9iYWxQcm9taXNlLnByb3RvdHlwZS50aGVuXG4gICAgfSA6IHt9O1xufVxuZnVuY3Rpb24gdXNlUFNEKHBzZCwgZm4sIGExLCBhMiwgYTMpIHtcbiAgICB2YXIgb3V0ZXJTY29wZSA9IFBTRDtcbiAgICB0cnkge1xuICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGZuKGExLCBhMiwgYTMpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGpvYikge1xuICAgIG5hdGl2ZVByb21pc2VUaGVuLmNhbGwocmVzb2x2ZWROYXRpdmVQcm9taXNlLCBqb2IpO1xufVxuZnVuY3Rpb24gbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChmbiwgem9uZSwgcG9zc2libGVBd2FpdCwgY2xlYW51cCkge1xuICAgIHJldHVybiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dGVyWm9uZSA9IFBTRDtcbiAgICAgICAgaWYgKHBvc3NpYmxlQXdhaXQpXG4gICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgdHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclpvbmUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjbGVhbnVwKVxuICAgICAgICAgICAgICAgIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhdGNoZWRQcm9taXNlVGhlbihvcmlnVGhlbiwgem9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob25SZXNvbHZlZCwgb25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gb3JpZ1RoZW4uY2FsbCh0aGlzLCBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVzb2x2ZWQsIHpvbmUpLCBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVqZWN0ZWQsIHpvbmUpKTtcbiAgICB9O1xufVxuY29uc3QgVU5IQU5ETEVEUkVKRUNUSU9OID0gXCJ1bmhhbmRsZWRyZWplY3Rpb25cIjtcbmZ1bmN0aW9uIGdsb2JhbEVycm9yKGVyciwgcHJvbWlzZSkge1xuICAgIHZhciBydjtcbiAgICB0cnkge1xuICAgICAgICBydiA9IHByb21pc2Uub251bmNhdGNoZWQoZXJyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIGlmIChydiAhPT0gZmFsc2UpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQsIGV2ZW50RGF0YSA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBlcnIgfTtcbiAgICAgICAgICAgIGlmIChfZ2xvYmFsLmRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICAgICAgICBldmVudC5pbml0RXZlbnQoVU5IQU5ETEVEUkVKRUNUSU9OLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBleHRlbmQoZXZlbnQsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfZ2xvYmFsLkN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoVU5IQU5ETEVEUkVKRUNUSU9OLCB7IGRldGFpbDogZXZlbnREYXRhIH0pO1xuICAgICAgICAgICAgICAgIGV4dGVuZChldmVudCwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudCAmJiBfZ2xvYmFsLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIV9nbG9iYWwuUHJvbWlzZVJlamVjdGlvbkV2ZW50ICYmIF9nbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVidWcgJiYgZXZlbnQgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuaGFuZGxlZCByZWplY3Rpb246ICR7ZXJyLnN0YWNrIHx8IGVycn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG59XG52YXIgcmVqZWN0aW9uID0gRGV4aWVQcm9taXNlLnJlamVjdDtcblxuZnVuY3Rpb24gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikge1xuICAgIGlmICghZGIuaWRiZGIgfHwgKCFkYi5fc3RhdGUub3BlbkNvbXBsZXRlICYmICghUFNELmxldFRocm91Z2ggJiYgIWRiLl92aXApKSkge1xuICAgICAgICBpZiAoZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChkYi5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRiLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICBpZiAoIWRiLl9vcHRpb25zLmF1dG9PcGVuKVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG4gICAgICAgICAgICBkYi5vcGVuKCkuY2F0Y2gobm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGIuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oKCkgPT4gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgICAgICAgIGRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gZXJybmFtZXMuSW52YWxpZFN0YXRlICYmIGRiLmlzT3BlbigpICYmIC0tZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IE5lZWQgdG8gcmVvcGVuIGRiJyk7XG4gICAgICAgICAgICAgICAgZGIuX2Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRiLm9wZW4oKS50aGVuKCgpID0+IHRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIFBTRC50cmFucyA9IHRyYW5zO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnMuX2NvbXBsZXRpb24udGhlbigoKSA9PiByZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IERFWElFX1ZFUlNJT04gPSAnMy4yLjcnO1xuY29uc3QgbWF4U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzNSk7XG5jb25zdCBtaW5LZXkgPSAtSW5maW5pdHk7XG5jb25zdCBJTlZBTElEX0tFWV9BUkdVTUVOVCA9IFwiSW52YWxpZCBrZXkgcHJvdmlkZWQuIEtleXMgbXVzdCBiZSBvZiB0eXBlIHN0cmluZywgbnVtYmVyLCBEYXRlIG9yIEFycmF5PHN0cmluZyB8IG51bWJlciB8IERhdGU+LlwiO1xuY29uc3QgU1RSSU5HX0VYUEVDVEVEID0gXCJTdHJpbmcgZXhwZWN0ZWQuXCI7XG5jb25zdCBjb25uZWN0aW9ucyA9IFtdO1xuY29uc3QgaXNJRU9yRWRnZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC8oTVNJRXxUcmlkZW50fEVkZ2UpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1ZyA9IGlzSUVPckVkZ2U7XG5jb25zdCBoYW5nc09uRGVsZXRlTGFyZ2VLZXlSYW5nZSA9IGlzSUVPckVkZ2U7XG5jb25zdCBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIgPSBmcmFtZSA9PiAhLyhkZXhpZVxcLmpzfGRleGllXFwubWluXFwuanMpLy50ZXN0KGZyYW1lKTtcbmNvbnN0IERCTkFNRVNfREIgPSAnX19kYm5hbWVzJztcbmNvbnN0IFJFQURPTkxZID0gJ3JlYWRvbmx5JztcbmNvbnN0IFJFQURXUklURSA9ICdyZWFkd3JpdGUnO1xuXG5mdW5jdGlvbiBjb21iaW5lKGZpbHRlcjEsIGZpbHRlcjIpIHtcbiAgICByZXR1cm4gZmlsdGVyMSA/XG4gICAgICAgIGZpbHRlcjIgP1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsdGVyMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICYmIGZpbHRlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSA6XG4gICAgICAgICAgICBmaWx0ZXIxIDpcbiAgICAgICAgZmlsdGVyMjtcbn1cblxuY29uc3QgQW55UmFuZ2UgPSB7XG4gICAgdHlwZTogMyAsXG4gICAgbG93ZXI6IC1JbmZpbml0eSxcbiAgICBsb3dlck9wZW46IGZhbHNlLFxuICAgIHVwcGVyOiBbW11dLFxuICAgIHVwcGVyT3BlbjogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09IFwic3RyaW5nXCIgJiYgIS9cXC4vLnRlc3Qoa2V5UGF0aClcbiAgICAgICAgPyAob2JqKSA9PiB7XG4gICAgICAgICAgICBpZiAob2JqW2tleVBhdGhdID09PSB1bmRlZmluZWQgJiYgKGtleVBhdGggaW4gb2JqKSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIDogKG9iaikgPT4gb2JqO1xufVxuXG5jbGFzcyBUYWJsZSB7XG4gICAgX3RyYW5zKG1vZGUsIGZuLCB3cml0ZUxvY2tlZCkge1xuICAgICAgICBjb25zdCB0cmFucyA9IHRoaXMuX3R4IHx8IFBTRC50cmFucztcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBmdW5jdGlvbiBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKSB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zLnNjaGVtYVt0YWJsZU5hbWVdKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGUgXCIgKyB0YWJsZU5hbWUgKyBcIiBub3QgcGFydCBvZiB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybiBmbih0cmFucy5pZGJ0cmFucywgdHJhbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zICYmIHRyYW5zLmRiID09PSB0aGlzLmRiID9cbiAgICAgICAgICAgICAgICB0cmFucyA9PT0gUFNELnRyYW5zID9cbiAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlKCgpID0+IHRyYW5zLl9wcm9taXNlKG1vZGUsIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uLCB3cml0ZUxvY2tlZCksIHsgdHJhbnM6IHRyYW5zLCB0cmFuc2xlc3M6IFBTRC50cmFuc2xlc3MgfHwgUFNEIH0pIDpcbiAgICAgICAgICAgICAgICB0ZW1wVHJhbnNhY3Rpb24odGhpcy5kYiwgbW9kZSwgW3RoaXMubmFtZV0sIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh3YXNSb290RXhlYylcbiAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChrZXlPckNyaXQsIGNiKSB7XG4gICAgICAgIGlmIChrZXlPckNyaXQgJiYga2V5T3JDcml0LmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShrZXlPckNyaXQpLmZpcnN0KGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkb25seScsICh0cmFucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5nZXQoeyB0cmFucywga2V5OiBrZXlPckNyaXQgfSlcbiAgICAgICAgICAgICAgICAudGhlbihyZXMgPT4gdGhpcy5ob29rLnJlYWRpbmcuZmlyZShyZXMpKTtcbiAgICAgICAgfSkudGhlbihjYik7XG4gICAgfVxuICAgIHdoZXJlKGluZGV4T3JDcml0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXhPckNyaXQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGluZGV4T3JDcml0KTtcbiAgICAgICAgaWYgKGlzQXJyYXkoaW5kZXhPckNyaXQpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGBbJHtpbmRleE9yQ3JpdC5qb2luKCcrJyl9XWApO1xuICAgICAgICBjb25zdCBrZXlQYXRocyA9IGtleXMoaW5kZXhPckNyaXQpO1xuICAgICAgICBpZiAoa2V5UGF0aHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAud2hlcmUoa2V5UGF0aHNbMF0pXG4gICAgICAgICAgICAgICAgLmVxdWFscyhpbmRleE9yQ3JpdFtrZXlQYXRoc1swXV0pO1xuICAgICAgICBjb25zdCBjb21wb3VuZEluZGV4ID0gdGhpcy5zY2hlbWEuaW5kZXhlcy5jb25jYXQodGhpcy5zY2hlbWEucHJpbUtleSkuZmlsdGVyKGl4ID0+IHtcbiAgICAgICAgICAgIGlmIChpeC5jb21wb3VuZCAmJlxuICAgICAgICAgICAgICAgIGtleVBhdGhzLmV2ZXJ5KGtleVBhdGggPT4gaXgua2V5UGF0aC5pbmRleE9mKGtleVBhdGgpID49IDApKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlQYXRocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aHMuaW5kZXhPZihpeC5rZXlQYXRoW2ldKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KS5zb3J0KChhLCBiKSA9PiBhLmtleVBhdGgubGVuZ3RoIC0gYi5rZXlQYXRoLmxlbmd0aClbMF07XG4gICAgICAgIGlmIChjb21wb3VuZEluZGV4ICYmIHRoaXMuZGIuX21heEtleSAhPT0gbWF4U3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlQYXRoc0luVmFsaWRPcmRlciA9IGNvbXBvdW5kSW5kZXgua2V5UGF0aC5zbGljZSgwLCBrZXlQYXRocy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAud2hlcmUoa2V5UGF0aHNJblZhbGlkT3JkZXIpXG4gICAgICAgICAgICAgICAgLmVxdWFscyhrZXlQYXRoc0luVmFsaWRPcmRlci5tYXAoa3AgPT4gaW5kZXhPckNyaXRba3BdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wb3VuZEluZGV4ICYmIGRlYnVnKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGUgcXVlcnkgJHtKU09OLnN0cmluZ2lmeShpbmRleE9yQ3JpdCl9IG9uICR7dGhpcy5uYW1lfSB3b3VsZCBiZW5lZml0IG9mIGEgYCArXG4gICAgICAgICAgICAgICAgYGNvbXBvdW5kIGluZGV4IFske2tleVBhdGhzLmpvaW4oJysnKX1dYCk7XG4gICAgICAgIGNvbnN0IHsgaWR4QnlOYW1lIH0gPSB0aGlzLnNjaGVtYTtcbiAgICAgICAgY29uc3QgaWRiID0gdGhpcy5kYi5fZGVwcy5pbmRleGVkREI7XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZGIuY21wKGEsIGIpID09PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2lkeCwgZmlsdGVyRnVuY3Rpb25dID0ga2V5UGF0aHMucmVkdWNlKChbcHJldkluZGV4LCBwcmV2RmlsdGVyRm5dLCBrZXlQYXRoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGlkeEJ5TmFtZVtrZXlQYXRoXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW5kZXhPckNyaXRba2V5UGF0aF07XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHByZXZJbmRleCB8fCBpbmRleCxcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXggfHwgIWluZGV4ID9cbiAgICAgICAgICAgICAgICAgICAgY29tYmluZShwcmV2RmlsdGVyRm4sIGluZGV4ICYmIGluZGV4Lm11bHRpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBnZXRCeUtleVBhdGgoeCwga2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkocHJvcCkgJiYgcHJvcC5zb21lKGl0ZW0gPT4gZXF1YWxzKHZhbHVlLCBpdGVtKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogeCA9PiBlcXVhbHModmFsdWUsIGdldEJ5S2V5UGF0aCh4LCBrZXlQYXRoKSkpXG4gICAgICAgICAgICAgICAgICAgIDogcHJldkZpbHRlckZuXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LCBbbnVsbCwgbnVsbF0pO1xuICAgICAgICByZXR1cm4gaWR4ID9cbiAgICAgICAgICAgIHRoaXMud2hlcmUoaWR4Lm5hbWUpLmVxdWFscyhpbmRleE9yQ3JpdFtpZHgua2V5UGF0aF0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOlxuICAgICAgICAgICAgY29tcG91bmRJbmRleCA/XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pIDpcbiAgICAgICAgICAgICAgICB0aGlzLndoZXJlKGtleVBhdGhzKS5lcXVhbHMoJycpO1xuICAgIH1cbiAgICBmaWx0ZXIoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuYW5kKGZpbHRlckZ1bmN0aW9uKTtcbiAgICB9XG4gICAgY291bnQodGhlblNob3J0Y3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmNvdW50KHRoZW5TaG9ydGN1dCk7XG4gICAgfVxuICAgIG9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkub2Zmc2V0KG9mZnNldCk7XG4gICAgfVxuICAgIGxpbWl0KG51bVJvd3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkubGltaXQobnVtUm93cyk7XG4gICAgfVxuICAgIGVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuZWFjaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHRvQXJyYXkodGhlblNob3J0Y3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnRvQXJyYXkodGhlblNob3J0Y3V0KTtcbiAgICB9XG4gICAgdG9Db2xsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzKSk7XG4gICAgfVxuICAgIG9yZGVyQnkoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLkNvbGxlY3Rpb24obmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgaXNBcnJheShpbmRleCkgP1xuICAgICAgICAgICAgYFske2luZGV4LmpvaW4oJysnKX1dYCA6XG4gICAgICAgICAgICBpbmRleCkpO1xuICAgIH1cbiAgICByZXZlcnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIG1hcFRvQ2xhc3MoY29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEubWFwcGVkQ2xhc3MgPSBjb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgcmVhZEhvb2sgPSBvYmogPT4ge1xuICAgICAgICAgICAgaWYgKCFvYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IE9iamVjdC5jcmVhdGUoY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gaW4gb2JqKVxuICAgICAgICAgICAgICAgIGlmIChoYXNPd24ob2JqLCBtKSlcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1ttXSA9IG9ialttXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zY2hlbWEucmVhZEhvb2spIHtcbiAgICAgICAgICAgIHRoaXMuaG9vay5yZWFkaW5nLnVuc3Vic2NyaWJlKHRoaXMuc2NoZW1hLnJlYWRIb29rKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVtYS5yZWFkSG9vayA9IHJlYWRIb29rO1xuICAgICAgICB0aGlzLmhvb2soXCJyZWFkaW5nXCIsIHJlYWRIb29rKTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBkZWZpbmVDbGFzcygpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2xhc3MoY29udGVudCkge1xuICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hcFRvQ2xhc3MoQ2xhc3MpO1xuICAgIH1cbiAgICBhZGQob2JqLCBrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhdXRvLCBrZXlQYXRoIH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgICAgICBsZXQgb2JqVG9BZGQgPSBvYmo7XG4gICAgICAgIGlmIChrZXlQYXRoICYmIGF1dG8pIHtcbiAgICAgICAgICAgIG9ialRvQWRkID0gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkob2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXkgIT0gbnVsbCA/IFtrZXldIDogbnVsbCwgdmFsdWVzOiBbb2JqVG9BZGRdIH0pO1xuICAgICAgICB9KS50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdClcbiAgICAgICAgICAgIC50aGVuKGxhc3RSZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBsYXN0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUoa2V5T3JPYmplY3QsIG1vZGlmaWNhdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXlPck9iamVjdCA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkoa2V5T3JPYmplY3QpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRCeUtleVBhdGgoa2V5T3JPYmplY3QsIHRoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aCk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJHaXZlbiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBpdHMgcHJpbWFyeSBrZXlcIikpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWNhdGlvbnMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBrZXlzKG1vZGlmaWNhdGlvbnMpLmZvckVhY2goa2V5UGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoa2V5T3JPYmplY3QsIGtleVBhdGgsIG1vZGlmaWNhdGlvbnNba2V5UGF0aF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWNhdGlvbnMoa2V5T3JPYmplY3QsIHsgdmFsdWU6IGtleU9yT2JqZWN0LCBwcmltS2V5OiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5T3JPYmplY3QpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXQob2JqLCBrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhdXRvLCBrZXlQYXRoIH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgICAgICBsZXQgb2JqVG9BZGQgPSBvYmo7XG4gICAgICAgIGlmIChrZXlQYXRoICYmIGF1dG8pIHtcbiAgICAgICAgICAgIG9ialRvQWRkID0gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkob2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ3B1dCcsIHZhbHVlczogW29ialRvQWRkXSwga2V5czoga2V5ICE9IG51bGwgPyBba2V5XSA6IG51bGwgfSkpXG4gICAgICAgICAgICAudGhlbihyZXMgPT4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogcmVzLmxhc3RSZXN1bHQpXG4gICAgICAgICAgICAudGhlbihsYXN0UmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IFtrZXldIH0pKVxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IEFueVJhbmdlIH0pKVxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGJ1bGtHZXQoa2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWRvbmx5JywgdHJhbnMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5nZXRNYW55KHtcbiAgICAgICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgICAgIHRyYW5zXG4gICAgICAgICAgICB9KS50aGVuKHJlc3VsdCA9PiByZXN1bHQubWFwKHJlcyA9PiB0aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcykpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1bGtBZGQob2JqZWN0cywga2V5c09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShrZXlzT3JPcHRpb25zKSA/IGtleXNPck9wdGlvbnMgOiB1bmRlZmluZWQ7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dG8sIGtleVBhdGggfSA9IHRoaXMuc2NoZW1hLnByaW1LZXk7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBrZXlzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtBZGQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgICAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJBcmd1bWVudHMgb2JqZWN0cyBhbmQga2V5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgY29uc3QgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG9iamVjdHNUb0FkZCA9IGtleVBhdGggJiYgYXV0byA/XG4gICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgICAgICAgICBvYmplY3RzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2FkZCcsIGtleXM6IGtleXMsIHZhbHVlczogb2JqZWN0c1RvQWRkLCB3YW50UmVzdWx0cyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKCh7IG51bUZhaWx1cmVzLCByZXN1bHRzLCBsYXN0UmVzdWx0LCBmYWlsdXJlcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FudFJlc3VsdHMgPyByZXN1bHRzIDogbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihgJHt0aGlzLm5hbWV9LmJ1bGtBZGQoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1PYmplY3RzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVsa1B1dChvYmplY3RzLCBrZXlzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgKGtleXMgPyB1bmRlZmluZWQgOiBrZXlzT3JPcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd2FudFJlc3VsdHMgPSBvcHRpb25zID8gb3B0aW9ucy5hbGxLZXlzIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0bywga2V5UGF0aCB9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiYnVsa1B1dCgpOiBrZXlzIGFyZ3VtZW50IGludmFsaWQgb24gdGFibGVzIHdpdGggaW5ib3VuZCBrZXlzXCIpO1xuICAgICAgICAgICAgaWYgKGtleXMgJiYga2V5cy5sZW5ndGggIT09IG9iamVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICBjb25zdCBudW1PYmplY3RzID0gb2JqZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgb2JqZWN0c1RvUHV0ID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgICAgICAgICBvYmplY3RzLm1hcCh3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKSkgOlxuICAgICAgICAgICAgICAgIG9iamVjdHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAncHV0Jywga2V5czoga2V5cywgdmFsdWVzOiBvYmplY3RzVG9QdXQsIHdhbnRSZXN1bHRzIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHsgbnVtRmFpbHVyZXMsIHJlc3VsdHMsIGxhc3RSZXN1bHQsIGZhaWx1cmVzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB3YW50UmVzdWx0cyA/IHJlc3VsdHMgOiBsYXN0UmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKGAke3RoaXMubmFtZX0uYnVsa1B1dCgpOiAke251bUZhaWx1cmVzfSBvZiAke251bU9iamVjdHN9IG9wZXJhdGlvbnMgZmFpbGVkYCwgZmFpbHVyZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWxrRGVsZXRlKGtleXMpIHtcbiAgICAgICAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBrZXlzIH0pO1xuICAgICAgICB9KS50aGVuKCh7IG51bUZhaWx1cmVzLCBsYXN0UmVzdWx0LCBmYWlsdXJlcyB9KSA9PiB7XG4gICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKGAke3RoaXMubmFtZX0uYnVsa0RlbGV0ZSgpOiAke251bUZhaWx1cmVzfSBvZiAke251bUtleXN9IG9wZXJhdGlvbnMgZmFpbGVkYCwgZmFpbHVyZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEV2ZW50cyhjdHgpIHtcbiAgICB2YXIgZXZzID0ge307XG4gICAgdmFyIHJ2ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICAgICAgICAgIHdoaWxlICgtLWkpXG4gICAgICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBldnNbZXZlbnROYW1lXS5zdWJzY3JpYmUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBldnNbZXZlbnROYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcnYuYWRkRXZlbnRUeXBlID0gYWRkO1xuICAgIGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICBhZGQoYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICAgIGZ1bmN0aW9uIGFkZChldmVudE5hbWUsIGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gYWRkQ29uZmlndXJlZEV2ZW50cyhldmVudE5hbWUpO1xuICAgICAgICBpZiAoIWNoYWluRnVuY3Rpb24pXG4gICAgICAgICAgICBjaGFpbkZ1bmN0aW9uID0gcmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW47XG4gICAgICAgIGlmICghZGVmYXVsdEZ1bmN0aW9uKVxuICAgICAgICAgICAgZGVmYXVsdEZ1bmN0aW9uID0gbm9wO1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgICAgIGZpcmU6IGRlZmF1bHRGdW5jdGlvbixcbiAgICAgICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc3Vic2NyaWJlcnMuaW5kZXhPZihjYikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNoYWluRnVuY3Rpb24oY29udGV4dC5maXJlLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzID0gY29udGV4dC5zdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbiAhPT0gY2I7IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNvbnRleHQuc3Vic2NyaWJlcnMucmVkdWNlKGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV2c1tldmVudE5hbWVdID0gcnZbZXZlbnROYW1lXSA9IGNvbnRleHQ7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRDb25maWd1cmVkRXZlbnRzKGNmZykge1xuICAgICAgICBrZXlzKGNmZykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGNmZ1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgICAgICAgICBhZGQoZXZlbnROYW1lLCBjZmdbZXZlbnROYW1lXVswXSwgY2ZnW2V2ZW50TmFtZV1bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJncyA9PT0gJ2FzYXAnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBhZGQoZXZlbnROYW1lLCBtaXJyb3IsIGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzYXAkMShmdW5jdGlvbiBmaXJlRXZlbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCBldmVudCBjb25maWdcIik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFrZUNsYXNzQ29uc3RydWN0b3IocHJvdG90eXBlLCBjb25zdHJ1Y3Rvcikge1xuICAgIGRlcml2ZShjb25zdHJ1Y3RvcikuZnJvbSh7IHByb3RvdHlwZSB9KTtcbiAgICByZXR1cm4gY29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlQ29uc3RydWN0b3IoZGIpIHtcbiAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVGFibGUucHJvdG90eXBlLCBmdW5jdGlvbiBUYWJsZShuYW1lLCB0YWJsZVNjaGVtYSwgdHJhbnMpIHtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICB0aGlzLl90eCA9IHRyYW5zO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHRhYmxlU2NoZW1hO1xuICAgICAgICB0aGlzLmhvb2sgPSBkYi5fYWxsVGFibGVzW25hbWVdID8gZGIuX2FsbFRhYmxlc1tuYW1lXS5ob29rIDogRXZlbnRzKG51bGwsIHtcbiAgICAgICAgICAgIFwiY3JlYXRpbmdcIjogW2hvb2tDcmVhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICAgICAgXCJyZWFkaW5nXCI6IFtwdXJlRnVuY3Rpb25DaGFpbiwgbWlycm9yXSxcbiAgICAgICAgICAgIFwidXBkYXRpbmdcIjogW2hvb2tVcGRhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICAgICAgXCJkZWxldGluZ1wiOiBbaG9va0RlbGV0aW5nQ2hhaW4sIG5vcF1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5LZXlSYW5nZShjdHgsIGlnbm9yZUxpbWl0RmlsdGVyKSB7XG4gICAgcmV0dXJuICEoY3R4LmZpbHRlciB8fCBjdHguYWxnb3JpdGhtIHx8IGN0eC5vcikgJiZcbiAgICAgICAgKGlnbm9yZUxpbWl0RmlsdGVyID8gY3R4Lmp1c3RMaW1pdCA6ICFjdHgucmVwbGF5RmlsdGVyKTtcbn1cbmZ1bmN0aW9uIGFkZEZpbHRlcihjdHgsIGZuKSB7XG4gICAgY3R4LmZpbHRlciA9IGNvbWJpbmUoY3R4LmZpbHRlciwgZm4pO1xufVxuZnVuY3Rpb24gYWRkUmVwbGF5RmlsdGVyKGN0eCwgZmFjdG9yeSwgaXNMaW1pdEZpbHRlcikge1xuICAgIHZhciBjdXJyID0gY3R4LnJlcGxheUZpbHRlcjtcbiAgICBjdHgucmVwbGF5RmlsdGVyID0gY3VyciA/ICgpID0+IGNvbWJpbmUoY3VycigpLCBmYWN0b3J5KCkpIDogZmFjdG9yeTtcbiAgICBjdHguanVzdExpbWl0ID0gaXNMaW1pdEZpbHRlciAmJiAhY3Vycjtcbn1cbmZ1bmN0aW9uIGFkZE1hdGNoRmlsdGVyKGN0eCwgZm4pIHtcbiAgICBjdHguaXNNYXRjaCA9IGNvbWJpbmUoY3R4LmlzTWF0Y2gsIGZuKTtcbn1cbmZ1bmN0aW9uIGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVTY2hlbWEpIHtcbiAgICBpZiAoY3R4LmlzUHJpbUtleSlcbiAgICAgICAgcmV0dXJuIGNvcmVTY2hlbWEucHJpbWFyeUtleTtcbiAgICBjb25zdCBpbmRleCA9IGNvcmVTY2hlbWEuZ2V0SW5kZXhCeUtleVBhdGgoY3R4LmluZGV4KTtcbiAgICBpZiAoIWluZGV4KVxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJLZXlQYXRoIFwiICsgY3R4LmluZGV4ICsgXCIgb24gb2JqZWN0IHN0b3JlIFwiICsgY29yZVNjaGVtYS5uYW1lICsgXCIgaXMgbm90IGluZGV4ZWRcIik7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gb3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgdHJhbnMpIHtcbiAgICBjb25zdCBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpO1xuICAgIHJldHVybiBjb3JlVGFibGUub3BlbkN1cnNvcih7XG4gICAgICAgIHRyYW5zLFxuICAgICAgICB2YWx1ZXM6ICFjdHgua2V5c09ubHksXG4gICAgICAgIHJldmVyc2U6IGN0eC5kaXIgPT09ICdwcmV2JyxcbiAgICAgICAgdW5pcXVlOiAhIWN0eC51bmlxdWUsXG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXRlcihjdHgsIGZuLCBjb3JlVHJhbnMsIGNvcmVUYWJsZSkge1xuICAgIGNvbnN0IGZpbHRlciA9IGN0eC5yZXBsYXlGaWx0ZXIgPyBjb21iaW5lKGN0eC5maWx0ZXIsIGN0eC5yZXBsYXlGaWx0ZXIoKSkgOiBjdHguZmlsdGVyO1xuICAgIGlmICghY3R4Lm9yKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIGNvcmVUcmFucyksIGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZmlsdGVyKSwgZm4sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHNldCA9IHt9O1xuICAgICAgICBjb25zdCB1bmlvbiA9IChpdGVtLCBjdXJzb3IsIGFkdmFuY2UpID0+IHtcbiAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihjdXJzb3IsIGFkdmFuY2UsIHJlc3VsdCA9PiBjdXJzb3Iuc3RvcChyZXN1bHQpLCBlcnIgPT4gY3Vyc29yLmZhaWwoZXJyKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSAnJyArIHByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJylcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gJycgKyBuZXcgVWludDhBcnJheShwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc093bihzZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0W2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBmbihpdGVtLCBjdXJzb3IsIGFkdmFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGN0eC5vci5faXRlcmF0ZSh1bmlvbiwgY29yZVRyYW5zKSxcbiAgICAgICAgICAgIGl0ZXJhdGUob3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSwgY3R4LmFsZ29yaXRobSwgdW5pb24sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKVxuICAgICAgICBdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpdGVyYXRlKGN1cnNvclByb21pc2UsIGZpbHRlciwgZm4sIHZhbHVlTWFwcGVyKSB7XG4gICAgdmFyIG1hcHBlZEZuID0gdmFsdWVNYXBwZXIgPyAoeCwgYywgYSkgPT4gZm4odmFsdWVNYXBwZXIoeCksIGMsIGEpIDogZm47XG4gICAgdmFyIHdyYXBwZWRGbiA9IHdyYXAobWFwcGVkRm4pO1xuICAgIHJldHVybiBjdXJzb3JQcm9taXNlLnRoZW4oY3Vyc29yID0+IHtcbiAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5zdGFydCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSAoKSA9PiBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoY3Vyc29yLCBhZHZhbmNlciA9PiBjID0gYWR2YW5jZXIsIHZhbCA9PiB7IGN1cnNvci5zdG9wKHZhbCk7IGMgPSBub3A7IH0sIGUgPT4geyBjdXJzb3IuZmFpbChlKTsgYyA9IG5vcDsgfSkpXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRGbihjdXJzb3IudmFsdWUsIGN1cnNvciwgYWR2YW5jZXIgPT4gYyA9IGFkdmFuY2VyKTtcbiAgICAgICAgICAgICAgICBjKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjbXAoYSwgYikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRhID0gdHlwZShhKTtcbiAgICAgICAgY29uc3QgdGIgPSB0eXBlKGIpO1xuICAgICAgICBpZiAodGEgIT09IHRiKSB7XG4gICAgICAgICAgICBpZiAodGEgPT09ICdBcnJheScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAodGIgPT09ICdBcnJheScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHRhID09PSAnYmluYXJ5JylcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmICh0YiA9PT0gJ2JpbmFyeScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHRhID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmICh0YiA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHRhID09PSAnRGF0ZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAodGIgIT09ICdEYXRlJylcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGEpIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICAgICAgICAgICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlVWludDhBcnJheXMoZ2V0VWludDhBcnJheShhKSwgZ2V0VWludDhBcnJheShiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVBcnJheXMoYSwgYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7IH1cbiAgICByZXR1cm4gTmFOO1xufVxuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgY29uc3QgYWwgPSBhLmxlbmd0aDtcbiAgICBjb25zdCBibCA9IGIubGVuZ3RoO1xuICAgIGNvbnN0IGwgPSBhbCA8IGJsID8gYWwgOiBibDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICBjb25zdCByZXMgPSBjbXAoYVtpXSwgYltpXSk7XG4gICAgICAgIGlmIChyZXMgIT09IDApXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gYWwgPT09IGJsID8gMCA6IGFsIDwgYmwgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBjb21wYXJlVWludDhBcnJheXMoYSwgYikge1xuICAgIGNvbnN0IGFsID0gYS5sZW5ndGg7XG4gICAgY29uc3QgYmwgPSBiLmxlbmd0aDtcbiAgICBjb25zdCBsID0gYWwgPCBibCA/IGFsIDogYmw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICByZXR1cm4gYVtpXSA8IGJbaV0gPyAtMSA6IDE7XG4gICAgfVxuICAgIHJldHVybiBhbCA9PT0gYmwgPyAwIDogYWwgPCBibCA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHR5cGUoeCkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgeDtcbiAgICBpZiAodCAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiB0O1xuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoeCkpXG4gICAgICAgIHJldHVybiAnYmluYXJ5JztcbiAgICBjb25zdCB0c1RhZyA9IHRvU3RyaW5nVGFnKHgpO1xuICAgIHJldHVybiB0c1RhZyA9PT0gJ0FycmF5QnVmZmVyJyA/ICdiaW5hcnknIDogdHNUYWc7XG59XG5mdW5jdGlvbiBnZXRVaW50OEFycmF5KGEpIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBhO1xuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkpXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhLmJ1ZmZlciwgYS5ieXRlT2Zmc2V0LCBhLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhKTtcbn1cblxuY2xhc3MgQ29sbGVjdGlvbiB7XG4gICAgX3JlYWQoZm4sIGNiKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIHJldHVybiBjdHguZXJyb3IgP1xuICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG4gICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkb25seScsIGZuKS50aGVuKGNiKTtcbiAgICB9XG4gICAgX3dyaXRlKGZuKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIHJldHVybiBjdHguZXJyb3IgP1xuICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG4gICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkd3JpdGUnLCBmbiwgXCJsb2NrZWRcIik7XG4gICAgfVxuICAgIF9hZGRBbGdvcml0aG0oZm4pIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgY3R4LmFsZ29yaXRobSA9IGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZm4pO1xuICAgIH1cbiAgICBfaXRlcmF0ZShmbiwgY29yZVRyYW5zKSB7XG4gICAgICAgIHJldHVybiBpdGVyKHRoaXMuX2N0eCwgZm4sIGNvcmVUcmFucywgdGhpcy5fY3R4LnRhYmxlLmNvcmUpO1xuICAgIH1cbiAgICBjbG9uZShwcm9wcykge1xuICAgICAgICB2YXIgcnYgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKSwgY3R4ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLl9jdHgpO1xuICAgICAgICBpZiAocHJvcHMpXG4gICAgICAgICAgICBleHRlbmQoY3R4LCBwcm9wcyk7XG4gICAgICAgIHJ2Ll9jdHggPSBjdHg7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgcmF3KCkge1xuICAgICAgICB0aGlzLl9jdHgudmFsdWVNYXBwZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZWFjaChmbikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZCh0cmFucyA9PiBpdGVyKGN0eCwgZm4sIHRyYW5zLCBjdHgudGFibGUuY29yZSkpO1xuICAgIH1cbiAgICBjb3VudChjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZCh0cmFucyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICBjb25zdCBjb3JlVGFibGUgPSBjdHgudGFibGUuY29yZTtcbiAgICAgICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlVGFibGUuY291bnQoe1xuICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oY291bnQgPT4gTWF0aC5taW4oY291bnQsIGN0eC5saW1pdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcihjdHgsICgpID0+IHsgKytjb3VudDsgcmV0dXJuIGZhbHNlOyB9LCB0cmFucywgY29yZVRhYmxlKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oY2IpO1xuICAgIH1cbiAgICBzb3J0Qnkoa2V5UGF0aCwgY2IpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBrZXlQYXRoLnNwbGl0KCcuJykucmV2ZXJzZSgpLCBsYXN0UGFydCA9IHBhcnRzWzBdLCBsYXN0SW5kZXggPSBwYXJ0cy5sZW5ndGggLSAxO1xuICAgICAgICBmdW5jdGlvbiBnZXR2YWwob2JqLCBpKSB7XG4gICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dmFsKG9ialtwYXJ0c1tpXV0sIGkgLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBvYmpbbGFzdFBhcnRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmRlciA9IHRoaXMuX2N0eC5kaXIgPT09IFwibmV4dFwiID8gMSA6IC0xO1xuICAgICAgICBmdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuICAgICAgICAgICAgdmFyIGFWYWwgPSBnZXR2YWwoYSwgbGFzdEluZGV4KSwgYlZhbCA9IGdldHZhbChiLCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGFWYWwgPCBiVmFsID8gLW9yZGVyIDogYVZhbCA+IGJWYWwgPyBvcmRlciA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEuc29ydChzb3J0ZXIpO1xuICAgICAgICB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgdG9BcnJheShjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZCh0cmFucyA9PiB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZU1hcHBlciB9ID0gY3R4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS50aGVuKCh7IHJlc3VsdCB9KSA9PiB2YWx1ZU1hcHBlciA/IHJlc3VsdC5tYXAodmFsdWVNYXBwZXIpIDogcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcihjdHgsIGl0ZW0gPT4gYS5wdXNoKGl0ZW0pLCB0cmFucywgY3R4LnRhYmxlLmNvcmUpLnRoZW4oKCkgPT4gYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNiKTtcbiAgICB9XG4gICAgb2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBpZiAob2Zmc2V0IDw9IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgY3R4Lm9mZnNldCArPSBvZmZzZXQ7XG4gICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4KSkge1xuICAgICAgICAgICAgYWRkUmVwbGF5RmlsdGVyKGN0eCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3Vyc29yLCBhZHZhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRMZWZ0ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRMZWZ0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLW9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShvZmZzZXRMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gKC0tb2Zmc2V0TGVmdCA8IDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxpbWl0KG51bVJvd3MpIHtcbiAgICAgICAgdGhpcy5fY3R4LmxpbWl0ID0gTWF0aC5taW4odGhpcy5fY3R4LmxpbWl0LCBudW1Sb3dzKTtcbiAgICAgICAgYWRkUmVwbGF5RmlsdGVyKHRoaXMuX2N0eCwgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIHJvd3NMZWZ0ID0gbnVtUm93cztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKC0tcm93c0xlZnQgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93c0xlZnQgPj0gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdW50aWwoZmlsdGVyRnVuY3Rpb24sIGJJbmNsdWRlU3RvcEVudHJ5KSB7XG4gICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJGdW5jdGlvbihjdXJzb3IudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYkluY2x1ZGVTdG9wRW50cnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaXJzdChjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5saW1pdCgxKS50b0FycmF5KGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgbGFzdChjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3QoY2IpO1xuICAgIH1cbiAgICBmaWx0ZXIoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRNYXRjaEZpbHRlcih0aGlzLl9jdHgsIGZpbHRlckZ1bmN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFuZChmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIG9yKGluZGV4TmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcy5fY3R4LnRhYmxlLCBpbmRleE5hbWUsIHRoaXMpO1xuICAgIH1cbiAgICByZXZlcnNlKCkge1xuICAgICAgICB0aGlzLl9jdHguZGlyID0gKHRoaXMuX2N0eC5kaXIgPT09IFwicHJldlwiID8gXCJuZXh0XCIgOiBcInByZXZcIik7XG4gICAgICAgIGlmICh0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSlcbiAgICAgICAgICAgIHRoaXMuX29uZGlyZWN0aW9uY2hhbmdlKHRoaXMuX2N0eC5kaXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBlYWNoS2V5KGNiKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLmtleSwgY3Vyc29yKTsgfSk7XG4gICAgfVxuICAgIGVhY2hVbmlxdWVLZXkoY2IpIHtcbiAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2hLZXkoY2IpO1xuICAgIH1cbiAgICBlYWNoUHJpbWFyeUtleShjYikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7IGNiKGN1cnNvci5wcmltYXJ5S2V5LCBjdXJzb3IpOyB9KTtcbiAgICB9XG4gICAga2V5cyhjYikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0sIGN1cnNvcikge1xuICAgICAgICAgICAgYS5wdXNoKGN1cnNvci5rZXkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgcHJpbWFyeUtleXMoY2IpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZCh0cmFucyA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS50aGVuKCh7IHJlc3VsdCB9KSA9PiByZXN1bHQpLnRoZW4oY2IpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaXRlbSwgY3Vyc29yKSB7XG4gICAgICAgICAgICBhLnB1c2goY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgdW5pcXVlS2V5cyhjYikge1xuICAgICAgICB0aGlzLl9jdHgudW5pcXVlID0gXCJ1bmlxdWVcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cyhjYik7XG4gICAgfVxuICAgIGZpcnN0S2V5KGNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLmtleXMoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICAgIH1cbiAgICBsYXN0S2V5KGNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maXJzdEtleShjYik7XG4gICAgfVxuICAgIGRpc3RpbmN0KCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LCBpZHggPSBjdHguaW5kZXggJiYgY3R4LnRhYmxlLnNjaGVtYS5pZHhCeU5hbWVbY3R4LmluZGV4XTtcbiAgICAgICAgaWYgKCFpZHggfHwgIWlkeC5tdWx0aSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB2YXIgc2V0ID0ge307XG4gICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgIHZhciBzdHJLZXkgPSBjdXJzb3IucHJpbWFyeUtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gaGFzT3duKHNldCwgc3RyS2V5KTtcbiAgICAgICAgICAgIHNldFtzdHJLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbW9kaWZ5KGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKHRyYW5zID0+IHtcbiAgICAgICAgICAgIHZhciBtb2RpZnllcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG1vZGlmeWVyID0gY2hhbmdlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBrZXlQYXRocyA9IGtleXMoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgdmFyIG51bUtleXMgPSBrZXlQYXRocy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbW9kaWZ5ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW55dGhpbmdNb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBrZXlQYXRoc1tpXSwgdmFsID0gY2hhbmdlc1trZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCkgIT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpdGVtLCBrZXlQYXRoLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueXRoaW5nTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbnl0aGluZ01vZGlmaWVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb3JlVGFibGUgPSBjdHgudGFibGUuY29yZTtcbiAgICAgICAgICAgIGNvbnN0IHsgb3V0Ym91bmQsIGV4dHJhY3RLZXkgfSA9IGNvcmVUYWJsZS5zY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5kYi5fb3B0aW9ucy5tb2RpZnlDaHVua1NpemUgfHwgMjAwO1xuICAgICAgICAgICAgY29uc3QgdG90YWxGYWlsdXJlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICAgICAgICBjb25zdCBmYWlsZWRLZXlzID0gW107XG4gICAgICAgICAgICBjb25zdCBhcHBseU11dGF0ZVJlc3VsdCA9IChleHBlY3RlZENvdW50LCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZhaWx1cmVzLCBudW1GYWlsdXJlcyB9ID0gcmVzO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCArPSBleHBlY3RlZENvdW50IC0gbnVtRmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIGtleXMoZmFpbHVyZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsRmFpbHVyZXMucHVzaChmYWlsdXJlc1twb3NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5wcmltYXJ5S2V5cygpLnRoZW4oa2V5cyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENodW5rID0gKG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKGxpbWl0LCBrZXlzLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlVGFibGUuZ2V0TWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGtleXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjb3VudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogXCJpbW11dGFibGVcIlxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKHZhbHVlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1dFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHV0S2V5cyA9IG91dGJvdW5kID8gW10gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlS2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRlZXBDbG9uZShvcmlnVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltS2V5OiBrZXlzW29mZnNldCArIGldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZ5ZXIuY2FsbChjdHgsIGN0eC52YWx1ZSwgY3R4KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eC52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW91dGJvdW5kICYmIGNtcChleHRyYWN0S2V5KG9yaWdWYWx1ZSksIGV4dHJhY3RLZXkoY3R4LnZhbHVlKSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFZhbHVlcy5wdXNoKGN0eC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRWYWx1ZXMucHVzaChjdHgudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dEtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNyaXRlcmlhID0gaXNQbGFpbktleVJhbmdlKGN0eCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGltaXQgPT09IEluZmluaXR5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nIHx8IGNoYW5nZXMgPT09IGRlbGV0ZUNhbGxiYWNrKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGN0eC5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhZGRWYWx1ZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2FkZCcsIHZhbHVlczogYWRkVmFsdWVzIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBpbiByZXMuZmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMuc3BsaWNlKHBhcnNlSW50KHBvcyksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5TXV0YXRlUmVzdWx0KGFkZFZhbHVlcy5sZW5ndGgsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKCkgPT4gKHB1dFZhbHVlcy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiB0eXBlb2YgY2hhbmdlcyA9PT0gJ29iamVjdCcpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHB1dEtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogcHV0VmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU3BlYzogdHlwZW9mIGNoYW5nZXMgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKHJlcyA9PiBhcHBseU11dGF0ZVJlc3VsdChwdXRWYWx1ZXMubGVuZ3RoLCByZXMpKSkudGhlbigoKSA9PiAoZGVsZXRlS2V5cy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiBjaGFuZ2VzID09PSBkZWxldGVDYWxsYmFjaykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZGVsZXRlS2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JpdGVyaWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKHJlcyA9PiBhcHBseU11dGF0ZVJlc3VsdChkZWxldGVLZXlzLmxlbmd0aCwgcmVzKSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aCA+IG9mZnNldCArIGNvdW50ICYmIG5leHRDaHVuayhvZmZzZXQgKyBsaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENodW5rKDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxGYWlsdXJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1vZGlmeUVycm9yKFwiRXJyb3IgbW9kaWZ5aW5nIG9uZSBvciBtb3JlIG9iamVjdHNcIiwgdG90YWxGYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHgsIHJhbmdlID0gY3R4LnJhbmdlO1xuICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCkgJiZcbiAgICAgICAgICAgICgoY3R4LmlzUHJpbUtleSAmJiAhaGFuZ3NPbkRlbGV0ZUxhcmdlS2V5UmFuZ2UpIHx8IHJhbmdlLnR5cGUgPT09IDMgKSlcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0ZSh0cmFucyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcmltYXJ5S2V5IH0gPSBjdHgudGFibGUuY29yZS5zY2hlbWE7XG4gICAgICAgICAgICAgICAgY29uc3QgY29yZVJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLmNvdW50KHsgdHJhbnMsIHF1ZXJ5OiB7IGluZGV4OiBwcmltYXJ5S2V5LCByYW5nZTogY29yZVJhbmdlIH0gfSkudGhlbihjb3VudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IGNvcmVSYW5nZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHsgZmFpbHVyZXMsIGxhc3RSZXN1bHQsIHJlc3VsdHMsIG51bUZhaWx1cmVzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJDb3VsZCBub3QgZGVsZXRlIHNvbWUgdmFsdWVzXCIsIE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAocG9zID0+IGZhaWx1cmVzW3Bvc10pLCBjb3VudCAtIG51bUZhaWx1cmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudCAtIG51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGlmeShkZWxldGVDYWxsYmFjayk7XG4gICAgfVxufVxuY29uc3QgZGVsZXRlQ2FsbGJhY2sgPSAodmFsdWUsIGN0eCkgPT4gY3R4LnZhbHVlID0gbnVsbDtcblxuZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9yKGRiKSB7XG4gICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKENvbGxlY3Rpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCBrZXlSYW5nZUdlbmVyYXRvcikge1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIGxldCBrZXlSYW5nZSA9IEFueVJhbmdlLCBlcnJvciA9IG51bGw7XG4gICAgICAgIGlmIChrZXlSYW5nZUdlbmVyYXRvcilcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAga2V5UmFuZ2UgPSBrZXlSYW5nZUdlbmVyYXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2hlcmVDdHggPSB3aGVyZUNsYXVzZS5fY3R4O1xuICAgICAgICBjb25zdCB0YWJsZSA9IHdoZXJlQ3R4LnRhYmxlO1xuICAgICAgICBjb25zdCByZWFkaW5nSG9vayA9IHRhYmxlLmhvb2sucmVhZGluZy5maXJlO1xuICAgICAgICB0aGlzLl9jdHggPSB7XG4gICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICBpbmRleDogd2hlcmVDdHguaW5kZXgsXG4gICAgICAgICAgICBpc1ByaW1LZXk6ICghd2hlcmVDdHguaW5kZXggfHwgKHRhYmxlLnNjaGVtYS5wcmltS2V5LmtleVBhdGggJiYgd2hlcmVDdHguaW5kZXggPT09IHRhYmxlLnNjaGVtYS5wcmltS2V5Lm5hbWUpKSxcbiAgICAgICAgICAgIHJhbmdlOiBrZXlSYW5nZSxcbiAgICAgICAgICAgIGtleXNPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgIGRpcjogXCJuZXh0XCIsXG4gICAgICAgICAgICB1bmlxdWU6IFwiXCIsXG4gICAgICAgICAgICBhbGdvcml0aG06IG51bGwsXG4gICAgICAgICAgICBmaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICByZXBsYXlGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICBqdXN0TGltaXQ6IHRydWUsXG4gICAgICAgICAgICBpc01hdGNoOiBudWxsLFxuICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgbGltaXQ6IEluZmluaXR5LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgb3I6IHdoZXJlQ3R4Lm9yLFxuICAgICAgICAgICAgdmFsdWVNYXBwZXI6IHJlYWRpbmdIb29rICE9PSBtaXJyb3IgPyByZWFkaW5nSG9vayA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlQ29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG59XG5mdW5jdGlvbiBzaW1wbGVDb21wYXJlUmV2ZXJzZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG59XG5cbmZ1bmN0aW9uIGZhaWwoY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UsIGVyciwgVCkge1xuICAgIHZhciBjb2xsZWN0aW9uID0gY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UgaW5zdGFuY2VvZiBXaGVyZUNsYXVzZSA/XG4gICAgICAgIG5ldyBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZS5Db2xsZWN0aW9uKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlKSA6XG4gICAgICAgIGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlO1xuICAgIGNvbGxlY3Rpb24uX2N0eC5lcnJvciA9IFQgPyBuZXcgVChlcnIpIDogbmV3IFR5cGVFcnJvcihlcnIpO1xuICAgIHJldHVybiBjb2xsZWN0aW9uO1xufVxuZnVuY3Rpb24gZW1wdHlDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlKSB7XG4gICAgcmV0dXJuIG5ldyB3aGVyZUNsYXVzZS5Db2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCAoKSA9PiByYW5nZUVxdWFsKFwiXCIpKS5saW1pdCgwKTtcbn1cbmZ1bmN0aW9uIHVwcGVyRmFjdG9yeShkaXIpIHtcbiAgICByZXR1cm4gZGlyID09PSBcIm5leHRcIiA/XG4gICAgICAgIChzKSA9PiBzLnRvVXBwZXJDYXNlKCkgOlxuICAgICAgICAocykgPT4gcy50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gbG93ZXJGYWN0b3J5KGRpcikge1xuICAgIHJldHVybiBkaXIgPT09IFwibmV4dFwiID9cbiAgICAgICAgKHMpID0+IHMudG9Mb3dlckNhc2UoKSA6XG4gICAgICAgIChzKSA9PiBzLnRvVXBwZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlLCBsb3dlck5lZWRsZSwgY21wLCBkaXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oa2V5Lmxlbmd0aCwgbG93ZXJOZWVkbGUubGVuZ3RoKTtcbiAgICB2YXIgbGxwID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbHdyS2V5Q2hhciA9IGxvd2VyS2V5W2ldO1xuICAgICAgICBpZiAobHdyS2V5Q2hhciAhPT0gbG93ZXJOZWVkbGVbaV0pIHtcbiAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCB1cHBlck5lZWRsZVtpXSkgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGkpICsgdXBwZXJOZWVkbGVbaV0gKyB1cHBlck5lZWRsZS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIGxvd2VyTmVlZGxlW2ldKSA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyBsb3dlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgICBpZiAobGxwID49IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyS2V5W2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21wKGtleVtpXSwgbHdyS2V5Q2hhcikgPCAwKVxuICAgICAgICAgICAgbGxwID0gaTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IGxvd2VyTmVlZGxlLmxlbmd0aCAmJiBkaXIgPT09IFwibmV4dFwiKVxuICAgICAgICByZXR1cm4ga2V5ICsgdXBwZXJOZWVkbGUuc3Vic3RyKGtleS5sZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPCBrZXkubGVuZ3RoICYmIGRpciA9PT0gXCJwcmV2XCIpXG4gICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIHVwcGVyTmVlZGxlLmxlbmd0aCk7XG4gICAgcmV0dXJuIChsbHAgPCAwID8gbnVsbCA6IGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyTmVlZGxlW2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSkpO1xufVxuZnVuY3Rpb24gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh3aGVyZUNsYXVzZSwgbWF0Y2gsIG5lZWRsZXMsIHN1ZmZpeCkge1xuICAgIHZhciB1cHBlciwgbG93ZXIsIGNvbXBhcmUsIHVwcGVyTmVlZGxlcywgbG93ZXJOZWVkbGVzLCBkaXJlY3Rpb24sIG5leHRLZXlTdWZmaXgsIG5lZWRsZXNMZW4gPSBuZWVkbGVzLmxlbmd0aDtcbiAgICBpZiAoIW5lZWRsZXMuZXZlcnkocyA9PiB0eXBlb2YgcyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybiBmYWlsKHdoZXJlQ2xhdXNlLCBTVFJJTkdfRVhQRUNURUQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0RGlyZWN0aW9uKGRpcikge1xuICAgICAgICB1cHBlciA9IHVwcGVyRmFjdG9yeShkaXIpO1xuICAgICAgICBsb3dlciA9IGxvd2VyRmFjdG9yeShkaXIpO1xuICAgICAgICBjb21wYXJlID0gKGRpciA9PT0gXCJuZXh0XCIgPyBzaW1wbGVDb21wYXJlIDogc2ltcGxlQ29tcGFyZVJldmVyc2UpO1xuICAgICAgICB2YXIgbmVlZGxlQm91bmRzID0gbmVlZGxlcy5tYXAoZnVuY3Rpb24gKG5lZWRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbG93ZXI6IGxvd2VyKG5lZWRsZSksIHVwcGVyOiB1cHBlcihuZWVkbGUpIH07XG4gICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKGEubG93ZXIsIGIubG93ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdXBwZXJOZWVkbGVzID0gbmVlZGxlQm91bmRzLm1hcChmdW5jdGlvbiAobmIpIHsgcmV0dXJuIG5iLnVwcGVyOyB9KTtcbiAgICAgICAgbG93ZXJOZWVkbGVzID0gbmVlZGxlQm91bmRzLm1hcChmdW5jdGlvbiAobmIpIHsgcmV0dXJuIG5iLmxvd2VyOyB9KTtcbiAgICAgICAgZGlyZWN0aW9uID0gZGlyO1xuICAgICAgICBuZXh0S2V5U3VmZml4ID0gKGRpciA9PT0gXCJuZXh0XCIgPyBcIlwiIDogc3VmZml4KTtcbiAgICB9XG4gICAgaW5pdERpcmVjdGlvbihcIm5leHRcIik7XG4gICAgdmFyIGMgPSBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwgKCkgPT4gY3JlYXRlUmFuZ2UodXBwZXJOZWVkbGVzWzBdLCBsb3dlck5lZWRsZXNbbmVlZGxlc0xlbiAtIDFdICsgc3VmZml4KSk7XG4gICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGluaXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICB9O1xuICAgIHZhciBmaXJzdFBvc3NpYmxlTmVlZGxlID0gMDtcbiAgICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgbG93ZXJLZXkgPSBsb3dlcihrZXkpO1xuICAgICAgICBpZiAobWF0Y2gobG93ZXJLZXksIGxvd2VyTmVlZGxlcywgZmlyc3RQb3NzaWJsZU5lZWRsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBmaXJzdFBvc3NpYmxlTmVlZGxlOyBpIDwgbmVlZGxlc0xlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhc2luZyA9IG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGVzW2ldLCBsb3dlck5lZWRsZXNbaV0sIGNvbXBhcmUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGNhc2luZyA9PT0gbnVsbCAmJiBsb3dlc3RQb3NzaWJsZUNhc2luZyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsIHx8IGNvbXBhcmUobG93ZXN0UG9zc2libGVDYXNpbmcsIGNhc2luZykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID0gY2FzaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb3dlc3RQb3NzaWJsZUNhc2luZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUobG93ZXN0UG9zc2libGVDYXNpbmcgKyBuZXh0S2V5U3VmZml4KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGM7XG59XG5mdW5jdGlvbiBjcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMiAsXG4gICAgICAgIGxvd2VyLFxuICAgICAgICB1cHBlcixcbiAgICAgICAgbG93ZXJPcGVuLFxuICAgICAgICB1cHBlck9wZW5cbiAgICB9O1xufVxuZnVuY3Rpb24gcmFuZ2VFcXVhbCh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDEgLFxuICAgICAgICBsb3dlcjogdmFsdWUsXG4gICAgICAgIHVwcGVyOiB2YWx1ZVxuICAgIH07XG59XG5cbmNsYXNzIFdoZXJlQ2xhdXNlIHtcbiAgICBnZXQgQ29sbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC50YWJsZS5kYi5Db2xsZWN0aW9uO1xuICAgIH1cbiAgICBiZXR3ZWVuKGxvd2VyLCB1cHBlciwgaW5jbHVkZUxvd2VyLCBpbmNsdWRlVXBwZXIpIHtcbiAgICAgICAgaW5jbHVkZUxvd2VyID0gaW5jbHVkZUxvd2VyICE9PSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZVVwcGVyID0gaW5jbHVkZVVwcGVyID09PSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA+IDApIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX2NtcChsb3dlciwgdXBwZXIpID09PSAwICYmIChpbmNsdWRlTG93ZXIgfHwgaW5jbHVkZVVwcGVyKSAmJiAhKGluY2x1ZGVMb3dlciAmJiBpbmNsdWRlVXBwZXIpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UobG93ZXIsIHVwcGVyLCAhaW5jbHVkZUxvd2VyLCAhaW5jbHVkZVVwcGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcXVhbHModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IHJhbmdlRXF1YWwodmFsdWUpKTtcbiAgICB9XG4gICAgYWJvdmUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHZhbHVlLCB1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG4gICAgYWJvdmVPckVxdWFsKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCBmYWxzZSkpO1xuICAgIH1cbiAgICBiZWxvdyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSwgZmFsc2UsIHRydWUpKTtcbiAgICB9XG4gICAgYmVsb3dPckVxdWFsKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh1bmRlZmluZWQsIHZhbHVlKSk7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGgoc3RyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFNUUklOR19FWFBFQ1RFRCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJldHdlZW4oc3RyLCBzdHIgKyBtYXhTdHJpbmcsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICBzdGFydHNXaXRoSWdub3JlQ2FzZShzdHIpIHtcbiAgICAgICAgaWYgKHN0ciA9PT0gXCJcIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0c1dpdGgoc3RyKTtcbiAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgKHgsIGEpID0+IHguaW5kZXhPZihhWzBdKSA9PT0gMCwgW3N0cl0sIG1heFN0cmluZyk7XG4gICAgfVxuICAgIGVxdWFsc0lnbm9yZUNhc2Uoc3RyKSB7XG4gICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiB4ID09PSBhWzBdLCBbc3RyXSwgXCJcIik7XG4gICAgfVxuICAgIGFueU9mSWdub3JlQ2FzZSgpIHtcbiAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCAoeCwgYSkgPT4gYS5pbmRleE9mKHgpICE9PSAtMSwgc2V0LCBcIlwiKTtcbiAgICB9XG4gICAgc3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSgpIHtcbiAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCAoeCwgYSkgPT4gYS5zb21lKG4gPT4geC5pbmRleE9mKG4pID09PSAwKSwgc2V0LCBtYXhTdHJpbmcpO1xuICAgIH1cbiAgICBhbnlPZigpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICBsZXQgY29tcGFyZSA9IHRoaXMuX2NtcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICBjb25zdCBjID0gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZShzZXRbMF0sIHNldFtzZXQubGVuZ3RoIC0gMV0pKTtcbiAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBkaXJlY3Rpb24gPT4ge1xuICAgICAgICAgICAgY29tcGFyZSA9IChkaXJlY3Rpb24gPT09IFwibmV4dFwiID9cbiAgICAgICAgICAgICAgICB0aGlzLl9hc2NlbmRpbmcgOlxuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc2NlbmRpbmcpO1xuICAgICAgICAgICAgc2V0LnNvcnQoY29tcGFyZSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgYy5fYWRkQWxnb3JpdGhtKChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShrZXksIHNldFtpXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGFyZShrZXksIHNldFtpXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoKCkgPT4geyBjdXJzb3IuY29udGludWUoc2V0W2ldKTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIG5vdEVxdWFsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2UoW1ttaW5LZXksIHZhbHVlXSwgW3ZhbHVlLCB0aGlzLmRiLl9tYXhLZXldXSwgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG4gICAgfVxuICAgIG5vbmVPZigpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2V0LnNvcnQodGhpcy5fYXNjZW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IHNldC5yZWR1Y2UoKHJlcywgdmFsKSA9PiByZXMgP1xuICAgICAgICAgICAgcmVzLmNvbmNhdChbW3Jlc1tyZXMubGVuZ3RoIC0gMV1bMV0sIHZhbF1dKSA6XG4gICAgICAgICAgICBbW21pbktleSwgdmFsXV0sIG51bGwpO1xuICAgICAgICByYW5nZXMucHVzaChbc2V0W3NldC5sZW5ndGggLSAxXSwgdGhpcy5kYi5fbWF4S2V5XSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2UocmFuZ2VzLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaW5BbnlSYW5nZShyYW5nZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY21wID0gdGhpcy5fY21wLCBhc2NlbmRpbmcgPSB0aGlzLl9hc2NlbmRpbmcsIGRlc2NlbmRpbmcgPSB0aGlzLl9kZXNjZW5kaW5nLCBtaW4gPSB0aGlzLl9taW4sIG1heCA9IHRoaXMuX21heDtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICBpZiAoIXJhbmdlcy5ldmVyeShyYW5nZSA9PiByYW5nZVswXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICByYW5nZVsxXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBhc2NlbmRpbmcocmFuZ2VbMF0sIHJhbmdlWzFdKSA8PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgXCJGaXJzdCBhcmd1bWVudCB0byBpbkFueVJhbmdlKCkgbXVzdCBiZSBhbiBBcnJheSBvZiB0d28tdmFsdWUgQXJyYXlzIFtsb3dlcix1cHBlcl0gd2hlcmUgdXBwZXIgbXVzdCBub3QgYmUgbG93ZXIgdGhhbiBsb3dlclwiLCBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5jbHVkZUxvd2VycyA9ICFvcHRpb25zIHx8IG9wdGlvbnMuaW5jbHVkZUxvd2VycyAhPT0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVVcHBlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZVVwcGVycyA9PT0gdHJ1ZTtcbiAgICAgICAgZnVuY3Rpb24gYWRkUmFuZ2UocmFuZ2VzLCBuZXdSYW5nZSkge1xuICAgICAgICAgICAgbGV0IGkgPSAwLCBsID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNtcChuZXdSYW5nZVswXSwgcmFuZ2VbMV0pIDwgMCAmJiBjbXAobmV3UmFuZ2VbMV0sIHJhbmdlWzBdKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMF0gPSBtaW4ocmFuZ2VbMF0sIG5ld1JhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0gPSBtYXgocmFuZ2VbMV0sIG5ld1JhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IGwpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3UmFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICAgICAgZnVuY3Rpb24gcmFuZ2VTb3J0ZXIoYSwgYikgeyByZXR1cm4gc29ydERpcmVjdGlvbihhWzBdLCBiWzBdKTsgfVxuICAgICAgICBsZXQgc2V0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2V0ID0gcmFuZ2VzLnJlZHVjZShhZGRSYW5nZSwgW10pO1xuICAgICAgICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZVBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGtleUlzQmV5b25kQ3VycmVudEVudHJ5ID0gaW5jbHVkZVVwcGVycyA/XG4gICAgICAgICAgICBrZXkgPT4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPiAwIDpcbiAgICAgICAgICAgIGtleSA9PiBhc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA+PSAwO1xuICAgICAgICBjb25zdCBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeSA9IGluY2x1ZGVMb3dlcnMgP1xuICAgICAgICAgICAga2V5ID0+IGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+IDAgOlxuICAgICAgICAgICAga2V5ID0+IGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+PSAwO1xuICAgICAgICBmdW5jdGlvbiBrZXlXaXRoaW5DdXJyZW50UmFuZ2Uoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gIWtleUlzQmV5b25kQ3VycmVudEVudHJ5KGtleSkgJiYgIWtleUlzQmVmb3JlQ3VycmVudEVudHJ5KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHNldFswXVswXSwgc2V0W3NldC5sZW5ndGggLSAxXVsxXSwgIWluY2x1ZGVMb3dlcnMsICFpbmNsdWRlVXBwZXJzKSk7XG4gICAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZGlyZWN0aW9uID0+IHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID0gZGVzY2VuZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgYy5fYWRkQWxnb3JpdGhtKChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgd2hpbGUgKGNoZWNrS2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICArK3JhbmdlUG9zO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZVBvcyA9PT0gc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jbXAoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA9PT0gMCB8fCB0aGlzLl9jbXAoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydERpcmVjdGlvbiA9PT0gYXNjZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHNldFtyYW5nZVBvc11bMF0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoc2V0W3JhbmdlUG9zXVsxXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGhBbnlPZigpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoIXNldC5ldmVyeShzID0+IHR5cGVvZiBzID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwic3RhcnRzV2l0aEFueU9mKCkgb25seSB3b3JrcyB3aXRoIHN0cmluZ3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKHNldC5tYXAoKHN0cikgPT4gW3N0ciwgc3RyICsgbWF4U3RyaW5nXSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3RvcihkYikge1xuICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihXaGVyZUNsYXVzZS5wcm90b3R5cGUsIGZ1bmN0aW9uIFdoZXJlQ2xhdXNlKHRhYmxlLCBpbmRleCwgb3JDb2xsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5fY3R4ID0ge1xuICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4ID09PSBcIjppZFwiID8gbnVsbCA6IGluZGV4LFxuICAgICAgICAgICAgb3I6IG9yQ29sbGVjdGlvblxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbmRleGVkREIgPSBkYi5fZGVwcy5pbmRleGVkREI7XG4gICAgICAgIGlmICghaW5kZXhlZERCKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuICAgICAgICB0aGlzLl9jbXAgPSB0aGlzLl9hc2NlbmRpbmcgPSBpbmRleGVkREIuY21wLmJpbmQoaW5kZXhlZERCKTtcbiAgICAgICAgdGhpcy5fZGVzY2VuZGluZyA9IChhLCBiKSA9PiBpbmRleGVkREIuY21wKGIsIGEpO1xuICAgICAgICB0aGlzLl9tYXggPSAoYSwgYikgPT4gaW5kZXhlZERCLmNtcChhLCBiKSA+IDAgPyBhIDogYjtcbiAgICAgICAgdGhpcy5fbWluID0gKGEsIGIpID0+IGluZGV4ZWREQi5jbXAoYSwgYikgPCAwID8gYSA6IGI7XG4gICAgICAgIHRoaXMuX0lEQktleVJhbmdlID0gZGIuX2RlcHMuSURCS2V5UmFuZ2U7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpIHtcbiAgICByZXR1cm4gd3JhcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmNvbnN0IERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FID0gJ3N0b3JhZ2VtdXRhdGVkJztcbmNvbnN0IFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSA9ICd4LXN0b3JhZ2VtdXRhdGVkLTEnO1xuY29uc3QgZ2xvYmFsRXZlbnRzID0gRXZlbnRzKG51bGwsIERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FKTtcblxuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIF9sb2NrKCkge1xuICAgICAgICBhc3NlcnQoIVBTRC5nbG9iYWwpO1xuICAgICAgICArK3RoaXMuX3JlY3Vsb2NrO1xuICAgICAgICBpZiAodGhpcy5fcmVjdWxvY2sgPT09IDEgJiYgIVBTRC5nbG9iYWwpXG4gICAgICAgICAgICBQU0QubG9ja093bmVyRm9yID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF91bmxvY2soKSB7XG4gICAgICAgIGFzc2VydCghUFNELmdsb2JhbCk7XG4gICAgICAgIGlmICgtLXRoaXMuX3JlY3Vsb2NrID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIVBTRC5nbG9iYWwpXG4gICAgICAgICAgICAgICAgUFNELmxvY2tPd25lckZvciA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fYmxvY2tlZEZ1bmNzLmxlbmd0aCA+IDAgJiYgIXRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuQW5kUFNEID0gdGhpcy5fYmxvY2tlZEZ1bmNzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdXNlUFNEKGZuQW5kUFNEWzFdLCBmbkFuZFBTRFswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2xvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Vsb2NrICYmIFBTRC5sb2NrT3duZXJGb3IgIT09IHRoaXM7XG4gICAgfVxuICAgIGNyZWF0ZShpZGJ0cmFucykge1xuICAgICAgICBpZiAoIXRoaXMubW9kZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjb25zdCBpZGJkYiA9IHRoaXMuZGIuaWRiZGI7XG4gICAgICAgIGNvbnN0IGRiT3BlbkVycm9yID0gdGhpcy5kYi5fc3RhdGUuZGJPcGVuRXJyb3I7XG4gICAgICAgIGFzc2VydCghdGhpcy5pZGJ0cmFucyk7XG4gICAgICAgIGlmICghaWRidHJhbnMgJiYgIWlkYmRiKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRiT3BlbkVycm9yICYmIGRiT3BlbkVycm9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiRGF0YWJhc2VDbG9zZWRFcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBcIk1pc3NpbmdBUElFcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKGRiT3BlbkVycm9yLm1lc3NhZ2UsIGRiT3BlbkVycm9yKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5PcGVuRmFpbGVkKGRiT3BlbkVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVHJhbnNhY3Rpb25JbmFjdGl2ZSgpO1xuICAgICAgICBhc3NlcnQodGhpcy5fY29tcGxldGlvbi5fc3RhdGUgPT09IG51bGwpO1xuICAgICAgICBpZGJ0cmFucyA9IHRoaXMuaWRidHJhbnMgPSBpZGJ0cmFucyB8fFxuICAgICAgICAgICAgKHRoaXMuZGIuY29yZVxuICAgICAgICAgICAgICAgID8gdGhpcy5kYi5jb3JlLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlLCB7IGR1cmFiaWxpdHk6IHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IH0pXG4gICAgICAgICAgICAgICAgOiBpZGJkYi50cmFuc2FjdGlvbih0aGlzLnN0b3JlTmFtZXMsIHRoaXMubW9kZSwgeyBkdXJhYmlsaXR5OiB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSB9KSk7XG4gICAgICAgIGlkYnRyYW5zLm9uZXJyb3IgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2KTtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChpZGJ0cmFucy5lcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZGJ0cmFucy5vbmFib3J0ID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSAmJiB0aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoaWRidHJhbnMuZXJyb3IpKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uKFwiYWJvcnRcIikuZmlyZShldik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZGJ0cmFucy5vbmNvbXBsZXRlID0gd3JhcCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgICAgICAgaWYgKCdtdXRhdGVkUGFydHMnIGluIGlkYnRyYW5zKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLmZpcmUoaWRidHJhbnNbXCJtdXRhdGVkUGFydHNcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9wcm9taXNlKG1vZGUsIGZuLCBiV3JpdGVMb2NrKSB7XG4gICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJyAmJiB0aGlzLm1vZGUgIT09ICdyZWFkd3JpdGUnKVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlRyYW5zYWN0aW9uIGlzIHJlYWRvbmx5XCIpKTtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuVHJhbnNhY3Rpb25JbmFjdGl2ZSgpKTtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tlZEZ1bmNzLnB1c2goWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UobW9kZSwgZm4sIGJXcml0ZUxvY2spLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgUFNEXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiV3JpdGVMb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwLmZpbmFsbHkoKCkgPT4gdGhpcy5fdW5sb2NrKCkpO1xuICAgICAgICAgICAgICAgIHAuX2xpYiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcbiAgICAgICAgICAgICAgICAgICAgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50Ll9yb290KCkgOiB0aGlzO1xuICAgIH1cbiAgICB3YWl0Rm9yKHByb21pc2VMaWtlKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdCgpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUocHJvbWlzZUxpa2UpO1xuICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0Zvcikge1xuICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IHJvb3QuX3dhaXRpbmdGb3IudGhlbigoKSA9PiBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBwcm9taXNlO1xuICAgICAgICAgICAgcm9vdC5fd2FpdGluZ1F1ZXVlID0gW107XG4gICAgICAgICAgICB2YXIgc3RvcmUgPSByb290LmlkYnRyYW5zLm9iamVjdFN0b3JlKHJvb3Quc3RvcmVOYW1lc1swXSk7XG4gICAgICAgICAgICAoZnVuY3Rpb24gc3BpbigpIHtcbiAgICAgICAgICAgICAgICArK3Jvb3QuX3NwaW5Db3VudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAocm9vdC5fd2FpdGluZ1F1ZXVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgKHJvb3QuX3dhaXRpbmdRdWV1ZS5zaGlmdCgpKSgpO1xuICAgICAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yKVxuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXQoLUluZmluaXR5KS5vbnN1Y2Nlc3MgPSBzcGluO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudFdhaXRQcm9taXNlID0gcm9vdC5fd2FpdGluZ0ZvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKHJlcyA9PiByb290Ll93YWl0aW5nUXVldWUucHVzaCh3cmFwKHJlc29sdmUuYmluZChudWxsLCByZXMpKSksIGVyciA9PiByb290Ll93YWl0aW5nUXVldWUucHVzaCh3cmFwKHJlamVjdC5iaW5kKG51bGwsIGVycikpKSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IgPT09IGN1cnJlbnRXYWl0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5pZGJ0cmFucylcbiAgICAgICAgICAgICAgICB0aGlzLmlkYnRyYW5zLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFibGUodGFibGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IG1lbW9pemVkVGFibGVzID0gKHRoaXMuX21lbW9pemVkVGFibGVzIHx8ICh0aGlzLl9tZW1vaXplZFRhYmxlcyA9IHt9KSk7XG4gICAgICAgIGlmIChoYXNPd24obWVtb2l6ZWRUYWJsZXMsIHRhYmxlTmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRUYWJsZXNbdGFibGVOYW1lXTtcbiAgICAgICAgY29uc3QgdGFibGVTY2hlbWEgPSB0aGlzLnNjaGVtYVt0YWJsZU5hbWVdO1xuICAgICAgICBpZiAoIXRhYmxlU2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25Cb3VuZFRhYmxlID0gbmV3IHRoaXMuZGIuVGFibGUodGFibGVOYW1lLCB0YWJsZVNjaGVtYSwgdGhpcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uQm91bmRUYWJsZS5jb3JlID0gdGhpcy5kYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV0gPSB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yKGRiKSB7XG4gICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSwgcGFyZW50KSB7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5zdG9yZU5hbWVzID0gc3RvcmVOYW1lcztcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBkYnNjaGVtYTtcbiAgICAgICAgdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgPSBjaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHk7XG4gICAgICAgIHRoaXMuaWRidHJhbnMgPSBudWxsO1xuICAgICAgICB0aGlzLm9uID0gRXZlbnRzKHRoaXMsIFwiY29tcGxldGVcIiwgXCJlcnJvclwiLCBcImFib3J0XCIpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlY3Vsb2NrID0gMDtcbiAgICAgICAgdGhpcy5fYmxvY2tlZEZ1bmNzID0gW107XG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2FpdGluZ1F1ZXVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3BpbkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fY29tcGxldGlvbiA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jb21wbGV0aW9uLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub24uY29tcGxldGUuZmlyZSgpO1xuICAgICAgICB9LCBlID0+IHtcbiAgICAgICAgICAgIHZhciB3YXNBY3RpdmUgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uLmVycm9yLmZpcmUoZSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3JlamVjdChlKSA6XG4gICAgICAgICAgICAgICAgd2FzQWN0aXZlICYmIHRoaXMuaWRidHJhbnMgJiYgdGhpcy5pZGJ0cmFucy5hYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4U3BlYyhuYW1lLCBrZXlQYXRoLCB1bmlxdWUsIG11bHRpLCBhdXRvLCBjb21wb3VuZCwgaXNQcmltS2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAga2V5UGF0aCxcbiAgICAgICAgdW5pcXVlLFxuICAgICAgICBtdWx0aSxcbiAgICAgICAgYXV0byxcbiAgICAgICAgY29tcG91bmQsXG4gICAgICAgIHNyYzogKHVuaXF1ZSAmJiAhaXNQcmltS2V5ID8gJyYnIDogJycpICsgKG11bHRpID8gJyonIDogJycpICsgKGF1dG8gPyBcIisrXCIgOiBcIlwiKSArIG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKVxuICAgIH07XG59XG5mdW5jdGlvbiBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aCkge1xuICAgIHJldHVybiB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgP1xuICAgICAgICBrZXlQYXRoIDpcbiAgICAgICAga2V5UGF0aCA/ICgnWycgKyBbXS5qb2luLmNhbGwoa2V5UGF0aCwgJysnKSArICddJykgOiBcIlwiO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUYWJsZVNjaGVtYShuYW1lLCBwcmltS2V5LCBpbmRleGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJpbUtleSxcbiAgICAgICAgaW5kZXhlcyxcbiAgICAgICAgbWFwcGVkQ2xhc3M6IG51bGwsXG4gICAgICAgIGlkeEJ5TmFtZTogYXJyYXlUb09iamVjdChpbmRleGVzLCBpbmRleCA9PiBbaW5kZXgubmFtZSwgaW5kZXhdKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNhZmFyaU11bHRpU3RvcmVGaXgoc3RvcmVOYW1lcykge1xuICAgIHJldHVybiBzdG9yZU5hbWVzLmxlbmd0aCA9PT0gMSA/IHN0b3JlTmFtZXNbMF0gOiBzdG9yZU5hbWVzO1xufVxubGV0IGdldE1heEtleSA9IChJZGJLZXlSYW5nZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIElkYktleVJhbmdlLm9ubHkoW1tdXSk7XG4gICAgICAgIGdldE1heEtleSA9ICgpID0+IFtbXV07XG4gICAgICAgIHJldHVybiBbW11dO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBnZXRNYXhLZXkgPSAoKSA9PiBtYXhTdHJpbmc7XG4gICAgICAgIHJldHVybiBtYXhTdHJpbmc7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpIHtcbiAgICBpZiAoa2V5UGF0aCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvcihrZXlQYXRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmogPT4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvcihrZXlQYXRoKSB7XG4gICAgY29uc3Qgc3BsaXQgPSBrZXlQYXRoLnNwbGl0KCcuJyk7XG4gICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gb2JqID0+IG9ialtrZXlQYXRoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmogPT4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcnJheWlmeShhcnJheUxpa2UpIHtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbChhcnJheUxpa2UpO1xufVxubGV0IF9pZF9jb3VudGVyID0gMDtcbmZ1bmN0aW9uIGdldEtleVBhdGhBbGlhcyhrZXlQYXRoKSB7XG4gICAgcmV0dXJuIGtleVBhdGggPT0gbnVsbCA/XG4gICAgICAgIFwiOmlkXCIgOlxuICAgICAgICB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAga2V5UGF0aCA6XG4gICAgICAgICAgICBgWyR7a2V5UGF0aC5qb2luKCcrJyl9XWA7XG59XG5mdW5jdGlvbiBjcmVhdGVEQkNvcmUoZGIsIElkYktleVJhbmdlLCB0bXBUcmFucykge1xuICAgIGZ1bmN0aW9uIGV4dHJhY3RTY2hlbWEoZGIsIHRyYW5zKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlcyA9IGFycmF5aWZ5KGRiLm9iamVjdFN0b3JlTmFtZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZGIubmFtZSxcbiAgICAgICAgICAgICAgICB0YWJsZXM6IHRhYmxlcy5tYXAodGFibGUgPT4gdHJhbnMub2JqZWN0U3RvcmUodGFibGUpKS5tYXAoc3RvcmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtleVBhdGgsIGF1dG9JbmNyZW1lbnQgfSA9IHN0b3JlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dGJvdW5kID0ga2V5UGF0aCA9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleEJ5S2V5UGF0aCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdG9yZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmltYXJ5S2V5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0luY3JlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlczogYXJyYXlpZnkoc3RvcmUuaW5kZXhOYW1lcykubWFwKGluZGV4TmFtZSA9PiBzdG9yZS5pbmRleChpbmRleE5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoaW5kZXggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgdW5pcXVlLCBtdWx0aUVudHJ5LCBrZXlQYXRoIH0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0S2V5OiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXhCeUtleVBhdGg6IChrZXlQYXRoKSA9PiBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW1wiOmlkXCJdID0gcmVzdWx0LnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV0gPSByZXN1bHQucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzR2V0QWxsOiB0YWJsZXMubGVuZ3RoID4gMCAmJiAoJ2dldEFsbCcgaW4gdHJhbnMub2JqZWN0U3RvcmUodGFibGVzWzBdKSkgJiZcbiAgICAgICAgICAgICAgICAhKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIS8oQ2hyb21lXFwvfEVkZ2VcXC8pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VJREJLZXlSYW5nZShyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gMyApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDQgKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgbmV2ZXIgdHlwZSB0byBJREJLZXlSYW5nZVwiKTtcbiAgICAgICAgY29uc3QgeyBsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuIH0gPSByYW5nZTtcbiAgICAgICAgY29uc3QgaWRiUmFuZ2UgPSBsb3dlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHVwcGVyID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgICAgIElkYktleVJhbmdlLnVwcGVyQm91bmQodXBwZXIsICEhdXBwZXJPcGVuKSA6XG4gICAgICAgICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS5sb3dlckJvdW5kKGxvd2VyLCAhIWxvd2VyT3BlbikgOlxuICAgICAgICAgICAgICAgIElkYktleVJhbmdlLmJvdW5kKGxvd2VyLCB1cHBlciwgISFsb3dlck9wZW4sICEhdXBwZXJPcGVuKTtcbiAgICAgICAgcmV0dXJuIGlkYlJhbmdlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVEYkNvcmVUYWJsZSh0YWJsZVNjaGVtYSkge1xuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZVNjaGVtYS5uYW1lO1xuICAgICAgICBmdW5jdGlvbiBtdXRhdGUoeyB0cmFucywgdHlwZSwga2V5cywgdmFsdWVzLCByYW5nZSB9KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRib3VuZCA9IHN0b3JlLmtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0FkZE9yUHV0ID0gdHlwZSA9PT0gXCJwdXRcIiB8fCB0eXBlID09PSBcImFkZFwiO1xuICAgICAgICAgICAgICAgIGlmICghaXNBZGRPclB1dCAmJiB0eXBlICE9PSAnZGVsZXRlJyAmJiB0eXBlICE9PSAnZGVsZXRlUmFuZ2UnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wZXJhdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBrZXlzIHx8IHZhbHVlcyB8fCB7IGxlbmd0aDogMSB9O1xuICAgICAgICAgICAgICAgIGlmIChrZXlzICYmIHZhbHVlcyAmJiBrZXlzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiBrZXlzIGFycmF5IG11c3QgaGF2ZSBzYW1lIGxlbmd0aCBhcyBnaXZlbiB2YWx1ZXMgYXJyYXkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IG51bUZhaWx1cmVzOiAwLCBmYWlsdXJlczoge30sIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlcTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXFzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgbnVtRmFpbHVyZXMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgKytudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBudW1GYWlsdXJlcywgZmFpbHVyZXMsIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSAzIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5jbGVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlLmRlbGV0ZShtYWtlSURCS2V5UmFuZ2UocmFuZ2UpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbYXJnczEsIGFyZ3MyXSA9IGlzQWRkT3JQdXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZXMsIGtleXNdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVzLCBudWxsXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBba2V5cywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FkZE9yUHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IChhcmdzMiAmJiBhcmdzMltpXSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbdHlwZV0oYXJnczFbaV0sIGFyZ3MyW2ldKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZVt0eXBlXShhcmdzMVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RSZXN1bHQgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICByZXFzLmZvckVhY2goKHJlcSwgaSkgPT4gcmVxLmVycm9yICE9IG51bGwgJiYgKGZhaWx1cmVzW2ldID0gcmVxLmVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtRmFpbHVyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IHR5cGUgPT09IFwiZGVsZXRlXCIgPyBrZXlzIDogcmVxcy5tYXAocmVxID0+IHJlcS5yZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBkb25lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb3BlbkN1cnNvcih7IHRyYW5zLCB2YWx1ZXMsIHF1ZXJ5LCByZXZlcnNlLCB1bmlxdWUgfSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGluZGV4LCByYW5nZSB9ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlIDpcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcmV2ZXJzZSA/XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcInByZXZ1bmlxdWVcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcInByZXZcIiA6XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5leHR1bmlxdWVcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5leHRcIjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXEgPSB2YWx1ZXMgfHwgISgnb3BlbktleUN1cnNvcicgaW4gc291cmNlKSA/XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5vcGVuQ3Vyc29yKG1ha2VJREJLZXlSYW5nZShyYW5nZSksIGRpcmVjdGlvbikgOlxuICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuX19faWQgPSArK19pZF9jb3VudGVyO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfY3Vyc29yQ29udGludWUgPSBjdXJzb3IuY29udGludWUuYmluZChjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkuYmluZChjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfY3Vyc29yQWR2YW5jZSA9IGN1cnNvci5hZHZhbmNlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZCA9ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIG5vdCBzdGFydGVkXCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb1Rocm93Q3Vyc29ySXNTdG9wcGVkID0gKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3Igbm90IHN0b3BwZWRcIik7IH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci50cmFucyA9IHRyYW5zO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCA9IGN1cnNvci5jb250aW51ZSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuYWR2YW5jZSA9IGRvVGhyb3dDdXJzb3JJc05vdFN0YXJ0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsID0gd3JhcChyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBnb3RPbmUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoKCkgPT4gZ290T25lLS0gPyB0aGlzLmNvbnRpbnVlKCkgOiB0aGlzLnN0b3AoKSkudGhlbigoKSA9PiB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0YXJ0ID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVyYXRpb25Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmVJdGVyYXRpb24sIHJlamVjdEl0ZXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24gPSB3cmFwKHJlc29sdmVJdGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdEl0ZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwgPSByZWplY3RJdGVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzU3RvcHBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUl0ZXJhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3VhcmRlZENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0YXJ0ID0gKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3IgYmVoaW5kIGxhc3QgZW50cnlcIik7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZ3VhcmRlZENhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUgPSBfY3Vyc29yQ29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlID0gX2N1cnNvckFkdmFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBndWFyZGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRpb25Qcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHF1ZXJ5KGhhc0dldEFsbCkge1xuICAgICAgICAgICAgcmV0dXJuIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnMsIHZhbHVlcywgbGltaXQsIHF1ZXJ5IH0gPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub25JbmZpbml0TGltaXQgPSBsaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBsaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpbmRleCwgcmFuZ2UgfSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkYktleVJhbmdlID0gbWFrZUlEQktleVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzR2V0QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXEgPSB2YWx1ZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5nZXRBbGwoaWRiS2V5UmFuZ2UsIG5vbkluZmluaXRMaW1pdCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5nZXRBbGxLZXlzKGlkYktleVJhbmdlLCBub25JbmZpbml0TGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50ID0+IHJlc29sdmUoeyByZXN1bHQ6IGV2ZW50LnRhcmdldC5yZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IHZhbHVlcyB8fCAhKCdvcGVuS2V5Q3Vyc29yJyBpbiBzb3VyY2UpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihpZGJLZXlSYW5nZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5vcGVuS2V5Q3Vyc29yKGlkYktleVJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZXMgPyBjdXJzb3IudmFsdWUgOiBjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGxpbWl0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZU5hbWUsXG4gICAgICAgICAgICBzY2hlbWE6IHRhYmxlU2NoZW1hLFxuICAgICAgICAgICAgbXV0YXRlLFxuICAgICAgICAgICAgZ2V0TWFueSh7IHRyYW5zLCBrZXlzIH0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXlDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjYWxsYmFja0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc0hhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXEgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdFtyZXEuX3Bvc10gPSByZXEucmVzdWx0KSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NhbGxiYWNrQ291bnQgPT09IGtleUNvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBzdG9yZS5nZXQoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLl9wb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBzdWNjZXNzSGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2tleUNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQoeyB0cmFucywga2V5IH0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXEgPSBzdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50ID0+IHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5KGhhc0dldEFsbCksXG4gICAgICAgICAgICBvcGVuQ3Vyc29yLFxuICAgICAgICAgICAgY291bnQoeyBxdWVyeSwgdHJhbnMgfSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIHJhbmdlIH0gPSBxdWVyeTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkYktleVJhbmdlID0gbWFrZUlEQktleVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxID0gaWRiS2V5UmFuZ2UgPyBzb3VyY2UuY291bnQoaWRiS2V5UmFuZ2UpIDogc291cmNlLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGV2ID0+IHJlc29sdmUoZXYudGFyZ2V0LnJlc3VsdCkpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IHNjaGVtYSwgaGFzR2V0QWxsIH0gPSBleHRyYWN0U2NoZW1hKGRiLCB0bXBUcmFucyk7XG4gICAgY29uc3QgdGFibGVzID0gc2NoZW1hLnRhYmxlcy5tYXAodGFibGVTY2hlbWEgPT4gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpKTtcbiAgICBjb25zdCB0YWJsZU1hcCA9IHt9O1xuICAgIHRhYmxlcy5mb3JFYWNoKHRhYmxlID0+IHRhYmxlTWFwW3RhYmxlLm5hbWVdID0gdGFibGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgICAgICB0cmFuc2FjdGlvbjogZGIudHJhbnNhY3Rpb24uYmluZChkYiksXG4gICAgICAgIHRhYmxlKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRhYmxlTWFwW25hbWVdO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWJsZSAnJHtuYW1lfScgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICByZXR1cm4gdGFibGVNYXBbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIE1JTl9LRVk6IC1JbmZpbml0eSxcbiAgICAgICAgTUFYX0tFWTogZ2V0TWF4S2V5KElkYktleVJhbmdlKSxcbiAgICAgICAgc2NoZW1hXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrKHN0YWNrSW1wbCwgbWlkZGxld2FyZXMpIHtcbiAgICByZXR1cm4gbWlkZGxld2FyZXMucmVkdWNlKChkb3duLCB7IGNyZWF0ZSB9KSA9PiAoeyAuLi5kb3duLCAuLi5jcmVhdGUoZG93bikgfSksIHN0YWNrSW1wbCk7XG59XG5mdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlU3RhY2tzKG1pZGRsZXdhcmVzLCBpZGJkYiwgeyBJREJLZXlSYW5nZSwgaW5kZXhlZERCIH0sIHRtcFRyYW5zKSB7XG4gICAgY29uc3QgZGJjb3JlID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrKGNyZWF0ZURCQ29yZShpZGJkYiwgSURCS2V5UmFuZ2UsIHRtcFRyYW5zKSwgbWlkZGxld2FyZXMuZGJjb3JlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYmNvcmVcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKHsgX25vdmlwOiBkYiB9LCB0bXBUcmFucykge1xuICAgIGNvbnN0IGlkYmRiID0gdG1wVHJhbnMuZGI7XG4gICAgY29uc3Qgc3RhY2tzID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhkYi5fbWlkZGxld2FyZXMsIGlkYmRiLCBkYi5fZGVwcywgdG1wVHJhbnMpO1xuICAgIGRiLmNvcmUgPSBzdGFja3MuZGJjb3JlO1xuICAgIGRiLnRhYmxlcy5mb3JFYWNoKHRhYmxlID0+IHtcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUubmFtZTtcbiAgICAgICAgaWYgKGRiLmNvcmUuc2NoZW1hLnRhYmxlcy5zb21lKHRibCA9PiB0YmwubmFtZSA9PT0gdGFibGVOYW1lKSkge1xuICAgICAgICAgICAgdGFibGUuY29yZSA9IGRiLmNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgIGlmIChkYlt0YWJsZU5hbWVdIGluc3RhbmNlb2YgZGIuVGFibGUpIHtcbiAgICAgICAgICAgICAgICBkYlt0YWJsZU5hbWVdLmNvcmUgPSB0YWJsZS5jb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldEFwaU9uUGxhY2UoeyBfbm92aXA6IGRiIH0sIG9ianMsIHRhYmxlTmFtZXMsIGRic2NoZW1hKSB7XG4gICAgdGFibGVOYW1lcy5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGRic2NoZW1hW3RhYmxlTmFtZV07XG4gICAgICAgIG9ianMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcERlc2MgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCB0YWJsZU5hbWUpO1xuICAgICAgICAgICAgaWYgKCFwcm9wRGVzYyB8fCAoXCJ2YWx1ZVwiIGluIHByb3BEZXNjICYmIHByb3BEZXNjLnZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlIHx8IG9iaiBpbnN0YW5jZW9mIGRiLlRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFByb3Aob2JqLCB0YWJsZU5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMudGFibGUodGFibGVOYW1lKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIHRhYmxlTmFtZSwgeyB2YWx1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmpbdGFibGVOYW1lXSA9IG5ldyBkYi5UYWJsZSh0YWJsZU5hbWUsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVRhYmxlc0FwaSh7IF9ub3ZpcDogZGIgfSwgb2Jqcykge1xuICAgIG9ianMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqW2tleV0gaW5zdGFuY2VvZiBkYi5UYWJsZSlcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGxvd2VyVmVyc2lvbkZpcnN0KGEsIGIpIHtcbiAgICByZXR1cm4gYS5fY2ZnLnZlcnNpb24gLSBiLl9jZmcudmVyc2lvbjtcbn1cbmZ1bmN0aW9uIHJ1blVwZ3JhZGVycyhkYiwgb2xkVmVyc2lvbiwgaWRiVXBncmFkZVRyYW5zLCByZWplY3QpIHtcbiAgICBjb25zdCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG4gICAgY29uc3QgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScsIGRiLl9zdG9yZU5hbWVzLCBnbG9iYWxTY2hlbWEpO1xuICAgIHRyYW5zLmNyZWF0ZShpZGJVcGdyYWRlVHJhbnMpO1xuICAgIHRyYW5zLl9jb21wbGV0aW9uLmNhdGNoKHJlamVjdCk7XG4gICAgY29uc3QgcmVqZWN0VHJhbnNhY3Rpb24gPSB0cmFucy5fcmVqZWN0LmJpbmQodHJhbnMpO1xuICAgIGNvbnN0IHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuICAgIG5ld1Njb3BlKCgpID0+IHtcbiAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgICAgIFBTRC50cmFuc2xlc3MgPSB0cmFuc2xlc3M7XG4gICAgICAgIGlmIChvbGRWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICBrZXlzKGdsb2JhbFNjaGVtYSkuZm9yRWFjaCh0YWJsZU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYlVwZ3JhZGVUcmFucywgdGFibGVOYW1lLCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5wcmltS2V5LCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5pbmRleGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgRGV4aWVQcm9taXNlLmZvbGxvdygoKSA9PiBkYi5vbi5wb3B1bGF0ZS5maXJlKHRyYW5zKSkuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoZGIsIG9sZFZlcnNpb24sIHRyYW5zLCBpZGJVcGdyYWRlVHJhbnMpLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoeyBfbm92aXA6IGRiIH0sIG9sZFZlcnNpb24sIHRyYW5zLCBpZGJVcGdyYWRlVHJhbnMpIHtcbiAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgIGNvbnN0IHZlcnNpb25zID0gZGIuX3ZlcnNpb25zO1xuICAgIGxldCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgbGV0IGFueUNvbnRlbnRVcGdyYWRlckhhc1J1biA9IGZhbHNlO1xuICAgIGNvbnN0IHZlcnNUb1J1biA9IHZlcnNpb25zLmZpbHRlcih2ID0+IHYuX2NmZy52ZXJzaW9uID49IG9sZFZlcnNpb24pO1xuICAgIHZlcnNUb1J1bi5mb3JFYWNoKHZlcnNpb24gPT4ge1xuICAgICAgICBxdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFNjaGVtYSA9IGdsb2JhbFNjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBvbGRTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgbmV3U2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gbmV3U2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpO1xuICAgICAgICAgICAgZGlmZi5hZGQuZm9yRWFjaCh0dXBsZSA9PiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0dXBsZVswXSwgdHVwbGVbMV0ucHJpbUtleSwgdHVwbGVbMV0uaW5kZXhlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpZmYuY2hhbmdlLmZvckVhY2goY2hhbmdlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnJlY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlVwZ3JhZGUoXCJOb3QgeWV0IHN1cHBvcnQgZm9yIGNoYW5naW5nIHByaW1hcnkga2V5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSBpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmUoY2hhbmdlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuYWRkLmZvckVhY2goaWR4ID0+IGFkZEluZGV4KHN0b3JlLCBpZHgpKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmNoYW5nZS5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5kZWxldGVJbmRleChpZHgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJbmRleChzdG9yZSwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kZWwuZm9yRWFjaChpZHhOYW1lID0+IHN0b3JlLmRlbGV0ZUluZGV4KGlkeE5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRVcGdyYWRlID0gdmVyc2lvbi5fY2ZnLmNvbnRlbnRVcGdyYWRlO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlICYmIHZlcnNpb24uX2NmZy52ZXJzaW9uID4gb2xkVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgICAgICAgICB0cmFucy5fbWVtb2l6ZWRUYWJsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBhbnlDb250ZW50VXBncmFkZXJIYXNSdW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCB1cGdyYWRlU2NoZW1hID0gc2hhbGxvd0Nsb25lKG5ld1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGlmZi5kZWwuZm9yRWFjaCh0YWJsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZ3JhZGVTY2hlbWFbdGFibGVdID0gb2xkU2NoZW1hW3RhYmxlXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSwga2V5cyh1cGdyYWRlU2NoZW1hKSwgdXBncmFkZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgdHJhbnMuc2NoZW1hID0gdXBncmFkZVNjaGVtYTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50VXBncmFkZUlzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24oY29udGVudFVwZ3JhZGUpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZUlzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VGb2xsb3dlZCA9IERleGllUHJvbWlzZS5mb2xsb3coKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGNvbnRlbnRVcGdyYWRlKHRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlbWVudG9yID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMuYmluZChudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpIDogcHJvbWlzZUZvbGxvd2VkLnRoZW4oKCkgPT4gcmV0dXJuVmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHF1ZXVlLnB1c2goaWRidHJhbnMgPT4ge1xuICAgICAgICAgICAgaWYgKCFhbnlDb250ZW50VXBncmFkZXJIYXNSdW4gfHwgIWhhc0lFRGVsZXRlT2JqZWN0U3RvcmVCdWcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTY2hlbWEgPSB2ZXJzaW9uLl9jZmcuZGJzY2hlbWE7XG4gICAgICAgICAgICAgICAgZGVsZXRlUmVtb3ZlZFRhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGRiLl9zdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuICAgICAgICAgICAgdHJhbnMuc2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBydW5RdWV1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlLmxlbmd0aCA/IERleGllUHJvbWlzZS5yZXNvbHZlKHF1ZXVlLnNoaWZ0KCkodHJhbnMuaWRidHJhbnMpKS50aGVuKHJ1blF1ZXVlKSA6XG4gICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcnVuUXVldWUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgY3JlYXRlTWlzc2luZ1RhYmxlcyhnbG9iYWxTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTY2hlbWFEaWZmKG9sZFNjaGVtYSwgbmV3U2NoZW1hKSB7XG4gICAgY29uc3QgZGlmZiA9IHtcbiAgICAgICAgZGVsOiBbXSxcbiAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgY2hhbmdlOiBbXVxuICAgIH07XG4gICAgbGV0IHRhYmxlO1xuICAgIGZvciAodGFibGUgaW4gb2xkU2NoZW1hKSB7XG4gICAgICAgIGlmICghbmV3U2NoZW1hW3RhYmxlXSlcbiAgICAgICAgICAgIGRpZmYuZGVsLnB1c2godGFibGUpO1xuICAgIH1cbiAgICBmb3IgKHRhYmxlIGluIG5ld1NjaGVtYSkge1xuICAgICAgICBjb25zdCBvbGREZWYgPSBvbGRTY2hlbWFbdGFibGVdLCBuZXdEZWYgPSBuZXdTY2hlbWFbdGFibGVdO1xuICAgICAgICBpZiAoIW9sZERlZikge1xuICAgICAgICAgICAgZGlmZi5hZGQucHVzaChbdGFibGUsIG5ld0RlZl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRhYmxlLFxuICAgICAgICAgICAgICAgIGRlZjogbmV3RGVmLFxuICAgICAgICAgICAgICAgIHJlY3JlYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZWw6IFtdLFxuICAgICAgICAgICAgICAgIGFkZDogW10sXG4gICAgICAgICAgICAgICAgY2hhbmdlOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgoXG4gICAgICAgICAgICAnJyArIChvbGREZWYucHJpbUtleS5rZXlQYXRoIHx8ICcnKSkgIT09ICgnJyArIChuZXdEZWYucHJpbUtleS5rZXlQYXRoIHx8ICcnKSkgfHxcbiAgICAgICAgICAgICAgICAob2xkRGVmLnByaW1LZXkuYXV0byAhPT0gbmV3RGVmLnByaW1LZXkuYXV0byAmJiAhaXNJRU9yRWRnZSkpXG4gICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNoYW5nZS5yZWNyZWF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkSW5kZXhlcyA9IG9sZERlZi5pZHhCeU5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IG5ld0RlZi5pZHhCeU5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IGlkeE5hbWU7XG4gICAgICAgICAgICAgICAgZm9yIChpZHhOYW1lIGluIG9sZEluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdJbmRleGVzW2lkeE5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRlbC5wdXNoKGlkeE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGlkeE5hbWUgaW4gbmV3SW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRJZHggPSBvbGRJbmRleGVzW2lkeE5hbWVdLCBuZXdJZHggPSBuZXdJbmRleGVzW2lkeE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZElkeClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5hZGQucHVzaChuZXdJZHgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRJZHguc3JjICE9PSBuZXdJZHguc3JjKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmNoYW5nZS5wdXNoKG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UuZGVsLmxlbmd0aCA+IDAgfHwgY2hhbmdlLmFkZC5sZW5ndGggPiAwIHx8IGNoYW5nZS5jaGFuZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmLmNoYW5nZS5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuICAgIGNvbnN0IHN0b3JlID0gaWRidHJhbnMuZGIuY3JlYXRlT2JqZWN0U3RvcmUodGFibGVOYW1lLCBwcmltS2V5LmtleVBhdGggP1xuICAgICAgICB7IGtleVBhdGg6IHByaW1LZXkua2V5UGF0aCwgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH0gOlxuICAgICAgICB7IGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9KTtcbiAgICBpbmRleGVzLmZvckVhY2goaWR4ID0+IGFkZEluZGV4KHN0b3JlLCBpZHgpKTtcbiAgICByZXR1cm4gc3RvcmU7XG59XG5mdW5jdGlvbiBjcmVhdGVNaXNzaW5nVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpIHtcbiAgICBrZXlzKG5ld1NjaGVtYSkuZm9yRWFjaCh0YWJsZU5hbWUgPT4ge1xuICAgICAgICBpZiAoIWlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGFibGVOYW1lKSkge1xuICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJlbW92ZWRUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucykge1xuICAgIFtdLnNsaWNlLmNhbGwoaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcykuZm9yRWFjaChzdG9yZU5hbWUgPT4gbmV3U2NoZW1hW3N0b3JlTmFtZV0gPT0gbnVsbCAmJiBpZGJ0cmFucy5kYi5kZWxldGVPYmplY3RTdG9yZShzdG9yZU5hbWUpKTtcbn1cbmZ1bmN0aW9uIGFkZEluZGV4KHN0b3JlLCBpZHgpIHtcbiAgICBzdG9yZS5jcmVhdGVJbmRleChpZHgubmFtZSwgaWR4LmtleVBhdGgsIHsgdW5pcXVlOiBpZHgudW5pcXVlLCBtdWx0aUVudHJ5OiBpZHgubXVsdGkgfSk7XG59XG5mdW5jdGlvbiBidWlsZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKSB7XG4gICAgY29uc3QgZ2xvYmFsU2NoZW1hID0ge307XG4gICAgY29uc3QgZGJTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG4gICAgZGJTdG9yZU5hbWVzLmZvckVhY2goc3RvcmVOYW1lID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0bXBUcmFucy5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICBsZXQga2V5UGF0aCA9IHN0b3JlLmtleVBhdGg7XG4gICAgICAgIGNvbnN0IHByaW1LZXkgPSBjcmVhdGVJbmRleFNwZWMobmFtZUZyb21LZXlQYXRoKGtleVBhdGgpLCBrZXlQYXRoIHx8IFwiXCIsIGZhbHNlLCBmYWxzZSwgISFzdG9yZS5hdXRvSW5jcmVtZW50LCBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IGlkYmluZGV4ID0gc3RvcmUuaW5kZXgoc3RvcmUuaW5kZXhOYW1lc1tqXSk7XG4gICAgICAgICAgICBrZXlQYXRoID0gaWRiaW5kZXgua2V5UGF0aDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGNyZWF0ZUluZGV4U3BlYyhpZGJpbmRleC5uYW1lLCBrZXlQYXRoLCAhIWlkYmluZGV4LnVuaXF1ZSwgISFpZGJpbmRleC5tdWx0aUVudHJ5LCBmYWxzZSwga2V5UGF0aCAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gXCJzdHJpbmdcIiwgZmFsc2UpO1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxTY2hlbWFbc3RvcmVOYW1lXSA9IGNyZWF0ZVRhYmxlU2NoZW1hKHN0b3JlTmFtZSwgcHJpbUtleSwgaW5kZXhlcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdsb2JhbFNjaGVtYTtcbn1cbmZ1bmN0aW9uIHJlYWRHbG9iYWxTY2hlbWEoeyBfbm92aXA6IGRiIH0sIGlkYmRiLCB0bXBUcmFucykge1xuICAgIGRiLnZlcm5vID0gaWRiZGIudmVyc2lvbiAvIDEwO1xuICAgIGNvbnN0IGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuICAgIGRiLl9zdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG4gICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLl9hbGxUYWJsZXNdLCBrZXlzKGdsb2JhbFNjaGVtYSksIGdsb2JhbFNjaGVtYSk7XG59XG5mdW5jdGlvbiB2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGIsIHRtcFRyYW5zKSB7XG4gICAgY29uc3QgaW5zdGFsbGVkU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCB0bXBUcmFucyk7XG4gICAgY29uc3QgZGlmZiA9IGdldFNjaGVtYURpZmYoaW5zdGFsbGVkU2NoZW1hLCBkYi5fZGJTY2hlbWEpO1xuICAgIHJldHVybiAhKGRpZmYuYWRkLmxlbmd0aCB8fCBkaWZmLmNoYW5nZS5zb21lKGNoID0+IGNoLmFkZC5sZW5ndGggfHwgY2guY2hhbmdlLmxlbmd0aCkpO1xufVxuZnVuY3Rpb24gYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoeyBfbm92aXA6IGRiIH0sIHNjaGVtYSwgaWRidHJhbnMpIHtcbiAgICBjb25zdCBzdG9yZU5hbWVzID0gaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3JlTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVOYW1lID0gc3RvcmVOYW1lc1tpXTtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBpZGJ0cmFucy5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICBkYi5faGFzR2V0QWxsID0gJ2dldEFsbCcgaW4gc3RvcmU7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RvcmUuaW5kZXhOYW1lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhOYW1lID0gc3RvcmUuaW5kZXhOYW1lc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IGtleVBhdGggPSBzdG9yZS5pbmRleChpbmRleE5hbWUpLmtleVBhdGg7XG4gICAgICAgICAgICBjb25zdCBkZXhpZU5hbWUgPSB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyBrZXlQYXRoIDogXCJbXCIgKyBzbGljZShrZXlQYXRoKS5qb2luKCcrJykgKyBcIl1cIjtcbiAgICAgICAgICAgIGlmIChzY2hlbWFbc3RvcmVOYW1lXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4U3BlYyA9IHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtkZXhpZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleFNwZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhTcGVjLm5hbWUgPSBpbmRleE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2luZGV4TmFtZV0gPSBpbmRleFNwZWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICEvKENocm9tZVxcL3xFZGdlXFwvKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmIF9nbG9iYWwgaW5zdGFuY2VvZiBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmXG4gICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpIHtcbiAgICAgICAgZGIuX2hhc0dldEFsbCA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW5kZXhTeW50YXgocHJpbUtleUFuZEluZGV4ZXMpIHtcbiAgICByZXR1cm4gcHJpbUtleUFuZEluZGV4ZXMuc3BsaXQoJywnKS5tYXAoKGluZGV4LCBpbmRleE51bSkgPT4ge1xuICAgICAgICBpbmRleCA9IGluZGV4LnRyaW0oKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGluZGV4LnJlcGxhY2UoLyhbJipdfFxcK1xcKykvZywgXCJcIik7XG4gICAgICAgIGNvbnN0IGtleVBhdGggPSAvXlxcWy8udGVzdChuYW1lKSA/IG5hbWUubWF0Y2goL15cXFsoLiopXFxdJC8pWzFdLnNwbGl0KCcrJykgOiBuYW1lO1xuICAgICAgICByZXR1cm4gY3JlYXRlSW5kZXhTcGVjKG5hbWUsIGtleVBhdGggfHwgbnVsbCwgL1xcJi8udGVzdChpbmRleCksIC9cXCovLnRlc3QoaW5kZXgpLCAvXFwrXFwrLy50ZXN0KGluZGV4KSwgaXNBcnJheShrZXlQYXRoKSwgaW5kZXhOdW0gPT09IDApO1xuICAgIH0pO1xufVxuXG5jbGFzcyBWZXJzaW9uIHtcbiAgICBfcGFyc2VTdG9yZXNTcGVjKHN0b3Jlcywgb3V0U2NoZW1hKSB7XG4gICAgICAgIGtleXMoc3RvcmVzKS5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RvcmVzW3RhYmxlTmFtZV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IHBhcnNlSW5kZXhTeW50YXgoc3RvcmVzW3RhYmxlTmFtZV0pO1xuICAgICAgICAgICAgICAgIHZhciBwcmltS2V5ID0gaW5kZXhlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmltS2V5Lm11bHRpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJQcmltYXJ5IGtleSBjYW5ub3QgYmUgbXVsdGktdmFsdWVkXCIpO1xuICAgICAgICAgICAgICAgIGluZGV4ZXMuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4LmF1dG8pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJPbmx5IHByaW1hcnkga2V5IGNhbiBiZSBtYXJrZWQgYXMgYXV0b0luY3JlbWVudCAoKyspXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlkeC5rZXlQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiSW5kZXggbXVzdCBoYXZlIGEgbmFtZSBhbmQgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvdXRTY2hlbWFbdGFibGVOYW1lXSA9IGNyZWF0ZVRhYmxlU2NoZW1hKHRhYmxlTmFtZSwgcHJpbUtleSwgaW5kZXhlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9yZXMoc3RvcmVzKSB7XG4gICAgICAgIGNvbnN0IGRiID0gdGhpcy5kYjtcbiAgICAgICAgdGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSA9IHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgP1xuICAgICAgICAgICAgZXh0ZW5kKHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UsIHN0b3JlcykgOlxuICAgICAgICAgICAgc3RvcmVzO1xuICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IGRiLl92ZXJzaW9ucztcbiAgICAgICAgY29uc3Qgc3RvcmVzU3BlYyA9IHt9O1xuICAgICAgICBsZXQgZGJzY2hlbWEgPSB7fTtcbiAgICAgICAgdmVyc2lvbnMuZm9yRWFjaCh2ZXJzaW9uID0+IHtcbiAgICAgICAgICAgIGV4dGVuZChzdG9yZXNTcGVjLCB2ZXJzaW9uLl9jZmcuc3RvcmVzU291cmNlKTtcbiAgICAgICAgICAgIGRic2NoZW1hID0gKHZlcnNpb24uX2NmZy5kYnNjaGVtYSA9IHt9KTtcbiAgICAgICAgICAgIHZlcnNpb24uX3BhcnNlU3RvcmVzU3BlYyhzdG9yZXNTcGVjLCBkYnNjaGVtYSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkYi5fZGJTY2hlbWEgPSBkYnNjaGVtYTtcbiAgICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSwgdGhpcy5fY2ZnLnRhYmxlc10sIGtleXMoZGJzY2hlbWEpLCBkYnNjaGVtYSk7XG4gICAgICAgIGRiLl9zdG9yZU5hbWVzID0ga2V5cyhkYnNjaGVtYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGdyYWRlKHVwZ3JhZGVGdW5jdGlvbikge1xuICAgICAgICB0aGlzLl9jZmcuY29udGVudFVwZ3JhZGUgPSBwcm9taXNhYmxlQ2hhaW4odGhpcy5fY2ZnLmNvbnRlbnRVcGdyYWRlIHx8IG5vcCwgdXBncmFkZUZ1bmN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IoZGIpIHtcbiAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVmVyc2lvbi5wcm90b3R5cGUsIGZ1bmN0aW9uIFZlcnNpb24odmVyc2lvbk51bWJlcikge1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMuX2NmZyA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25OdW1iZXIsXG4gICAgICAgICAgICBzdG9yZXNTb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBkYnNjaGVtYToge30sXG4gICAgICAgICAgICB0YWJsZXM6IHt9LFxuICAgICAgICAgICAgY29udGVudFVwZ3JhZGU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpIHtcbiAgICBsZXQgZGJOYW1lc0RCID0gaW5kZXhlZERCW1wiX2RiTmFtZXNEQlwiXTtcbiAgICBpZiAoIWRiTmFtZXNEQikge1xuICAgICAgICBkYk5hbWVzREIgPSBpbmRleGVkREJbXCJfZGJOYW1lc0RCXCJdID0gbmV3IERleGllJDEoREJOQU1FU19EQiwge1xuICAgICAgICAgICAgYWRkb25zOiBbXSxcbiAgICAgICAgICAgIGluZGV4ZWREQixcbiAgICAgICAgICAgIElEQktleVJhbmdlLFxuICAgICAgICB9KTtcbiAgICAgICAgZGJOYW1lc0RCLnZlcnNpb24oMSkuc3RvcmVzKHsgZGJuYW1lczogXCJuYW1lXCIgfSk7XG4gICAgfVxuICAgIHJldHVybiBkYk5hbWVzREIudGFibGUoXCJkYm5hbWVzXCIpO1xufVxuZnVuY3Rpb24gaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikge1xuICAgIHJldHVybiBpbmRleGVkREIgJiYgdHlwZW9mIGluZGV4ZWREQi5kYXRhYmFzZXMgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGdldERhdGFiYXNlTmFtZXMoeyBpbmRleGVkREIsIElEQktleVJhbmdlLCB9KSB7XG4gICAgcmV0dXJuIGhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpXG4gICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKGluZGV4ZWREQi5kYXRhYmFzZXMoKSkudGhlbigoaW5mb3MpID0+IGluZm9zXG4gICAgICAgICAgICAubWFwKChpbmZvKSA9PiBpbmZvLm5hbWUpXG4gICAgICAgICAgICAuZmlsdGVyKChuYW1lKSA9PiBuYW1lICE9PSBEQk5BTUVTX0RCKSlcbiAgICAgICAgOiBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkudG9Db2xsZWN0aW9uKCkucHJpbWFyeUtleXMoKTtcbn1cbmZ1bmN0aW9uIF9vbkRhdGFiYXNlQ3JlYXRlZCh7IGluZGV4ZWREQiwgSURCS2V5UmFuZ2UgfSwgbmFtZSkge1xuICAgICFoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSAmJlxuICAgICAgICBuYW1lICE9PSBEQk5BTUVTX0RCICYmXG4gICAgICAgIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS5wdXQoeyBuYW1lIH0pLmNhdGNoKG5vcCk7XG59XG5mdW5jdGlvbiBfb25EYXRhYmFzZURlbGV0ZWQoeyBpbmRleGVkREIsIElEQktleVJhbmdlIH0sIG5hbWUpIHtcbiAgICAhaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikgJiZcbiAgICAgICAgbmFtZSAhPT0gREJOQU1FU19EQiAmJlxuICAgICAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkuZGVsZXRlKG5hbWUpLmNhdGNoKG5vcCk7XG59XG5cbmZ1bmN0aW9uIHZpcChmbikge1xuICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIFBTRC5sZXRUaHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGlkYlJlYWR5KCkge1xuICAgIHZhciBpc1NhZmFyaSA9ICFuYXZpZ2F0b3IudXNlckFnZW50RGF0YSAmJlxuICAgICAgICAvU2FmYXJpXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICEvQ2hyb20oZXxpdW0pXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmICghaXNTYWZhcmkgfHwgIWluZGV4ZWREQi5kYXRhYmFzZXMpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgaW50ZXJ2YWxJZDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHRyeUlkYiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4ZWREQi5kYXRhYmFzZXMoKS5maW5hbGx5KHJlc29sdmUpOyB9O1xuICAgICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodHJ5SWRiLCAxMDApO1xuICAgICAgICB0cnlJZGIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7IH0pO1xufVxuXG5mdW5jdGlvbiBkZXhpZU9wZW4oZGIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGRiLl9zdGF0ZTtcbiAgICBjb25zdCB7IGluZGV4ZWREQiB9ID0gZGIuX2RlcHM7XG4gICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQgfHwgZGIuaWRiZGIpXG4gICAgICAgIHJldHVybiBzdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKCgpID0+IHN0YXRlLmRiT3BlbkVycm9yID9cbiAgICAgICAgICAgIHJlamVjdGlvbihzdGF0ZS5kYk9wZW5FcnJvcikgOlxuICAgICAgICAgICAgZGIpO1xuICAgIGRlYnVnICYmIChzdGF0ZS5vcGVuQ2FuY2VsbGVyLl9zdGFja0hvbGRlciA9IGdldEVycm9yV2l0aFN0YWNrKCkpO1xuICAgIHN0YXRlLmlzQmVpbmdPcGVuZWQgPSB0cnVlO1xuICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbnVsbDtcbiAgICBzdGF0ZS5vcGVuQ29tcGxldGUgPSBmYWxzZTtcbiAgICBjb25zdCBvcGVuQ2FuY2VsbGVyID0gc3RhdGUub3BlbkNhbmNlbGxlcjtcbiAgICBmdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGVkKCkge1xuICAgICAgICBpZiAoc3RhdGUub3BlbkNhbmNlbGxlciAhPT0gb3BlbkNhbmNlbGxlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCdkYi5vcGVuKCkgd2FzIGNhbmNlbGxlZCcpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZURiUmVhZHkgPSBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSxcbiAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsLCB3YXNDcmVhdGVkID0gZmFsc2U7XG4gICAgY29uc3QgdHJ5T3BlbkRCID0gKCkgPT4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAgICAgaWYgKCFpbmRleGVkREIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG4gICAgICAgIGNvbnN0IGRiTmFtZSA9IGRiLm5hbWU7XG4gICAgICAgIGNvbnN0IHJlcSA9IHN0YXRlLmF1dG9TY2hlbWEgP1xuICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lKSA6XG4gICAgICAgICAgICBpbmRleGVkREIub3BlbihkYk5hbWUsIE1hdGgucm91bmQoZGIudmVybm8gKiAxMCkpO1xuICAgICAgICBpZiAoIXJlcSlcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgcmVxLm9uYmxvY2tlZCA9IHdyYXAoZGIuX2ZpcmVPbkJsb2NrZWQpO1xuICAgICAgICByZXEub251cGdyYWRlbmVlZGVkID0gd3JhcChlID0+IHtcbiAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IHJlcS50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hICYmICFkYi5fb3B0aW9ucy5hbGxvd0VtcHR5REIpIHtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IHByZXZlbnREZWZhdWx0O1xuICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHJlcS5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxyZXEgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTtcbiAgICAgICAgICAgICAgICBkZWxyZXEub25zdWNjZXNzID0gZGVscmVxLm9uZXJyb3IgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBleGNlcHRpb25zLk5vU3VjaERhdGFiYXNlKGBEYXRhYmFzZSAke2RiTmFtZX0gZG9lc250IGV4aXN0YCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmVyID0gZS5vbGRWZXJzaW9uID4gTWF0aC5wb3coMiwgNjIpID8gMCA6IGUub2xkVmVyc2lvbjtcbiAgICAgICAgICAgICAgICB3YXNDcmVhdGVkID0gb2xkVmVyIDwgMTtcbiAgICAgICAgICAgICAgICBkYi5fbm92aXAuaWRiZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgIHJ1blVwZ3JhZGVycyhkYiwgb2xkVmVyIC8gMTAsIHVwZ3JhZGVUcmFuc2FjdGlvbiwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoKCkgPT4ge1xuICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGlkYmRiID0gZGIuX25vdmlwLmlkYmRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzKTtcbiAgICAgICAgICAgIGlmIChvYmplY3RTdG9yZU5hbWVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wVHJhbnMgPSBpZGJkYi50cmFuc2FjdGlvbihzYWZhcmlNdWx0aVN0b3JlRml4KG9iamVjdFN0b3JlTmFtZXMpLCAncmVhZG9ubHknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBkYi5fZGJTY2hlbWEsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmVyaWZ5SW5zdGFsbGVkU2NoZW1hKGRiLCB0bXBUcmFucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYERleGllIFNjaGVtYURpZmY6IFNjaGVtYSB3YXMgZXh0ZW5kZWQgd2l0aG91dCBpbmNyZWFzaW5nIHRoZSBudW1iZXIgcGFzc2VkIHRvIGRiLnZlcnNpb24oKS4gU29tZSBxdWVyaWVzIG1heSBmYWlsLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgdG1wVHJhbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goZGIpO1xuICAgICAgICAgICAgaWRiZGIub252ZXJzaW9uY2hhbmdlID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmNGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZGJkYi5vbmNsb3NlID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICAgICAgZGIub24oXCJjbG9zZVwiKS5maXJlKGV2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHdhc0NyZWF0ZWQpXG4gICAgICAgICAgICAgICAgX29uRGF0YWJhc2VDcmVhdGVkKGRiLl9kZXBzLCBkYk5hbWUpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLm5hbWUgPT09ICdVbmtub3duRXJyb3InICYmIHN0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuICAgICAgICAgICAgc3RhdGUuUFIxMzk4X21heExvb3AtLTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IFdvcmthcm91bmQgZm9yIENocm9tZSBVbmtub3duRXJyb3Igb24gb3BlbigpJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ5T3BlbkRCKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIERleGllUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgb3BlbkNhbmNlbGxlcixcbiAgICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gRGV4aWVQcm9taXNlLnJlc29sdmUoKSA6IGlkYlJlYWR5KCkpLnRoZW4odHJ5T3BlbkRCKVxuICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKCk7XG4gICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG4gICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSh2aXAoKCkgPT4gZGIub24ucmVhZHkuZmlyZShkYi52aXApKSkudGhlbihmdW5jdGlvbiBmaXJlUmVtYWluZGVycygpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlbWFpbmRlcnMgPSBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5yZWR1Y2UocHJvbWlzYWJsZUNoYWluLCBub3ApO1xuICAgICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHZpcCgoKSA9PiByZW1haW5kZXJzKGRiLnZpcCkpKS50aGVuKGZpcmVSZW1haW5kZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gbnVsbDtcbiAgICAgICAgc3RhdGUuaXNCZWluZ09wZW5lZCA9IGZhbHNlO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gZGI7XG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBlcnI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gJiYgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgaWYgKG9wZW5DYW5jZWxsZXIgPT09IHN0YXRlLm9wZW5DYW5jZWxsZXIpIHtcbiAgICAgICAgICAgIGRiLl9jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3Rpb24oZXJyKTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgc3RhdGUub3BlbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZURiUmVhZHkoKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYXdhaXRJdGVyYXRvcihpdGVyYXRvcikge1xuICAgIHZhciBjYWxsTmV4dCA9IHJlc3VsdCA9PiBpdGVyYXRvci5uZXh0KHJlc3VsdCksIGRvVGhyb3cgPSBlcnJvciA9PiBpdGVyYXRvci50aHJvdyhlcnJvciksIG9uU3VjY2VzcyA9IHN0ZXAoY2FsbE5leHQpLCBvbkVycm9yID0gc3RlcChkb1Rocm93KTtcbiAgICBmdW5jdGlvbiBzdGVwKGdldE5leHQpIHtcbiAgICAgICAgcmV0dXJuICh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZ2V0TmV4dCh2YWwpLCB2YWx1ZSA9IG5leHQudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gbmV4dC5kb25lID8gdmFsdWUgOlxuICAgICAgICAgICAgICAgICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlLnRoZW4gIT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgICBpc0FycmF5KHZhbHVlKSA/IFByb21pc2UuYWxsKHZhbHVlKS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikgOiBvblN1Y2Nlc3ModmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ZXAoY2FsbE5leHQpKCk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MobW9kZSwgX3RhYmxlQXJnc18sIHNjb3BlRnVuYykge1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAoaSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIlRvbyBmZXcgYXJndW1lbnRzXCIpO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICB3aGlsZSAoLS1pKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICBzY29wZUZ1bmMgPSBhcmdzLnBvcCgpO1xuICAgIHZhciB0YWJsZXMgPSBmbGF0dGVuKGFyZ3MpO1xuICAgIHJldHVybiBbbW9kZSwgdGFibGVzLCBzY29wZUZ1bmNdO1xufVxuZnVuY3Rpb24gZW50ZXJUcmFuc2FjdGlvblNjb3BlKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBwYXJlbnRUcmFuc2FjdGlvbiwgc2NvcGVGdW5jKSB7XG4gICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuICAgICAgICBjb25zdCB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEsIHBhcmVudFRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3Qgem9uZVByb3BzID0ge1xuICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgdHJhbnNsZXNzOiB0cmFuc2xlc3NcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0cmFucy5pZGJ0cmFucyA9IHBhcmVudFRyYW5zYWN0aW9uLmlkYnRyYW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBkYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogTmVlZCB0byByZW9wZW4gZGInKTtcbiAgICAgICAgICAgICAgICAgICAgZGIuX2Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbigoKSA9PiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoZGIsIG1vZGUsIHN0b3JlTmFtZXMsIG51bGwsIHNjb3BlRnVuYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY29wZUZ1bmNJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKHNjb3BlRnVuYyk7XG4gICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICAgICAgY29uc3QgcHJvbWlzZUZvbGxvd2VkID0gRGV4aWVQcm9taXNlLmZvbGxvdygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHNjb3BlRnVuYy5jYWxsKHRyYW5zLCB0cmFucyk7XG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZS5uZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGF3YWl0SXRlcmF0b3IocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgem9uZVByb3BzKTtcbiAgICAgICAgcmV0dXJuIChyZXR1cm5WYWx1ZSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkudGhlbih4ID0+IHRyYW5zLmFjdGl2ZSA/XG4gICAgICAgICAgICAgICAgeFxuICAgICAgICAgICAgICAgIDogcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlByZW1hdHVyZUNvbW1pdChcIlRyYW5zYWN0aW9uIGNvbW1pdHRlZCB0b28gZWFybHkuIFNlZSBodHRwOi8vYml0Lmx5LzJrZGNrTW5cIikpKVxuICAgICAgICAgICAgOiBwcm9taXNlRm9sbG93ZWQudGhlbigoKSA9PiByZXR1cm5WYWx1ZSkpLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgdHJhbnMuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0cmFucy5fY29tcGxldGlvbi50aGVuKCgpID0+IHgpO1xuICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIHRyYW5zLl9yZWplY3QoZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFkKGEsIHZhbHVlLCBjb3VudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGlzQXJyYXkoYSkgPyBhLnNsaWNlKCkgOiBbYV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKVxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxJbmRleE1pZGRsZXdhcmUoZG93bikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRvd24sXG4gICAgICAgIHRhYmxlKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBkb3duLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gdGFibGU7XG4gICAgICAgICAgICBjb25zdCBpbmRleExvb2t1cCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgYWxsVmlydHVhbEluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFZpcnR1YWxJbmRleGVzKGtleVBhdGgsIGtleVRhaWwsIGxvd0xldmVsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlQYXRoQWxpYXMgPSBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhMaXN0ID0gKGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gPSBpbmRleExvb2t1cFtrZXlQYXRoQWxpYXNdIHx8IFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBrZXlQYXRoID09IG51bGwgPyAwIDogdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8gMSA6IGtleVBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmlydHVhbCA9IGtleVRhaWwgPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxJbmRleCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubG93TGV2ZWxJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNWaXJ0dWFsLFxuICAgICAgICAgICAgICAgICAgICBrZXlUYWlsLFxuICAgICAgICAgICAgICAgICAgICBrZXlMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiAhaXNWaXJ0dWFsICYmIGxvd0xldmVsSW5kZXgudW5pcXVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbmRleExpc3QucHVzaCh2aXJ0dWFsSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghdmlydHVhbEluZGV4LmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxWaXJ0dWFsSW5kZXhlcy5wdXNoKHZpcnR1YWxJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXlMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxLZXlQYXRoID0ga2V5TGVuZ3RoID09PSAyID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGhbMF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aC5zbGljZSgwLCBrZXlMZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmlydHVhbEluZGV4ZXModmlydHVhbEtleVBhdGgsIGtleVRhaWwgKyAxLCBsb3dMZXZlbEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXhMaXN0LnNvcnQoKGEsIGIpID0+IGEua2V5VGFpbCAtIGIua2V5VGFpbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByaW1hcnlLZXkgPSBhZGRWaXJ0dWFsSW5kZXhlcyhzY2hlbWEucHJpbWFyeUtleS5rZXlQYXRoLCAwLCBzY2hlbWEucHJpbWFyeUtleSk7XG4gICAgICAgICAgICBpbmRleExvb2t1cFtcIjppZFwiXSA9IFtwcmltYXJ5S2V5XTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2Ygc2NoZW1hLmluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICBhZGRWaXJ0dWFsSW5kZXhlcyhpbmRleC5rZXlQYXRoLCAwLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kQmVzdEluZGV4KGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbmRleExvb2t1cFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgJiYgcmVzdWx0WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNsYXRlUmFuZ2UocmFuZ2UsIGtleVRhaWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiByYW5nZS50eXBlID09PSAxICA/XG4gICAgICAgICAgICAgICAgICAgICAgICAyICA6XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBsb3dlcjogcGFkKHJhbmdlLmxvd2VyLCByYW5nZS5sb3dlck9wZW4gPyBkb3duLk1BWF9LRVkgOiBkb3duLk1JTl9LRVksIGtleVRhaWwpLFxuICAgICAgICAgICAgICAgICAgICBsb3dlck9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyOiBwYWQocmFuZ2UudXBwZXIsIHJhbmdlLnVwcGVyT3BlbiA/IGRvd24uTUlOX0tFWSA6IGRvd24uTUFYX0tFWSwga2V5VGFpbCksXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyT3BlbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSZXF1ZXN0KHJlcSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnF1ZXJ5LmluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleC5pc1ZpcnR1YWwgPyB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnJlcSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRyYW5zbGF0ZVJhbmdlKHJlcS5xdWVyeS5yYW5nZSwgaW5kZXgua2V5VGFpbClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gOiByZXE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgLi4udGFibGUsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlczogYWxsVmlydHVhbEluZGV4ZXMsXG4gICAgICAgICAgICAgICAgICAgIGdldEluZGV4QnlLZXlQYXRoOiBmaW5kQmVzdEluZGV4XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb3VudChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmNvdW50KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBxdWVyeShyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLnF1ZXJ5KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcGVuQ3Vyc29yKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtleVRhaWwsIGlzVmlydHVhbCwga2V5TGVuZ3RoIH0gPSByZXEucXVlcnkuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWaXJ0dWFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlVmlydHVhbEN1cnNvcihjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9jb250aW51ZShrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShwYWQoa2V5LCByZXEucmV2ZXJzZSA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnVuaXF1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoY3Vyc29yLmtleS5zbGljZSgwLCBrZXlMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyZXEucmV2ZXJzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZG93bi5NSU5fS0VZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxDdXJzb3IgPSBPYmplY3QuY3JlYXRlKGN1cnNvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiB7IHZhbHVlOiBfY29udGludWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUoa2V5LCBwcmltYXJ5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5KHBhZChrZXksIGRvd24uTUFYX0tFWSwga2V5VGFpbCksIHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5TGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlbMF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5zbGljZSgwLCBrZXlMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlydHVhbEN1cnNvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUub3BlbkN1cnNvcih0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihjdXJzb3IgPT4gY3Vyc29yICYmIGNyZWF0ZVZpcnR1YWxDdXJzb3IoY3Vyc29yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgdmlydHVhbEluZGV4TWlkZGxld2FyZSA9IHtcbiAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICBuYW1lOiBcIlZpcnR1YWxJbmRleE1pZGRsZXdhcmVcIixcbiAgICBsZXZlbDogMSxcbiAgICBjcmVhdGU6IGNyZWF0ZVZpcnR1YWxJbmRleE1pZGRsZXdhcmVcbn07XG5cbmZ1bmN0aW9uIGdldE9iamVjdERpZmYoYSwgYiwgcnYsIHByZngpIHtcbiAgICBydiA9IHJ2IHx8IHt9O1xuICAgIHByZnggPSBwcmZ4IHx8ICcnO1xuICAgIGtleXMoYSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAoIWhhc093bihiLCBwcm9wKSkge1xuICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFwID0gYVtwcm9wXSwgYnAgPSBiW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJwID09PSAnb2JqZWN0JyAmJiBhcCAmJiBicCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwVHlwZU5hbWUgPSB0b1N0cmluZ1RhZyhhcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGJwKTtcbiAgICAgICAgICAgICAgICBpZiAoYXBUeXBlTmFtZSAhPT0gYnBUeXBlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcFR5cGVOYW1lID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBnZXRPYmplY3REaWZmKGFwLCBicCwgcnYsIHByZnggKyBwcm9wICsgJy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKVxuICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBrZXlzKGIpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKCFoYXNPd24oYSwgcHJvcCkpIHtcbiAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcnY7XG59XG5cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZUtleXMocHJpbWFyeUtleSwgcmVxKSB7XG4gICAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlJylcbiAgICAgICAgcmV0dXJuIHJlcS5rZXlzO1xuICAgIHJldHVybiByZXEua2V5cyB8fCByZXEudmFsdWVzLm1hcChwcmltYXJ5S2V5LmV4dHJhY3RLZXkpO1xufVxuXG5jb25zdCBob29rc01pZGRsZXdhcmUgPSB7XG4gICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgbmFtZTogXCJIb29rc01pZGRsZXdhcmVcIixcbiAgICBsZXZlbDogMixcbiAgICBjcmVhdGU6IChkb3duQ29yZSkgPT4gKHtcbiAgICAgICAgLi4uZG93bkNvcmUsXG4gICAgICAgIHRhYmxlKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgZG93blRhYmxlID0gZG93bkNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJpbWFyeUtleSB9ID0gZG93blRhYmxlLnNjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlTWlkZGxld2FyZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5kb3duVGFibGUsXG4gICAgICAgICAgICAgICAgbXV0YXRlKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkeFRyYW5zID0gUFNELnRyYW5zO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0aW5nLCBjcmVhdGluZywgdXBkYXRpbmcgfSA9IGR4VHJhbnMudGFibGUodGFibGVOYW1lKS5ob29rO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlcS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCAoKSA9PiBhZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0aW5nLmZpcmUgPT09IG5vcCAmJiB1cGRhdGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCAoKSA9PiBhZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0aW5nLmZpcmUgPT09IG5vcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpID0+IGFkZFB1dE9yRGVsZXRlKHJlcSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlUmFuZ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCAoKSA9PiBkZWxldGVSYW5nZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRQdXRPckRlbGV0ZShyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR4VHJhbnMgPSBQU0QudHJhbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gcmVxLmtleXMgfHwgZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IHJlcS50eXBlID09PSAnYWRkJyB8fCByZXEudHlwZSA9PT0gJ3B1dCcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgLi4ucmVxLCBrZXlzIH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgLi4ucmVxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09ICdkZWxldGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXMgPSBbLi4ucmVxLnZhbHVlc107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLmtleXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmtleXMgPSBbLi4ucmVxLmtleXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmFsdWVzKGRvd25UYWJsZSwgcmVxLCBrZXlzKS50aGVuKGV4aXN0aW5nVmFsdWVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0cyA9IGtleXMubWFwKChrZXksIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IGV4aXN0aW5nVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB7IG9uZXJyb3I6IG51bGwsIG9uc3VjY2VzczogbnVsbCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGluZy5maXJlLmNhbGwoY3R4LCBrZXksIGV4aXN0aW5nVmFsdWUsIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcS50eXBlID09PSAnYWRkJyB8fCBleGlzdGluZ1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZFByaW1hcnlLZXkgPSBjcmVhdGluZy5maXJlLmNhbGwoY3R4LCBrZXksIHJlcS52YWx1ZXNbaV0sIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsICYmIGdlbmVyYXRlZFByaW1hcnlLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGdlbmVyYXRlZFByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmtleXNbaV0gPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5Lm91dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChyZXEudmFsdWVzW2ldLCBwcmltYXJ5S2V5LmtleVBhdGgsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0RGlmZiA9IGdldE9iamVjdERpZmYoZXhpc3RpbmdWYWx1ZSwgcmVxLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsQ2hhbmdlcyA9IHVwZGF0aW5nLmZpcmUuY2FsbChjdHgsIG9iamVjdERpZmYsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRWYWx1ZSA9IHJlcS52YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYWRkaXRpb25hbENoYW5nZXMpLmZvckVhY2goa2V5UGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24ocmVxdWVzdGVkVmFsdWUsIGtleVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRWYWx1ZVtrZXlQYXRoXSA9IGFkZGl0aW9uYWxDaGFuZ2VzW2tleVBhdGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcXVlc3RlZFZhbHVlLCBrZXlQYXRoLCBhZGRpdGlvbmFsQ2hhbmdlc1trZXlQYXRoXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSkudGhlbigoeyBmYWlsdXJlcywgcmVzdWx0cywgbnVtRmFpbHVyZXMsIGxhc3RSZXN1bHQgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaW1LZXkgPSByZXN1bHRzID8gcmVzdWx0c1tpXSA6IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjb250ZXh0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihmYWlsdXJlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgub25zdWNjZXNzICYmIGN0eC5vbnN1Y2Nlc3MocmVxLnR5cGUgPT09ICdwdXQnICYmIGV4aXN0aW5nVmFsdWVzW2ldID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlc1tpXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1LZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZhaWx1cmVzLCByZXN1bHRzLCBudW1GYWlsdXJlcywgbGFzdFJlc3VsdCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dHMuZm9yRWFjaChjdHggPT4gY3R4Lm9uZXJyb3IgJiYgY3R4Lm9uZXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZVJhbmdlKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZU5leHRDaHVuayhyZXEudHJhbnMsIHJlcS5yYW5nZSwgMTAwMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZU5leHRDaHVuayh0cmFucywgcmFuZ2UsIGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLnF1ZXJ5KHsgdHJhbnMsIHZhbHVlczogZmFsc2UsIHF1ZXJ5OiB7IGluZGV4OiBwcmltYXJ5S2V5LCByYW5nZSB9LCBsaW1pdCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCh7IHJlc3VsdCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHsgdHlwZTogJ2RlbGV0ZScsIGtleXM6IHJlc3VsdCwgdHJhbnMgfSkudGhlbihyZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWlsdXJlczogW10sIG51bUZhaWx1cmVzOiAwLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxldGVOZXh0Q2h1bmsodHJhbnMsIHsgLi4ucmFuZ2UsIGxvd2VyOiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsb3dlck9wZW46IHRydWUgfSwgbGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGFibGVNaWRkbGV3YXJlO1xuICAgICAgICB9LFxuICAgIH0pXG59O1xuZnVuY3Rpb24gZ2V0RXhpc3RpbmdWYWx1ZXModGFibGUsIHJlcSwgZWZmZWN0aXZlS2V5cykge1xuICAgIHJldHVybiByZXEudHlwZSA9PT0gXCJhZGRcIlxuICAgICAgICA/IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICAgICAgOiB0YWJsZS5nZXRNYW55KHsgdHJhbnM6IHJlcS50cmFucywga2V5czogZWZmZWN0aXZlS2V5cywgY2FjaGU6IFwiaW1tdXRhYmxlXCIgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIGNhY2hlLCBjbG9uZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghY2FjaGUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGNhY2hlLmtleXMubGVuZ3RoIDwga2V5cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGNhY2hlLmtleXMubGVuZ3RoICYmIGogPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY21wKGNhY2hlLmtleXNbaV0sIGtleXNbal0pICE9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2xvbmUgPyBkZWVwQ2xvbmUoY2FjaGUudmFsdWVzW2ldKSA6IGNhY2hlLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IGtleXMubGVuZ3RoID8gcmVzdWx0IDogbnVsbDtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNvbnN0IGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlID0ge1xuICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgIGxldmVsOiAtMSxcbiAgICBjcmVhdGU6IChjb3JlKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWJsZTogKHRhYmxlTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhYmxlLFxuICAgICAgICAgICAgICAgICAgICBnZXRNYW55OiAocmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcS5jYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5nZXRNYW55KHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRSZXN1bHQgPSBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShyZXEua2V5cywgcmVxLnRyYW5zW1wiX2NhY2hlXCJdLCByZXEuY2FjaGUgPT09IFwiY2xvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS50cmFuc1tcIl9jYWNoZVwiXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogcmVxLmtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogcmVxLmNhY2hlID09PSBcImNsb25lXCIgPyBkZWVwQ2xvbmUocmVzKSA6IHJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlOiAocmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09IFwiYWRkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5tdXRhdGUocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZnVuY3Rpb24gaXNFbXB0eVJhbmdlKG5vZGUpIHtcbiAgICByZXR1cm4gIShcImZyb21cIiBpbiBub2RlKTtcbn1cbmNvbnN0IFJhbmdlU2V0ID0gZnVuY3Rpb24gKGZyb21PclRyZWUsIHRvKSB7XG4gICAgaWYgKHRoaXMpIHtcbiAgICAgICAgZXh0ZW5kKHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyB7IGQ6IDEsIGZyb206IGZyb21PclRyZWUsIHRvOiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRvIDogZnJvbU9yVHJlZSB9IDogeyBkOiAwIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcnYgPSBuZXcgUmFuZ2VTZXQoKTtcbiAgICAgICAgaWYgKGZyb21PclRyZWUgJiYgKFwiZFwiIGluIGZyb21PclRyZWUpKSB7XG4gICAgICAgICAgICBleHRlbmQocnYsIGZyb21PclRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG59O1xucHJvcHMoUmFuZ2VTZXQucHJvdG90eXBlLCB7XG4gICAgYWRkKHJhbmdlU2V0KSB7XG4gICAgICAgIG1lcmdlUmFuZ2VzKHRoaXMsIHJhbmdlU2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZGRLZXkoa2V5KSB7XG4gICAgICAgIGFkZFJhbmdlKHRoaXMsIGtleSwga2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZGRLZXlzKGtleXMpIHtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRSYW5nZSh0aGlzLCBrZXksIGtleSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIFtpdGVyYXRvclN5bWJvbF0oKSB7XG4gICAgICAgIHJldHVybiBnZXRSYW5nZVNldEl0ZXJhdG9yKHRoaXMpO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gYWRkUmFuZ2UodGFyZ2V0LCBmcm9tLCB0bykge1xuICAgIGNvbnN0IGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xuICAgIGlmIChpc05hTihkaWZmKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkaWZmID4gMClcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigpO1xuICAgIGlmIChpc0VtcHR5UmFuZ2UodGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh0YXJnZXQsIHsgZnJvbSwgdG8sIGQ6IDEgfSk7XG4gICAgY29uc3QgbGVmdCA9IHRhcmdldC5sO1xuICAgIGNvbnN0IHJpZ2h0ID0gdGFyZ2V0LnI7XG4gICAgaWYgKGNtcCh0bywgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgICAgICBsZWZ0XG4gICAgICAgICAgICA/IGFkZFJhbmdlKGxlZnQsIGZyb20sIHRvKVxuICAgICAgICAgICAgOiAodGFyZ2V0LmwgPSB7IGZyb20sIHRvLCBkOiAxLCBsOiBudWxsLCByOiBudWxsIH0pO1xuICAgICAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gICAgfVxuICAgIGlmIChjbXAoZnJvbSwgdGFyZ2V0LnRvKSA+IDApIHtcbiAgICAgICAgcmlnaHRcbiAgICAgICAgICAgID8gYWRkUmFuZ2UocmlnaHQsIGZyb20sIHRvKVxuICAgICAgICAgICAgOiAodGFyZ2V0LnIgPSB7IGZyb20sIHRvLCBkOiAxLCBsOiBudWxsLCByOiBudWxsIH0pO1xuICAgICAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gICAgfVxuICAgIGlmIChjbXAoZnJvbSwgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgICAgICB0YXJnZXQuZnJvbSA9IGZyb207XG4gICAgICAgIHRhcmdldC5sID0gbnVsbDtcbiAgICAgICAgdGFyZ2V0LmQgPSByaWdodCA/IHJpZ2h0LmQgKyAxIDogMTtcbiAgICB9XG4gICAgaWYgKGNtcCh0bywgdGFyZ2V0LnRvKSA+IDApIHtcbiAgICAgICAgdGFyZ2V0LnRvID0gdG87XG4gICAgICAgIHRhcmdldC5yID0gbnVsbDtcbiAgICAgICAgdGFyZ2V0LmQgPSB0YXJnZXQubCA/IHRhcmdldC5sLmQgKyAxIDogMTtcbiAgICB9XG4gICAgY29uc3QgcmlnaHRXYXNDdXRPZmYgPSAhdGFyZ2V0LnI7XG4gICAgaWYgKGxlZnQgJiYgIXRhcmdldC5sKSB7XG4gICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldCwgbGVmdCk7XG4gICAgfVxuICAgIGlmIChyaWdodCAmJiByaWdodFdhc0N1dE9mZikge1xuICAgICAgICBtZXJnZVJhbmdlcyh0YXJnZXQsIHJpZ2h0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVJhbmdlcyh0YXJnZXQsIG5ld1NldCkge1xuICAgIGZ1bmN0aW9uIF9hZGRSYW5nZVNldCh0YXJnZXQsIHsgZnJvbSwgdG8sIGwsIHIgfSkge1xuICAgICAgICBhZGRSYW5nZSh0YXJnZXQsIGZyb20sIHRvKTtcbiAgICAgICAgaWYgKGwpXG4gICAgICAgICAgICBfYWRkUmFuZ2VTZXQodGFyZ2V0LCBsKTtcbiAgICAgICAgaWYgKHIpXG4gICAgICAgICAgICBfYWRkUmFuZ2VTZXQodGFyZ2V0LCByKTtcbiAgICB9XG4gICAgaWYgKCFpc0VtcHR5UmFuZ2UobmV3U2V0KSlcbiAgICAgICAgX2FkZFJhbmdlU2V0KHRhcmdldCwgbmV3U2V0KTtcbn1cbmZ1bmN0aW9uIHJhbmdlc092ZXJsYXAocmFuZ2VTZXQxLCByYW5nZVNldDIpIHtcbiAgICBjb25zdCBpMSA9IGdldFJhbmdlU2V0SXRlcmF0b3IocmFuZ2VTZXQyKTtcbiAgICBsZXQgbmV4dFJlc3VsdDEgPSBpMS5uZXh0KCk7XG4gICAgaWYgKG5leHRSZXN1bHQxLmRvbmUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYSA9IG5leHRSZXN1bHQxLnZhbHVlO1xuICAgIGNvbnN0IGkyID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDEpO1xuICAgIGxldCBuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKTtcbiAgICBsZXQgYiA9IG5leHRSZXN1bHQyLnZhbHVlO1xuICAgIHdoaWxlICghbmV4dFJlc3VsdDEuZG9uZSAmJiAhbmV4dFJlc3VsdDIuZG9uZSkge1xuICAgICAgICBpZiAoY21wKGIuZnJvbSwgYS50bykgPD0gMCAmJiBjbXAoYi50bywgYS5mcm9tKSA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNtcChhLmZyb20sIGIuZnJvbSkgPCAwXG4gICAgICAgICAgICA/IChhID0gKG5leHRSZXN1bHQxID0gaTEubmV4dChiLmZyb20pKS52YWx1ZSlcbiAgICAgICAgICAgIDogKGIgPSAobmV4dFJlc3VsdDIgPSBpMi5uZXh0KGEuZnJvbSkpLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UmFuZ2VTZXRJdGVyYXRvcihub2RlKSB7XG4gICAgbGV0IHN0YXRlID0gaXNFbXB0eVJhbmdlKG5vZGUpID8gbnVsbCA6IHsgczogMCwgbjogbm9kZSB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBrZXlQcm92aWRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgd2hpbGUgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZS5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVByb3ZpZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLm4ubCAmJiBjbXAoa2V5LCBzdGF0ZS5uLmZyb20pIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5sLCBzOiAxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLmwsIHM6IDEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleVByb3ZpZGVkIHx8IGNtcChrZXksIHN0YXRlLm4udG8pIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHN0YXRlLm4sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5uLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLnIsIHM6IDAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS51cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlYmFsYW5jZSh0YXJnZXQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRpZmYgPSAoKChfYSA9IHRhcmdldC5yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZCkgfHwgMCkgLSAoKChfYiA9IHRhcmdldC5sKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZCkgfHwgMCk7XG4gICAgY29uc3QgciA9IGRpZmYgPiAxID8gXCJyXCIgOiBkaWZmIDwgLTEgPyBcImxcIiA6IFwiXCI7XG4gICAgaWYgKHIpIHtcbiAgICAgICAgY29uc3QgbCA9IHIgPT09IFwiclwiID8gXCJsXCIgOiBcInJcIjtcbiAgICAgICAgY29uc3Qgcm9vdENsb25lID0geyAuLi50YXJnZXQgfTtcbiAgICAgICAgY29uc3Qgb2xkUm9vdFJpZ2h0ID0gdGFyZ2V0W3JdO1xuICAgICAgICB0YXJnZXQuZnJvbSA9IG9sZFJvb3RSaWdodC5mcm9tO1xuICAgICAgICB0YXJnZXQudG8gPSBvbGRSb290UmlnaHQudG87XG4gICAgICAgIHRhcmdldFtyXSA9IG9sZFJvb3RSaWdodFtyXTtcbiAgICAgICAgcm9vdENsb25lW3JdID0gb2xkUm9vdFJpZ2h0W2xdO1xuICAgICAgICB0YXJnZXRbbF0gPSByb290Q2xvbmU7XG4gICAgICAgIHJvb3RDbG9uZS5kID0gY29tcHV0ZURlcHRoKHJvb3RDbG9uZSk7XG4gICAgfVxuICAgIHRhcmdldC5kID0gY29tcHV0ZURlcHRoKHRhcmdldCk7XG59XG5mdW5jdGlvbiBjb21wdXRlRGVwdGgoeyByLCBsIH0pIHtcbiAgICByZXR1cm4gKHIgPyAobCA/IE1hdGgubWF4KHIuZCwgbC5kKSA6IHIuZCkgOiBsID8gbC5kIDogMCkgKyAxO1xufVxuXG5jb25zdCBvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSA9IHtcbiAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICBsZXZlbDogMCxcbiAgICBjcmVhdGU6IChjb3JlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRiTmFtZSA9IGNvcmUuc2NoZW1hLm5hbWU7XG4gICAgICAgIGNvbnN0IEZVTExfUkFOR0UgPSBuZXcgUmFuZ2VTZXQoY29yZS5NSU5fS0VZLCBjb3JlLk1BWF9LRVkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29yZSxcbiAgICAgICAgICAgIHRhYmxlOiAodGFibGVOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHRhYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJpbWFyeUtleSB9ID0gc2NoZW1hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXh0cmFjdEtleSwgb3V0Ym91bmQgfSA9IHByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGVDbG9uZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGFibGUsXG4gICAgICAgICAgICAgICAgICAgIG11dGF0ZTogKHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnMgPSByZXEudHJhbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtdXRhdGVkUGFydHMgPSB0cmFucy5tdXRhdGVkUGFydHMgfHwgKHRyYW5zLm11dGF0ZWRQYXJ0cyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldFJhbmdlU2V0ID0gKGluZGV4TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBgaWRiOi8vJHtkYk5hbWV9LyR7dGFibGVOYW1lfS8ke2luZGV4TmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobXV0YXRlZFBhcnRzW3BhcnRdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtdXRhdGVkUGFydHNbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBrUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbHNSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHJlcTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBba2V5cywgbmV3T2Jqc10gPSByZXEudHlwZSA9PT0gXCJkZWxldGVSYW5nZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcmVxLnJhbmdlXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxLnR5cGUgPT09IFwiZGVsZXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcmVxLmtleXNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxLnZhbHVlcy5sZW5ndGggPCA1MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbW10sIHJlcS52YWx1ZXNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkQ2FjaGUgPSByZXEudHJhbnNbXCJfY2FjaGVcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUubXV0YXRlKHJlcSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IFwiZGVsZXRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzID0gcmVzLnJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkT2JqcyA9IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIG9sZENhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRPYmpzICYmIHR5cGUgIT09IFwiYWRkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRPYmpzIHx8IG5ld09ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrQWZmZWN0ZWRJbmRleGVzKGdldFJhbmdlU2V0LCBzY2hlbWEsIG9sZE9ianMsIG5ld09ianMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7IGZyb206IGtleXMubG93ZXIsIHRvOiBrZXlzLnVwcGVyIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChpZHggPT4gZ2V0UmFuZ2VTZXQoaWR4Lm5hbWUpLmFkZChGVUxMX1JBTkdFKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldFJhbmdlID0gKHsgcXVlcnk6IHsgaW5kZXgsIHJhbmdlIH0sIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJhbmdlU2V0KChfYSA9IHJhbmdlLmxvd2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb3JlLk1JTl9LRVksIChfYiA9IHJhbmdlLnVwcGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb3JlLk1BWF9LRVkpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZFN1YnNjcmliZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IChyZXEpID0+IFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQocmVxLmtleSldLFxuICAgICAgICAgICAgICAgICAgICBnZXRNYW55OiAocmVxKSA9PiBbcHJpbWFyeUtleSwgbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhyZXEua2V5cyldLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogZ2V0UmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBnZXRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlbkN1cnNvcjogZ2V0UmFuZ2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBrZXlzKHJlYWRTdWJzY3JpYmVycykuZm9yRWFjaChtZXRob2QgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsb25lW21ldGhvZF0gPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN1YnNjciB9ID0gUFNEO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldFJhbmdlU2V0ID0gKGluZGV4TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gYGlkYjovLyR7ZGJOYW1lfS8ke3RhYmxlTmFtZX0vJHtpbmRleE5hbWV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzdWJzY3JbcGFydF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdWJzY3JbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGtSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbHNSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3F1ZXJpZWRJbmRleCwgcXVlcmllZFJhbmdlc10gPSByZWFkU3Vic2NyaWJlcnNbbWV0aG9kXShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJhbmdlU2V0KHF1ZXJpZWRJbmRleC5uYW1lIHx8IFwiXCIpLmFkZChxdWVyaWVkUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXJpZWRJbmRleC5pc1ByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjb3VudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkKEZVTExfUkFOR0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5c1Byb21pc2UgPSBtZXRob2QgPT09IFwicXVlcnlcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInF1ZXJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kICYmIHJlcS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzUHJvbWlzZS50aGVuKCh7IHJlc3VsdDogcmVzdWx0aW5nS2V5cyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHJlc3VsdGluZ0tleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwS2V5cyA9IHJlcS52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzLnJlc3VsdC5tYXAoZXh0cmFjdEtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhwS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5cyhwS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSBcIm9wZW5DdXJzb3JcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhbnRWYWx1ZXMgPSByZXEudmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGN1cnNvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShjdXJzb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZEtleShjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGtleSA9IGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZEtleShwa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwa2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FudFZhbHVlcyAmJiBwa1JhbmdlU2V0LmFkZEtleShjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlQ2xvbmU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdHJhY2tBZmZlY3RlZEluZGV4ZXMoZ2V0UmFuZ2VTZXQsIHNjaGVtYSwgb2xkT2JqcywgbmV3T2Jqcykge1xuICAgIGZ1bmN0aW9uIGFkZEFmZmVjdGVkSW5kZXgoaXgpIHtcbiAgICAgICAgY29uc3QgcmFuZ2VTZXQgPSBnZXRSYW5nZVNldChpeC5uYW1lIHx8IFwiXCIpO1xuICAgICAgICBmdW5jdGlvbiBleHRyYWN0S2V5KG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8gaXguZXh0cmFjdEtleShvYmopIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRLZXlPcktleXMgPSAoa2V5KSA9PiBpeC5tdWx0aUVudHJ5ICYmIGlzQXJyYXkoa2V5KVxuICAgICAgICAgICAgPyBrZXkuZm9yRWFjaChrZXkgPT4gcmFuZ2VTZXQuYWRkS2V5KGtleSkpXG4gICAgICAgICAgICA6IHJhbmdlU2V0LmFkZEtleShrZXkpO1xuICAgICAgICAob2xkT2JqcyB8fCBuZXdPYmpzKS5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRLZXkgPSBvbGRPYmpzICYmIGV4dHJhY3RLZXkob2xkT2Jqc1tpXSk7XG4gICAgICAgICAgICBjb25zdCBuZXdLZXkgPSBuZXdPYmpzICYmIGV4dHJhY3RLZXkobmV3T2Jqc1tpXSk7XG4gICAgICAgICAgICBpZiAoY21wKG9sZEtleSwgbmV3S2V5KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRLZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYWRkS2V5T3JLZXlzKG9sZEtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0tleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBhZGRLZXlPcktleXMobmV3S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVtYS5pbmRleGVzLmZvckVhY2goYWRkQWZmZWN0ZWRJbmRleCk7XG59XG5cbmNsYXNzIERleGllJDEge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fbWlkZGxld2FyZXMgPSB7fTtcbiAgICAgICAgdGhpcy52ZXJubyA9IDA7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBEZXhpZSQxLmRlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhZGRvbnM6IERleGllJDEuYWRkb25zLFxuICAgICAgICAgICAgYXV0b09wZW46IHRydWUsXG4gICAgICAgICAgICBpbmRleGVkREI6IGRlcHMuaW5kZXhlZERCLFxuICAgICAgICAgICAgSURCS2V5UmFuZ2U6IGRlcHMuSURCS2V5UmFuZ2UsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RlcHMgPSB7XG4gICAgICAgICAgICBpbmRleGVkREI6IG9wdGlvbnMuaW5kZXhlZERCLFxuICAgICAgICAgICAgSURCS2V5UmFuZ2U6IG9wdGlvbnMuSURCS2V5UmFuZ2VcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBhZGRvbnMsIH0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9kYlNjaGVtYSA9IHt9O1xuICAgICAgICB0aGlzLl92ZXJzaW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9zdG9yZU5hbWVzID0gW107XG4gICAgICAgIHRoaXMuX2FsbFRhYmxlcyA9IHt9O1xuICAgICAgICB0aGlzLmlkYmRiID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbm92aXAgPSB0aGlzO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGRiT3BlbkVycm9yOiBudWxsLFxuICAgICAgICAgICAgaXNCZWluZ09wZW5lZDogZmFsc2UsXG4gICAgICAgICAgICBvblJlYWR5QmVpbmdGaXJlZDogbnVsbCxcbiAgICAgICAgICAgIG9wZW5Db21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICBkYlJlYWR5UmVzb2x2ZTogbm9wLFxuICAgICAgICAgICAgZGJSZWFkeVByb21pc2U6IG51bGwsXG4gICAgICAgICAgICBjYW5jZWxPcGVuOiBub3AsXG4gICAgICAgICAgICBvcGVuQ2FuY2VsbGVyOiBudWxsLFxuICAgICAgICAgICAgYXV0b1NjaGVtYTogdHJ1ZSxcbiAgICAgICAgICAgIFBSMTM5OF9tYXhMb29wOiAzXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlID0gbmV3IERleGllUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLm9wZW5DYW5jZWxsZXIgPSBuZXcgRGV4aWVQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm9uID0gRXZlbnRzKHRoaXMsIFwicG9wdWxhdGVcIiwgXCJibG9ja2VkXCIsIFwidmVyc2lvbmNoYW5nZVwiLCBcImNsb3NlXCIsIHsgcmVhZHk6IFtwcm9taXNhYmxlQ2hhaW4sIG5vcF0gfSk7XG4gICAgICAgIHRoaXMub24ucmVhZHkuc3Vic2NyaWJlID0gb3ZlcnJpZGUodGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUsIHN1YnNjcmliZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHN1YnNjcmliZXIsIGJTdGlja3kpID0+IHtcbiAgICAgICAgICAgICAgICBEZXhpZSQxLnZpcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5vcGVuQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuZGJPcGVuRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUoKS50aGVuKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJTdGlja3kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJTdGlja3kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiU3RpY2t5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIub24ucmVhZHkudW5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHVuc3Vic2NyaWJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuQ29sbGVjdGlvbiA9IGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgdGhpcy5UYWJsZSA9IGNyZWF0ZVRhYmxlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIHRoaXMuVHJhbnNhY3Rpb24gPSBjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLlZlcnNpb24gPSBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIHRoaXMuV2hlcmVDbGF1c2UgPSBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLm9uKFwidmVyc2lvbmNoYW5nZVwiLCBldiA9PiB7XG4gICAgICAgICAgICBpZiAoZXYubmV3VmVyc2lvbiA+IDApXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gdXBncmFkZSBkYXRhYmFzZSAnJHt0aGlzLm5hbWV9Jy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSB1cGdyYWRlLmApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIGRlbGV0ZSBkYXRhYmFzZSAnJHt0aGlzLm5hbWV9Jy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSBkZWxldGUgcmVxdWVzdC5gKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oXCJibG9ja2VkXCIsIGV2ID0+IHtcbiAgICAgICAgICAgIGlmICghZXYubmV3VmVyc2lvbiB8fCBldi5uZXdWZXJzaW9uIDwgZXYub2xkVmVyc2lvbilcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYERleGllLmRlbGV0ZSgnJHt0aGlzLm5hbWV9Jykgd2FzIGJsb2NrZWRgKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVwZ3JhZGUgJyR7dGhpcy5uYW1lfScgYmxvY2tlZCBieSBvdGhlciBjb25uZWN0aW9uIGhvbGRpbmcgdmVyc2lvbiAke2V2Lm9sZFZlcnNpb24gLyAxMH1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21heEtleSA9IGdldE1heEtleShvcHRpb25zLklEQktleVJhbmdlKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlVHJhbnNhY3Rpb24gPSAobW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIHBhcmVudFRyYW5zYWN0aW9uKSA9PiBuZXcgdGhpcy5UcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgdGhpcy5fb3B0aW9ucy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksIHBhcmVudFRyYW5zYWN0aW9uKTtcbiAgICAgICAgdGhpcy5fZmlyZU9uQmxvY2tlZCA9IGV2ID0+IHtcbiAgICAgICAgICAgIHRoaXMub24oXCJibG9ja2VkXCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgY29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGMgPT4gYy5uYW1lID09PSB0aGlzLm5hbWUgJiYgYyAhPT0gdGhpcyAmJiAhYy5fc3RhdGUudmNGaXJlZClcbiAgICAgICAgICAgICAgICAubWFwKGMgPT4gYy5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldikpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVzZSh2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlKTtcbiAgICAgICAgdGhpcy51c2UoaG9va3NNaWRkbGV3YXJlKTtcbiAgICAgICAgdGhpcy51c2Uob2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUpO1xuICAgICAgICB0aGlzLnVzZShjYWNoZUV4aXN0aW5nVmFsdWVzTWlkZGxld2FyZSk7XG4gICAgICAgIHRoaXMudmlwID0gT2JqZWN0LmNyZWF0ZSh0aGlzLCB7IF92aXA6IHsgdmFsdWU6IHRydWUgfSB9KTtcbiAgICAgICAgYWRkb25zLmZvckVhY2goYWRkb24gPT4gYWRkb24odGhpcykpO1xuICAgIH1cbiAgICB2ZXJzaW9uKHZlcnNpb25OdW1iZXIpIHtcbiAgICAgICAgaWYgKGlzTmFOKHZlcnNpb25OdW1iZXIpIHx8IHZlcnNpb25OdW1iZXIgPCAwLjEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5UeXBlKGBHaXZlbiB2ZXJzaW9uIGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlcmApO1xuICAgICAgICB2ZXJzaW9uTnVtYmVyID0gTWF0aC5yb3VuZCh2ZXJzaW9uTnVtYmVyICogMTApIC8gMTA7XG4gICAgICAgIGlmICh0aGlzLmlkYmRiIHx8IHRoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJDYW5ub3QgYWRkIHZlcnNpb24gd2hlbiBkYXRhYmFzZSBpcyBvcGVuXCIpO1xuICAgICAgICB0aGlzLnZlcm5vID0gTWF0aC5tYXgodGhpcy52ZXJubywgdmVyc2lvbk51bWJlcik7XG4gICAgICAgIGNvbnN0IHZlcnNpb25zID0gdGhpcy5fdmVyc2lvbnM7XG4gICAgICAgIHZhciB2ZXJzaW9uSW5zdGFuY2UgPSB2ZXJzaW9ucy5maWx0ZXIodiA9PiB2Ll9jZmcudmVyc2lvbiA9PT0gdmVyc2lvbk51bWJlcilbMF07XG4gICAgICAgIGlmICh2ZXJzaW9uSW5zdGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgICAgICB2ZXJzaW9uSW5zdGFuY2UgPSBuZXcgdGhpcy5WZXJzaW9uKHZlcnNpb25OdW1iZXIpO1xuICAgICAgICB2ZXJzaW9ucy5wdXNoKHZlcnNpb25JbnN0YW5jZSk7XG4gICAgICAgIHZlcnNpb25zLnNvcnQobG93ZXJWZXJzaW9uRmlyc3QpO1xuICAgICAgICB2ZXJzaW9uSW5zdGFuY2Uuc3RvcmVzKHt9KTtcbiAgICAgICAgdGhpcy5fc3RhdGUuYXV0b1NjaGVtYSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgIH1cbiAgICBfd2hlblJlYWR5KGZuKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZGJkYiAmJiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlIHx8IFBTRC5sZXRUaHJvdWdoIHx8IHRoaXMuX3ZpcCkpID8gZm4oKSA6IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQodGhpcy5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5hdXRvT3Blbikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuKCkuY2F0Y2gobm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkudGhlbihmbik7XG4gICAgfVxuICAgIHVzZSh7IHN0YWNrLCBjcmVhdGUsIGxldmVsLCBuYW1lIH0pIHtcbiAgICAgICAgaWYgKG5hbWUpXG4gICAgICAgICAgICB0aGlzLnVudXNlKHsgc3RhY2ssIG5hbWUgfSk7XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdIHx8ICh0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gPSBbXSk7XG4gICAgICAgIG1pZGRsZXdhcmVzLnB1c2goeyBzdGFjaywgY3JlYXRlLCBsZXZlbDogbGV2ZWwgPT0gbnVsbCA/IDEwIDogbGV2ZWwsIG5hbWUgfSk7XG4gICAgICAgIG1pZGRsZXdhcmVzLnNvcnQoKGEsIGIpID0+IGEubGV2ZWwgLSBiLmxldmVsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVudXNlKHsgc3RhY2ssIG5hbWUsIGNyZWF0ZSB9KSB7XG4gICAgICAgIGlmIChzdGFjayAmJiB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10pIHtcbiAgICAgICAgICAgIHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXS5maWx0ZXIobXcgPT4gY3JlYXRlID8gbXcuY3JlYXRlICE9PSBjcmVhdGUgOlxuICAgICAgICAgICAgICAgIG5hbWUgPyBtdy5uYW1lICE9PSBuYW1lIDpcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcGVuKCkge1xuICAgICAgICByZXR1cm4gZGV4aWVPcGVuKHRoaXMpO1xuICAgIH1cbiAgICBfY2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGNvbnN0IGlkeCA9IGNvbm5lY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGlmIChpZHggPj0gMClcbiAgICAgICAgICAgIGNvbm5lY3Rpb25zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICBpZiAodGhpcy5pZGJkYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkYmRiLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB0aGlzLl9ub3ZpcC5pZGJkYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UgPSBuZXcgRGV4aWVQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUub3BlbkNhbmNlbGxlciA9IG5ldyBEZXhpZVByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLl9jbG9zZSgpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICB0aGlzLl9vcHRpb25zLmF1dG9PcGVuID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKTtcbiAgICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQpXG4gICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuKHN0YXRlLmRiT3BlbkVycm9yKTtcbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICBjb25zdCBoYXNBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9EZWxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHZhciByZXEgPSB0aGlzLl9kZXBzLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZSh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgX29uRGF0YWJhc2VEZWxldGVkKHRoaXMuX2RlcHMsIHRoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIHJlcS5vbmJsb2NrZWQgPSB0aGlzLl9maXJlT25CbG9ja2VkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoYXNBcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG5vdCBhbGxvd2VkIGluIGRiLmRlbGV0ZSgpXCIpO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKGRvRGVsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvRGVsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBiYWNrZW5kREIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkYmRiO1xuICAgIH1cbiAgICBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkYmRiICE9PSBudWxsO1xuICAgIH1cbiAgICBoYXNCZWVuQ2xvc2VkKCkge1xuICAgICAgICBjb25zdCBkYk9wZW5FcnJvciA9IHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgICAgICByZXR1cm4gZGJPcGVuRXJyb3IgJiYgKGRiT3BlbkVycm9yLm5hbWUgPT09ICdEYXRhYmFzZUNsb3NlZCcpO1xuICAgIH1cbiAgICBoYXNGYWlsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvciAhPT0gbnVsbDtcbiAgICB9XG4gICAgZHluYW1pY2FsbHlPcGVuZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hO1xuICAgIH1cbiAgICBnZXQgdGFibGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyh0aGlzLl9hbGxUYWJsZXMpLm1hcChuYW1lID0+IHRoaXMuX2FsbFRhYmxlc1tuYW1lXSk7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gZXh0cmFjdFRyYW5zYWN0aW9uQXJncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIF90cmFuc2FjdGlvbihtb2RlLCB0YWJsZXMsIHNjb3BlRnVuYykge1xuICAgICAgICBsZXQgcGFyZW50VHJhbnNhY3Rpb24gPSBQU0QudHJhbnM7XG4gICAgICAgIGlmICghcGFyZW50VHJhbnNhY3Rpb24gfHwgcGFyZW50VHJhbnNhY3Rpb24uZGIgIT09IHRoaXMgfHwgbW9kZS5pbmRleE9mKCchJykgIT09IC0xKVxuICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICBjb25zdCBvbmx5SWZDb21wYXRpYmxlID0gbW9kZS5pbmRleE9mKCc/JykgIT09IC0xO1xuICAgICAgICBtb2RlID0gbW9kZS5yZXBsYWNlKCchJywgJycpLnJlcGxhY2UoJz8nLCAnJyk7XG4gICAgICAgIGxldCBpZGJNb2RlLCBzdG9yZU5hbWVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RvcmVOYW1lcyA9IHRhYmxlcy5tYXAodGFibGUgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSB0YWJsZSBpbnN0YW5jZW9mIHRoaXMuVGFibGUgPyB0YWJsZS5uYW1lIDogdGFibGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZU5hbWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0YWJsZSBhcmd1bWVudCB0byBEZXhpZS50cmFuc2FjdGlvbigpLiBPbmx5IFRhYmxlIG9yIFN0cmluZyBhcmUgYWxsb3dlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmVOYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobW9kZSA9PSBcInJcIiB8fCBtb2RlID09PSBSRUFET05MWSlcbiAgICAgICAgICAgICAgICBpZGJNb2RlID0gUkVBRE9OTFk7XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwicndcIiB8fCBtb2RlID09IFJFQURXUklURSlcbiAgICAgICAgICAgICAgICBpZGJNb2RlID0gUkVBRFdSSVRFO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgdHJhbnNhY3Rpb24gbW9kZTogXCIgKyBtb2RlKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbi5tb2RlID09PSBSRUFET05MWSAmJiBpZGJNb2RlID09PSBSRUFEV1JJVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TdWJUcmFuc2FjdGlvbihcIkNhbm5vdCBlbnRlciBhIHN1Yi10cmFuc2FjdGlvbiB3aXRoIFJFQURXUklURSBtb2RlIHdoZW4gcGFyZW50IHRyYW5zYWN0aW9uIGlzIFJFQURPTkxZXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lcy5mb3JFYWNoKHN0b3JlTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24gJiYgcGFyZW50VHJhbnNhY3Rpb24uc3RvcmVOYW1lcy5pbmRleE9mKHN0b3JlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiVGFibGUgXCIgKyBzdG9yZU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgbm90IGluY2x1ZGVkIGluIHBhcmVudCB0cmFuc2FjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSAmJiBwYXJlbnRUcmFuc2FjdGlvbiAmJiAhcGFyZW50VHJhbnNhY3Rpb24uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRUcmFuc2FjdGlvbiA/XG4gICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UobnVsbCwgKF8sIHJlamVjdCkgPT4geyByZWplY3QoZSk7IH0pIDpcbiAgICAgICAgICAgICAgICByZWplY3Rpb24oZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50ZXJUcmFuc2FjdGlvbiA9IGVudGVyVHJhbnNhY3Rpb25TY29wZS5iaW5kKG51bGwsIHRoaXMsIGlkYk1vZGUsIHN0b3JlTmFtZXMsIHBhcmVudFRyYW5zYWN0aW9uLCBzY29wZUZ1bmMpO1xuICAgICAgICByZXR1cm4gKHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKGlkYk1vZGUsIGVudGVyVHJhbnNhY3Rpb24sIFwibG9ja1wiKSA6XG4gICAgICAgICAgICBQU0QudHJhbnMgP1xuICAgICAgICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCAoKSA9PiB0aGlzLl93aGVuUmVhZHkoZW50ZXJUcmFuc2FjdGlvbikpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl93aGVuUmVhZHkoZW50ZXJUcmFuc2FjdGlvbikpO1xuICAgIH1cbiAgICB0YWJsZSh0YWJsZU5hbWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd24odGhpcy5fYWxsVGFibGVzLCB0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkVGFibGUoYFRhYmxlICR7dGFibGVOYW1lfSBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxUYWJsZXNbdGFibGVOYW1lXTtcbiAgICB9XG59XG5cbmNvbnN0IHN5bWJvbE9ic2VydmFibGUgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFwib2JzZXJ2YWJsZVwiIGluIFN5bWJvbFxuICAgID8gU3ltYm9sLm9ic2VydmFibGVcbiAgICA6IFwiQEBvYnNlcnZhYmxlXCI7XG5jbGFzcyBPYnNlcnZhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihzdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoeCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoIXggfHwgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHsgbmV4dDogeCwgZXJyb3IsIGNvbXBsZXRlIH0gOiB4KTtcbiAgICB9XG4gICAgW3N5bWJvbE9ic2VydmFibGVdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodGFyZ2V0LCBuZXdTZXQpIHtcbiAgICBrZXlzKG5ld1NldCkuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgICAgY29uc3QgcmFuZ2VTZXQgPSB0YXJnZXRbcGFydF0gfHwgKHRhcmdldFtwYXJ0XSA9IG5ldyBSYW5nZVNldCgpKTtcbiAgICAgICAgbWVyZ2VSYW5nZXMocmFuZ2VTZXQsIG5ld1NldFtwYXJ0XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gbGl2ZVF1ZXJ5KHF1ZXJpZXIpIHtcbiAgICBsZXQgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICBsZXQgY3VycmVudFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgY29uc3Qgc2NvcGVGdW5jSXNBc3luYyA9IGlzQXN5bmNGdW5jdGlvbihxdWVyaWVyKTtcbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZShzdWJzY3IpIHtcbiAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4ZWMgPSAoKSA9PiBuZXdTY29wZShxdWVyaWVyLCB7IHN1YnNjciwgdHJhbnM6IG51bGwgfSk7XG4gICAgICAgICAgICBjb25zdCBydiA9IFBTRC50cmFuc1xuICAgICAgICAgICAgICAgID9cbiAgICAgICAgICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsIGV4ZWMpXG4gICAgICAgICAgICAgICAgOiBleGVjKCk7XG4gICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgICAgICAgIHJ2LnRoZW4oZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMsIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGxldCBhY2N1bU11dHMgPSB7fTtcbiAgICAgICAgbGV0IGN1cnJlbnRPYnMgPSB7fTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQudW5zdWJzY3JpYmUobXV0YXRpb25MaXN0ZW5lcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBvYnNlcnZlci5zdGFydCAmJiBvYnNlcnZlci5zdGFydChzdWJzY3JpcHRpb24pO1xuICAgICAgICBsZXQgcXVlcnlpbmcgPSBmYWxzZSwgc3RhcnRlZExpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBzaG91bGROb3RpZnkoKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5cyhjdXJyZW50T2JzKS5zb21lKChrZXkpID0+IGFjY3VtTXV0c1trZXldICYmIHJhbmdlc092ZXJsYXAoYWNjdW1NdXRzW2tleV0sIGN1cnJlbnRPYnNba2V5XSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG11dGF0aW9uTGlzdGVuZXIgPSAocGFydHMpID0+IHtcbiAgICAgICAgICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQoYWNjdW1NdXRzLCBwYXJ0cyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KCkpIHtcbiAgICAgICAgICAgICAgICBkb1F1ZXJ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRvUXVlcnkgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocXVlcnlpbmcgfHwgY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyID0ge307XG4gICAgICAgICAgICBjb25zdCByZXQgPSBleGVjdXRlKHN1YnNjcik7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0ZWRMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIG11dGF0aW9uTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWRMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVlcnlpbmcgPSB0cnVlO1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBxdWVyeWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9RdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW1NdXRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPYnMgPSBzdWJzY3I7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBxdWVyeWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgJiYgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBkb1F1ZXJ5KCk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfSk7XG4gICAgb2JzZXJ2YWJsZS5oYXNWYWx1ZSA9ICgpID0+IGhhc1ZhbHVlO1xuICAgIG9ic2VydmFibGUuZ2V0VmFsdWUgPSAoKSA9PiBjdXJyZW50VmFsdWU7XG4gICAgcmV0dXJuIG9ic2VydmFibGU7XG59XG5cbmxldCBkb21EZXBzO1xudHJ5IHtcbiAgICBkb21EZXBzID0ge1xuICAgICAgICBpbmRleGVkREI6IF9nbG9iYWwuaW5kZXhlZERCIHx8IF9nbG9iYWwubW96SW5kZXhlZERCIHx8IF9nbG9iYWwud2Via2l0SW5kZXhlZERCIHx8IF9nbG9iYWwubXNJbmRleGVkREIsXG4gICAgICAgIElEQktleVJhbmdlOiBfZ2xvYmFsLklEQktleVJhbmdlIHx8IF9nbG9iYWwud2Via2l0SURCS2V5UmFuZ2VcbiAgICB9O1xufVxuY2F0Y2ggKGUpIHtcbiAgICBkb21EZXBzID0geyBpbmRleGVkREI6IG51bGwsIElEQktleVJhbmdlOiBudWxsIH07XG59XG5cbmNvbnN0IERleGllID0gRGV4aWUkMTtcbnByb3BzKERleGllLCB7XG4gICAgLi4uZnVsbE5hbWVFeGNlcHRpb25zLFxuICAgIGRlbGV0ZShkYXRhYmFzZU5hbWUpIHtcbiAgICAgICAgY29uc3QgZGIgPSBuZXcgRGV4aWUoZGF0YWJhc2VOYW1lLCB7IGFkZG9uczogW10gfSk7XG4gICAgICAgIHJldHVybiBkYi5kZWxldGUoKTtcbiAgICB9LFxuICAgIGV4aXN0cyhuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWUobmFtZSwgeyBhZGRvbnM6IFtdIH0pLm9wZW4oKS50aGVuKGRiID0+IHtcbiAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSkuY2F0Y2goJ05vU3VjaERhdGFiYXNlRXJyb3InLCAoKSA9PiBmYWxzZSk7XG4gICAgfSxcbiAgICBnZXREYXRhYmFzZU5hbWVzKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RGF0YWJhc2VOYW1lcyhEZXhpZS5kZXBlbmRlbmNpZXMpLnRoZW4oY2IpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZWZpbmVDbGFzcygpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2xhc3MoY29udGVudCkge1xuICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDbGFzcztcbiAgICB9LFxuICAgIGlnbm9yZVRyYW5zYWN0aW9uKHNjb3BlRnVuYykge1xuICAgICAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBzY29wZUZ1bmMpIDpcbiAgICAgICAgICAgIHNjb3BlRnVuYygpO1xuICAgIH0sXG4gICAgdmlwLFxuICAgIGFzeW5jOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocnYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNwYXduOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4sIGFyZ3MsIHRoaXopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpeiwgYXJncyB8fCBbXSkpO1xuICAgICAgICAgICAgaWYgKCFydiB8fCB0eXBlb2YgcnYudGhlbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocnYpO1xuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjdXJyZW50VHJhbnNhY3Rpb246IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBQU0QudHJhbnMgfHwgbnVsbFxuICAgIH0sXG4gICAgd2FpdEZvcjogZnVuY3Rpb24gKHByb21pc2VPckZ1bmN0aW9uLCBvcHRpb25hbFRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHR5cGVvZiBwcm9taXNlT3JGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbihwcm9taXNlT3JGdW5jdGlvbikgOlxuICAgICAgICAgICAgcHJvbWlzZU9yRnVuY3Rpb24pXG4gICAgICAgICAgICAudGltZW91dChvcHRpb25hbFRpbWVvdXQgfHwgNjAwMDApO1xuICAgICAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgICAgICAgIFBTRC50cmFucy53YWl0Rm9yKHByb21pc2UpIDpcbiAgICAgICAgICAgIHByb21pc2U7XG4gICAgfSxcbiAgICBQcm9taXNlOiBEZXhpZVByb21pc2UsXG4gICAgZGVidWc6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBkZWJ1ZyxcbiAgICAgICAgc2V0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzZXREZWJ1Zyh2YWx1ZSwgdmFsdWUgPT09ICdkZXhpZScgPyAoKSA9PiB0cnVlIDogZGV4aWVTdGFja0ZyYW1lRmlsdGVyKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVyaXZlOiBkZXJpdmUsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIG92ZXJyaWRlOiBvdmVycmlkZSxcbiAgICBFdmVudHM6IEV2ZW50cyxcbiAgICBvbjogZ2xvYmFsRXZlbnRzLFxuICAgIGxpdmVRdWVyeSxcbiAgICBleHRlbmRPYnNlcnZhYmlsaXR5U2V0LFxuICAgIGdldEJ5S2V5UGF0aDogZ2V0QnlLZXlQYXRoLFxuICAgIHNldEJ5S2V5UGF0aDogc2V0QnlLZXlQYXRoLFxuICAgIGRlbEJ5S2V5UGF0aDogZGVsQnlLZXlQYXRoLFxuICAgIHNoYWxsb3dDbG9uZTogc2hhbGxvd0Nsb25lLFxuICAgIGRlZXBDbG9uZTogZGVlcENsb25lLFxuICAgIGdldE9iamVjdERpZmY6IGdldE9iamVjdERpZmYsXG4gICAgY21wLFxuICAgIGFzYXA6IGFzYXAkMSxcbiAgICBtaW5LZXk6IG1pbktleSxcbiAgICBhZGRvbnM6IFtdLFxuICAgIGNvbm5lY3Rpb25zOiBjb25uZWN0aW9ucyxcbiAgICBlcnJuYW1lczogZXJybmFtZXMsXG4gICAgZGVwZW5kZW5jaWVzOiBkb21EZXBzLFxuICAgIHNlbVZlcjogREVYSUVfVkVSU0lPTixcbiAgICB2ZXJzaW9uOiBERVhJRV9WRVJTSU9OLnNwbGl0KCcuJylcbiAgICAgICAgLm1hcChuID0+IHBhcnNlSW50KG4pKVxuICAgICAgICAucmVkdWNlKChwLCBjLCBpKSA9PiBwICsgKGMgLyBNYXRoLnBvdygxMCwgaSAqIDIpKSksXG59KTtcbkRleGllLm1heEtleSA9IGdldE1heEtleShEZXhpZS5kZXBlbmRlbmNpZXMuSURCS2V5UmFuZ2UpO1xuXG5pZiAodHlwZW9mIGRpc3BhdGNoRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgdXBkYXRlZFBhcnRzID0+IHtcbiAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgICAgICAgIGxldCBldmVudDtcbiAgICAgICAgICAgIGlmIChpc0lFT3JFZGdlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCB0cnVlLCB0cnVlLCB1cGRhdGVkUGFydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDogdXBkYXRlZFBhcnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB0cnVlO1xuICAgICAgICAgICAgZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCAoeyBkZXRhaWwgfSkgPT4ge1xuICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgcHJvcGFnYXRlTG9jYWxseShkZXRhaWwpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVMb2NhbGx5KHVwZGF0ZVBhcnRzKSB7XG4gICAgbGV0IHdhc01lID0gcHJvcGFnYXRpbmdMb2NhbGx5O1xuICAgIHRyeSB7XG4gICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHRydWU7XG4gICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKHVwZGF0ZVBhcnRzKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHdhc01lO1xuICAgIH1cbn1cbmxldCBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcblxuaWYgKHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FKTtcbiAgICBpZiAodHlwZW9mIGJjLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGJjLnVucmVmKCk7XG4gICAgfVxuICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgKGNoYW5nZWRQYXJ0cykgPT4ge1xuICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgYmMucG9zdE1lc3NhZ2UoY2hhbmdlZFBhcnRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGJjLm9ubWVzc2FnZSA9IChldikgPT4ge1xuICAgICAgICBpZiAoZXYuZGF0YSlcbiAgICAgICAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoZXYuZGF0YSk7XG4gICAgfTtcbn1cbmVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgKGNoYW5nZWRQYXJ0cykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnOiBNYXRoLnJhbmRvbSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFBhcnRzLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZlsnY2xpZW50cyddID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBbLi4uc2VsZlsnY2xpZW50cyddLm1hdGNoQWxsKHsgaW5jbHVkZVVuY29udHJvbGxlZDogdHJ1ZSB9KV0uZm9yRWFjaCgoY2xpZW50KSA9PiBjbGllbnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFBhcnRzLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoZGF0YS5jaGFuZ2VkUGFydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3dDb250YWluZXIgPSBzZWxmLmRvY3VtZW50ICYmIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyO1xuICAgIGlmIChzd0NvbnRhaW5lcikge1xuICAgICAgICBzd0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgcHJvcGFnYXRlTWVzc2FnZUxvY2FsbHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZU1lc3NhZ2VMb2NhbGx5KHsgZGF0YSB9KSB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS50eXBlID09PSBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUpIHtcbiAgICAgICAgcHJvcGFnYXRlTG9jYWxseShkYXRhLmNoYW5nZWRQYXJ0cyk7XG4gICAgfVxufVxuXG5EZXhpZVByb21pc2UucmVqZWN0aW9uTWFwcGVyID0gbWFwRXJyb3I7XG5zZXREZWJ1ZyhkZWJ1ZywgZGV4aWVTdGFja0ZyYW1lRmlsdGVyKTtcblxuZXhwb3J0IHsgRGV4aWUkMSBhcyBEZXhpZSwgUmFuZ2VTZXQsIERleGllJDEgYXMgZGVmYXVsdCwgbGl2ZVF1ZXJ5LCBtZXJnZVJhbmdlcywgcmFuZ2VzT3ZlcmxhcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV4aWUubWpzLm1hcFxuIl0sIm5hbWVzIjpbIl9nbG9iYWwiLCJnbG9iYWxUaGlzIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImtleXMiLCJPYmplY3QiLCJpc0FycmF5IiwiQXJyYXkiLCJQcm9taXNlIiwiZXh0ZW5kIiwib2JqIiwiZXh0ZW5zaW9uIiwiZm9yRWFjaCIsImtleSIsImdldFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJfaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJoYXNPd24iLCJwcm9wIiwiY2FsbCIsInByb3BzIiwicHJvdG8iLCJSZWZsZWN0Iiwib3duS2V5cyIsInNldFByb3AiLCJkZWZpbmVQcm9wZXJ0eSIsImZ1bmN0aW9uT3JHZXRTZXQiLCJvcHRpb25zIiwiZ2V0Iiwic2V0IiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJ3cml0YWJsZSIsImRlcml2ZSIsIkNoaWxkIiwiZnJvbSIsIlBhcmVudCIsInByb3RvdHlwZSIsImNyZWF0ZSIsImJpbmQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRQcm9wZXJ0eURlc2NyaXB0b3IiLCJwZCIsIl9zbGljZSIsInNsaWNlIiwiYXJncyIsInN0YXJ0IiwiZW5kIiwib3ZlcnJpZGUiLCJvcmlnRnVuYyIsIm92ZXJyaWRlZEZhY3RvcnkiLCJhc3NlcnQiLCJiIiwiRXJyb3IiLCJhc2FwJDEiLCJmbiIsInNldEltbWVkaWF0ZSIsInNldFRpbWVvdXQiLCJhcnJheVRvT2JqZWN0IiwiYXJyYXkiLCJleHRyYWN0b3IiLCJyZWR1Y2UiLCJyZXN1bHQiLCJpdGVtIiwiaSIsIm5hbWVBbmRWYWx1ZSIsInRyeUNhdGNoIiwib25lcnJvciIsImFwcGx5IiwiZXgiLCJnZXRCeUtleVBhdGgiLCJrZXlQYXRoIiwicnYiLCJsIiwibGVuZ3RoIiwidmFsIiwicHVzaCIsInBlcmlvZCIsImluZGV4T2YiLCJpbm5lck9iaiIsInN1YnN0ciIsInVuZGVmaW5lZCIsInNldEJ5S2V5UGF0aCIsImlzRnJvemVuIiwiY3VycmVudEtleVBhdGgiLCJyZW1haW5pbmdLZXlQYXRoIiwiaXNOYU4iLCJwYXJzZUludCIsInNwbGljZSIsImRlbEJ5S2V5UGF0aCIsIm1hcCIsImtwIiwic2hhbGxvd0Nsb25lIiwibSIsImNvbmNhdCIsImZsYXR0ZW4iLCJhIiwiaW50cmluc2ljVHlwZU5hbWVzIiwic3BsaXQiLCJudW0iLCJ0IiwiZmlsdGVyIiwiaW50cmluc2ljVHlwZXMiLCJ4IiwiY2lyY3VsYXJSZWZzIiwiZGVlcENsb25lIiwiYW55IiwiV2Vha01hcCIsImlubmVyRGVlcENsb25lIiwiY29uc3RydWN0b3IiLCJ0b1N0cmluZyIsInRvU3RyaW5nVGFnIiwibyIsIml0ZXJhdG9yU3ltYm9sIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJnZXRJdGVyYXRvck9mIiwiTk9fQ0hBUl9BUlJBWSIsImdldEFycmF5T2YiLCJhcnJheUxpa2UiLCJpdCIsImFyZ3VtZW50cyIsIm5leHQiLCJkb25lIiwiaXNBc3luY0Z1bmN0aW9uIiwiZGVidWciLCJsb2NhdGlvbiIsInRlc3QiLCJocmVmIiwic2V0RGVidWciLCJsaWJyYXJ5RmlsdGVyIiwiTkVFRFNfVEhST1dfRk9SX1NUQUNLIiwic3RhY2siLCJnZXRFcnJvcldpdGhTdGFjayIsImUiLCJwcmV0dHlTdGFjayIsImV4Y2VwdGlvbiIsIm51bUlnbm9yZWRGcmFtZXMiLCJuYW1lIiwibWVzc2FnZSIsImZyYW1lIiwiam9pbiIsImRleGllRXJyb3JOYW1lcyIsImlkYkRvbUVycm9yTmFtZXMiLCJlcnJvckxpc3QiLCJkZWZhdWx0VGV4dHMiLCJWZXJzaW9uQ2hhbmdlZCIsIkRhdGFiYXNlQ2xvc2VkIiwiQWJvcnQiLCJUcmFuc2FjdGlvbkluYWN0aXZlIiwiTWlzc2luZ0FQSSIsIkRleGllRXJyb3IiLCJtc2ciLCJfZSIsIl9zdGFjayIsImdldE11bHRpRXJyb3JNZXNzYWdlIiwiZmFpbHVyZXMiLCJ2IiwicyIsIk1vZGlmeUVycm9yIiwic3VjY2Vzc0NvdW50IiwiZmFpbGVkS2V5cyIsIkJ1bGtFcnJvciIsInBvcyIsImZhaWx1cmVzQnlQb3MiLCJlcnJuYW1lcyIsIkJhc2VFeGNlcHRpb24iLCJleGNlcHRpb25zIiwiZnVsbE5hbWUiLCJtc2dPcklubmVyIiwiaW5uZXIiLCJTeW50YXgiLCJTeW50YXhFcnJvciIsIlR5cGUiLCJUeXBlRXJyb3IiLCJSYW5nZSIsIlJhbmdlRXJyb3IiLCJleGNlcHRpb25NYXAiLCJtYXBFcnJvciIsImRvbUVycm9yIiwiZnVsbE5hbWVFeGNlcHRpb25zIiwibm9wIiwibWlycm9yIiwicHVyZUZ1bmN0aW9uQ2hhaW4iLCJmMSIsImYyIiwiY2FsbEJvdGgiLCJvbjEiLCJvbjIiLCJob29rQ3JlYXRpbmdDaGFpbiIsInJlcyIsIm9uc3VjY2VzcyIsInJlczIiLCJob29rRGVsZXRpbmdDaGFpbiIsImhvb2tVcGRhdGluZ0NoYWluIiwibW9kaWZpY2F0aW9ucyIsInJldmVyc2VTdG9wcGFibGVFdmVudENoYWluIiwicHJvbWlzYWJsZUNoYWluIiwidGhlbiIsInRoaXoiLCJJTlRFUk5BTCIsIkxPTkdfU1RBQ0tTX0NMSVBfTElNSVQiLCJNQVhfTE9OR19TVEFDS1MiLCJaT05FX0VDSE9fTElNSVQiLCJyZXNvbHZlZE5hdGl2ZVByb21pc2UiLCJuYXRpdmVQcm9taXNlUHJvdG8iLCJyZXNvbHZlZEdsb2JhbFByb21pc2UiLCJnbG9iYWxQIiwicmVzb2x2ZSIsImNyeXB0byIsInN1YnRsZSIsIm5hdGl2ZVAiLCJkaWdlc3QiLCJVaW50OEFycmF5IiwibmF0aXZlUHJvbWlzZVRoZW4iLCJOYXRpdmVQcm9taXNlIiwicGF0Y2hHbG9iYWxQcm9taXNlIiwic3RhY2tfYmVpbmdfZ2VuZXJhdGVkIiwic2NoZWR1bGVQaHlzaWNhbFRpY2siLCJwaHlzaWNhbFRpY2siLCJNdXRhdGlvbk9ic2VydmVyIiwiaGlkZGVuRGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJzZXRBdHRyaWJ1dGUiLCJhc2FwIiwiY2FsbGJhY2siLCJtaWNyb3RpY2tRdWV1ZSIsIm5lZWRzTmV3UGh5c2ljYWxUaWNrIiwiaXNPdXRzaWRlTWljcm9UaWNrIiwidW5oYW5kbGVkRXJyb3JzIiwicmVqZWN0aW5nRXJyb3JzIiwiY3VycmVudEZ1bGZpbGxlciIsInJlamVjdGlvbk1hcHBlciIsImdsb2JhbFBTRCIsImlkIiwicmVmIiwidW5oYW5kbGVkcyIsIm9udW5oYW5kbGVkIiwiZ2xvYmFsRXJyb3IiLCJwZ3AiLCJlbnYiLCJmaW5hbGl6ZSIsInVoIiwiUFNEIiwibnVtU2NoZWR1bGVkQ2FsbHMiLCJ0aWNrRmluYWxpemVycyIsIkRleGllUHJvbWlzZSIsIl9saXN0ZW5lcnMiLCJvbnVuY2F0Y2hlZCIsIl9saWIiLCJwc2QiLCJfUFNEIiwiX3N0YWNrSG9sZGVyIiwiX3ByZXYiLCJfbnVtUHJldiIsIl9zdGF0ZSIsIl92YWx1ZSIsImhhbmRsZVJlamVjdGlvbiIsImV4ZWN1dGVQcm9taXNlVGFzayIsInRoZW5Qcm9wIiwibWljcm9UYXNrSWQiLCJ0b3RhbEVjaG9lcyIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInBvc3NpYmxlQXdhaXQiLCJjbGVhbnVwIiwiZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMiLCJyZWplY3QiLCJwcm9wYWdhdGVUb0xpc3RlbmVyIiwiTGlzdGVuZXIiLCJuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwIiwibGlua1RvUHJldmlvdXNQcm9taXNlIiwiX3RoZW4iLCJjYXRjaCIsInR5cGUiLCJoYW5kbGVyIiwiZXJyIiwiUHJvbWlzZVJlamVjdCIsImZpbmFsbHkiLCJvbkZpbmFsbHkiLCJzdGFja3MiLCJnZXRTdGFjayIsInRpbWVvdXQiLCJtcyIsIkluZmluaXR5IiwiaGFuZGxlIiwiVGltZW91dCIsImNsZWFyVGltZW91dCIsInNuYXBTaG90Iiwiem9uZSIsImFsbCIsInZhbHVlcyIsIm9uUG9zc2libGVQYXJhbGxlbGxBc3luYyIsInJlbWFpbmluZyIsInJhY2UiLCJuZXdQU0QiLCJuZXdTY29wZSIsInVzZVBTRCIsInNjaGVkdWxlciIsImZvbGxvdyIsInpvbmVQcm9wcyIsInJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2siLCJhbGxTZXR0bGVkIiwicG9zc2libGVQcm9taXNlcyIsInJlc3VsdHMiLCJwIiwic3RhdHVzIiwicmVhc29uIiwiQWdncmVnYXRlRXJyb3IiLCJmYWlsdXJlIiwicHJvbWlzZSIsInNob3VsZEV4ZWN1dGVUaWNrIiwiYmVnaW5NaWNyb1RpY2tTY29wZSIsInByb3BhZ2F0ZUFsbExpc3RlbmVycyIsImVuZE1pY3JvVGlja1Njb3BlIiwiX3Byb21pc2UiLCJvcmlnUHJvcCIsImFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IiLCJsaXN0ZW5lcnMiLCJsZW4iLCJmaW5hbGl6ZVBoeXNpY2FsVGljayIsImxpc3RlbmVyIiwiY2IiLCJjYWxsTGlzdGVuZXIiLCJyZXQiLCJtYXJrRXJyb3JBc0hhbmRsZWQiLCJsaW1pdCIsImVycm9yTmFtZSIsInByZXYiLCJudW1QcmV2Iiwid2FzUm9vdEV4ZWMiLCJjYWxsYmFja3MiLCJ1bmhhbmRsZWRFcnJzIiwiZmluYWxpemVycyIsImZpbmFsaXplciIsInNvbWUiLCJ3cmFwIiwiZXJyb3JDYXRjaGVyIiwib3V0ZXJTY29wZSIsInN3aXRjaFRvWm9uZSIsInRhc2siLCJhd2FpdHMiLCJlY2hvZXMiLCJ0YXNrQ291bnRlciIsInpvbmVTdGFjayIsInpvbmVFY2hvZXMiLCJ6b25lX2lkX2NvdW50ZXIiLCJhMSIsImEyIiwicGFyZW50IiwiZ2xvYmFsRW52IiwiUHJvbWlzZVByb3AiLCJudGhlbiIsImdldFBhdGNoZWRQcm9taXNlVGhlbiIsImd0aGVuIiwiaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMiLCJwb3NzaWJsZVByb21pc2UiLCJyZWplY3Rpb24iLCJ6b25lRW50ZXJFY2hvIiwidGFyZ2V0Wm9uZSIsInpvbmVMZWF2ZUVjaG8iLCJwb3AiLCJiRW50ZXJpbmdab25lIiwiY3VycmVudFpvbmUiLCJlbnF1ZXVlTmF0aXZlTWljcm9UYXNrIiwiR2xvYmFsUHJvbWlzZSIsInRhcmdldEVudiIsImEzIiwiam9iIiwib3V0ZXJab25lIiwib3JpZ1RoZW4iLCJvblJlc29sdmVkIiwiVU5IQU5ETEVEUkVKRUNUSU9OIiwiZXZlbnQiLCJldmVudERhdGEiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiZGlzcGF0Y2hFdmVudCIsIlByb21pc2VSZWplY3Rpb25FdmVudCIsIm9udW5oYW5kbGVkcmVqZWN0aW9uIiwiXyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjb25zb2xlIiwid2FybiIsInRlbXBUcmFuc2FjdGlvbiIsImRiIiwibW9kZSIsInN0b3JlTmFtZXMiLCJpZGJkYiIsIm9wZW5Db21wbGV0ZSIsImxldFRocm91Z2giLCJfdmlwIiwiZGJPcGVuRXJyb3IiLCJpc0JlaW5nT3BlbmVkIiwiX29wdGlvbnMiLCJhdXRvT3BlbiIsIm9wZW4iLCJkYlJlYWR5UHJvbWlzZSIsInRyYW5zIiwiX2NyZWF0ZVRyYW5zYWN0aW9uIiwiX2RiU2NoZW1hIiwiUFIxMzk4X21heExvb3AiLCJJbnZhbGlkU3RhdGUiLCJpc09wZW4iLCJfY2xvc2UiLCJfY29tcGxldGlvbiIsIkRFWElFX1ZFUlNJT04iLCJtYXhTdHJpbmciLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJtaW5LZXkiLCJJTlZBTElEX0tFWV9BUkdVTUVOVCIsIlNUUklOR19FWFBFQ1RFRCIsImNvbm5lY3Rpb25zIiwiaXNJRU9yRWRnZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImhhc0lFRGVsZXRlT2JqZWN0U3RvcmVCdWciLCJoYW5nc09uRGVsZXRlTGFyZ2VLZXlSYW5nZSIsImRleGllU3RhY2tGcmFtZUZpbHRlciIsIkRCTkFNRVNfREIiLCJSRUFET05MWSIsIlJFQURXUklURSIsImNvbWJpbmUiLCJmaWx0ZXIxIiwiZmlsdGVyMiIsIkFueVJhbmdlIiwibG93ZXIiLCJsb3dlck9wZW4iLCJ1cHBlciIsInVwcGVyT3BlbiIsIndvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5IiwiVGFibGUiLCJfdHJhbnMiLCJ3cml0ZUxvY2tlZCIsIl90eCIsInRhYmxlTmFtZSIsImNoZWNrVGFibGVJblRyYW5zYWN0aW9uIiwic2NoZW1hIiwiTm90Rm91bmQiLCJpZGJ0cmFucyIsInRyYW5zbGVzcyIsImtleU9yQ3JpdCIsIndoZXJlIiwiZmlyc3QiLCJjb3JlIiwiaG9vayIsInJlYWRpbmciLCJmaXJlIiwiaW5kZXhPckNyaXQiLCJXaGVyZUNsYXVzZSIsImtleVBhdGhzIiwiZXF1YWxzIiwiY29tcG91bmRJbmRleCIsImluZGV4ZXMiLCJwcmltS2V5IiwiaXgiLCJjb21wb3VuZCIsImV2ZXJ5Iiwic29ydCIsIl9tYXhLZXkiLCJrZXlQYXRoc0luVmFsaWRPcmRlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJpZHhCeU5hbWUiLCJpZGIiLCJfZGVwcyIsImluZGV4ZWREQiIsImNtcCIsImlkeCIsImZpbHRlckZ1bmN0aW9uIiwicHJldkluZGV4IiwicHJldkZpbHRlckZuIiwiaW5kZXgiLCJtdWx0aSIsInRvQ29sbGVjdGlvbiIsImFuZCIsImNvdW50IiwidGhlblNob3J0Y3V0Iiwib2Zmc2V0IiwibnVtUm93cyIsImVhY2giLCJ0b0FycmF5IiwiQ29sbGVjdGlvbiIsIm9yZGVyQnkiLCJyZXZlcnNlIiwibWFwVG9DbGFzcyIsIm1hcHBlZENsYXNzIiwicmVhZEhvb2siLCJ1bnN1YnNjcmliZSIsImRlZmluZUNsYXNzIiwiQ2xhc3MiLCJjb250ZW50IiwiYWRkIiwiYXV0byIsIm9ialRvQWRkIiwibXV0YXRlIiwibnVtRmFpbHVyZXMiLCJsYXN0UmVzdWx0IiwidXBkYXRlIiwia2V5T3JPYmplY3QiLCJJbnZhbGlkQXJndW1lbnQiLCJfYSIsIm1vZGlmeSIsInB1dCIsImRlbGV0ZSIsImNsZWFyIiwicmFuZ2UiLCJidWxrR2V0IiwiZ2V0TWFueSIsImJ1bGtBZGQiLCJvYmplY3RzIiwia2V5c09yT3B0aW9ucyIsIndhbnRSZXN1bHRzIiwiYWxsS2V5cyIsIm51bU9iamVjdHMiLCJvYmplY3RzVG9BZGQiLCJidWxrUHV0Iiwib2JqZWN0c1RvUHV0IiwiYnVsa0RlbGV0ZSIsIm51bUtleXMiLCJFdmVudHMiLCJjdHgiLCJldnMiLCJldmVudE5hbWUiLCJzdWJzY3JpYmVyIiwic3Vic2NyaWJlIiwiYWRkRXZlbnRUeXBlIiwiY2hhaW5GdW5jdGlvbiIsImRlZmF1bHRGdW5jdGlvbiIsImFkZENvbmZpZ3VyZWRFdmVudHMiLCJjb250ZXh0Iiwic3Vic2NyaWJlcnMiLCJjZmciLCJmaXJlRXZlbnQiLCJtYWtlQ2xhc3NDb25zdHJ1Y3RvciIsImNyZWF0ZVRhYmxlQ29uc3RydWN0b3IiLCJ0YWJsZVNjaGVtYSIsIl9hbGxUYWJsZXMiLCJpc1BsYWluS2V5UmFuZ2UiLCJpZ25vcmVMaW1pdEZpbHRlciIsImFsZ29yaXRobSIsIm9yIiwianVzdExpbWl0IiwicmVwbGF5RmlsdGVyIiwiYWRkRmlsdGVyIiwiYWRkUmVwbGF5RmlsdGVyIiwiZmFjdG9yeSIsImlzTGltaXRGaWx0ZXIiLCJjdXJyIiwiYWRkTWF0Y2hGaWx0ZXIiLCJpc01hdGNoIiwiZ2V0SW5kZXhPclN0b3JlIiwiY29yZVNjaGVtYSIsImlzUHJpbUtleSIsInByaW1hcnlLZXkiLCJnZXRJbmRleEJ5S2V5UGF0aCIsIlNjaGVtYSIsIm9wZW5DdXJzb3IiLCJjb3JlVGFibGUiLCJrZXlzT25seSIsImRpciIsInVuaXF1ZSIsInF1ZXJ5IiwiaXRlciIsImNvcmVUcmFucyIsIml0ZXJhdGUiLCJ2YWx1ZU1hcHBlciIsInVuaW9uIiwiY3Vyc29yIiwiYWR2YW5jZSIsInN0b3AiLCJmYWlsIiwiX2l0ZXJhdGUiLCJjdXJzb3JQcm9taXNlIiwibWFwcGVkRm4iLCJjIiwid3JhcHBlZEZuIiwiY29udGludWUiLCJhZHZhbmNlciIsInRhIiwidGIiLCJOYU4iLCJjb21wYXJlVWludDhBcnJheXMiLCJnZXRVaW50OEFycmF5IiwiY29tcGFyZUFycmF5cyIsImFsIiwiYmwiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsInRzVGFnIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJfcmVhZCIsIl9jdHgiLCJlcnJvciIsInRhYmxlIiwiX3dyaXRlIiwiX2FkZEFsZ29yaXRobSIsImNsb25lIiwicmF3IiwiTWF0aCIsIm1pbiIsInNvcnRCeSIsInBhcnRzIiwibGFzdFBhcnQiLCJsYXN0SW5kZXgiLCJnZXR2YWwiLCJvcmRlciIsInNvcnRlciIsImFWYWwiLCJiVmFsIiwib2Zmc2V0TGVmdCIsInJvd3NMZWZ0IiwidW50aWwiLCJiSW5jbHVkZVN0b3BFbnRyeSIsImxhc3QiLCJpbmRleE5hbWUiLCJfb25kaXJlY3Rpb25jaGFuZ2UiLCJkZXNjIiwiZWFjaEtleSIsImVhY2hVbmlxdWVLZXkiLCJlYWNoUHJpbWFyeUtleSIsInByaW1hcnlLZXlzIiwidW5pcXVlS2V5cyIsImZpcnN0S2V5IiwibGFzdEtleSIsImRpc3RpbmN0Iiwic3RyS2V5IiwiZm91bmQiLCJjaGFuZ2VzIiwibW9kaWZ5ZXIiLCJhbnl0aGluZ01vZGlmaWVkIiwib3V0Ym91bmQiLCJleHRyYWN0S2V5IiwibW9kaWZ5Q2h1bmtTaXplIiwidG90YWxGYWlsdXJlcyIsImFwcGx5TXV0YXRlUmVzdWx0IiwiZXhwZWN0ZWRDb3VudCIsIm5leHRDaHVuayIsImNhY2hlIiwiYWRkVmFsdWVzIiwicHV0VmFsdWVzIiwicHV0S2V5cyIsImRlbGV0ZUtleXMiLCJvcmlnVmFsdWUiLCJjcml0ZXJpYSIsImRlbGV0ZUNhbGxiYWNrIiwiY2hhbmdlU3BlYyIsImNvcmVSYW5nZSIsImNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3RvciIsIndoZXJlQ2xhdXNlIiwia2V5UmFuZ2VHZW5lcmF0b3IiLCJrZXlSYW5nZSIsIndoZXJlQ3R4IiwicmVhZGluZ0hvb2siLCJzaW1wbGVDb21wYXJlIiwic2ltcGxlQ29tcGFyZVJldmVyc2UiLCJjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSIsIlQiLCJjb2xsZWN0aW9uIiwiZW1wdHlDb2xsZWN0aW9uIiwicmFuZ2VFcXVhbCIsInVwcGVyRmFjdG9yeSIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJsb3dlckZhY3RvcnkiLCJuZXh0Q2FzaW5nIiwibG93ZXJLZXkiLCJ1cHBlck5lZWRsZSIsImxvd2VyTmVlZGxlIiwibGxwIiwibHdyS2V5Q2hhciIsImFkZElnbm9yZUNhc2VBbGdvcml0aG0iLCJtYXRjaCIsIm5lZWRsZXMiLCJzdWZmaXgiLCJjb21wYXJlIiwidXBwZXJOZWVkbGVzIiwibG93ZXJOZWVkbGVzIiwiZGlyZWN0aW9uIiwibmV4dEtleVN1ZmZpeCIsIm5lZWRsZXNMZW4iLCJpbml0RGlyZWN0aW9uIiwibmVlZGxlQm91bmRzIiwibmVlZGxlIiwibmIiLCJjcmVhdGVSYW5nZSIsImZpcnN0UG9zc2libGVOZWVkbGUiLCJsb3dlc3RQb3NzaWJsZUNhc2luZyIsImNhc2luZyIsImJldHdlZW4iLCJpbmNsdWRlTG93ZXIiLCJpbmNsdWRlVXBwZXIiLCJfY21wIiwiYWJvdmUiLCJhYm92ZU9yRXF1YWwiLCJiZWxvdyIsImJlbG93T3JFcXVhbCIsInN0YXJ0c1dpdGgiLCJzdHIiLCJzdGFydHNXaXRoSWdub3JlQ2FzZSIsImVxdWFsc0lnbm9yZUNhc2UiLCJhbnlPZklnbm9yZUNhc2UiLCJzdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlIiwibiIsImFueU9mIiwiX2FzY2VuZGluZyIsIl9kZXNjZW5kaW5nIiwibm90RXF1YWwiLCJpbkFueVJhbmdlIiwiaW5jbHVkZUxvd2VycyIsImluY2x1ZGVVcHBlcnMiLCJub25lT2YiLCJyYW5nZXMiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiX21pbiIsIm1heCIsIl9tYXgiLCJhZGRSYW5nZSIsIm5ld1JhbmdlIiwic29ydERpcmVjdGlvbiIsInJhbmdlU29ydGVyIiwicmFuZ2VQb3MiLCJrZXlJc0JleW9uZEN1cnJlbnRFbnRyeSIsImtleUlzQmVmb3JlQ3VycmVudEVudHJ5Iiwia2V5V2l0aGluQ3VycmVudFJhbmdlIiwiY2hlY2tLZXkiLCJzdGFydHNXaXRoQW55T2YiLCJjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yIiwib3JDb2xsZWN0aW9uIiwiX0lEQktleVJhbmdlIiwiSURCS2V5UmFuZ2UiLCJldmVudFJlamVjdEhhbmRsZXIiLCJwcmV2ZW50RGVmYXVsdCIsInRhcmdldCIsInN0b3BQcm9wYWdhdGlvbiIsIkRFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FIiwiU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FIiwiZ2xvYmFsRXZlbnRzIiwiVHJhbnNhY3Rpb24iLCJfbG9jayIsIl9yZWN1bG9jayIsImxvY2tPd25lckZvciIsIl91bmxvY2siLCJfYmxvY2tlZEZ1bmNzIiwiX2xvY2tlZCIsImZuQW5kUFNEIiwic2hpZnQiLCJPcGVuRmFpbGVkIiwiYWN0aXZlIiwidHJhbnNhY3Rpb24iLCJkdXJhYmlsaXR5IiwiY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IiwiZXYiLCJfcmVqZWN0Iiwib25hYm9ydCIsIm9uIiwib25jb21wbGV0ZSIsIl9yZXNvbHZlIiwic3RvcmFnZW11dGF0ZWQiLCJiV3JpdGVMb2NrIiwiUmVhZE9ubHkiLCJfcm9vdCIsIndhaXRGb3IiLCJwcm9taXNlTGlrZSIsInJvb3QiLCJfd2FpdGluZ0ZvciIsIl93YWl0aW5nUXVldWUiLCJzdG9yZSIsIm9iamVjdFN0b3JlIiwic3BpbiIsIl9zcGluQ291bnQiLCJjdXJyZW50V2FpdFByb21pc2UiLCJhYm9ydCIsIm1lbW9pemVkVGFibGVzIiwiX21lbW9pemVkVGFibGVzIiwidHJhbnNhY3Rpb25Cb3VuZFRhYmxlIiwiY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3RvciIsImRic2NoZW1hIiwiY29tcGxldGUiLCJ3YXNBY3RpdmUiLCJjcmVhdGVJbmRleFNwZWMiLCJzcmMiLCJuYW1lRnJvbUtleVBhdGgiLCJjcmVhdGVUYWJsZVNjaGVtYSIsInNhZmFyaU11bHRpU3RvcmVGaXgiLCJnZXRNYXhLZXkiLCJJZGJLZXlSYW5nZSIsIm9ubHkiLCJnZXRLZXlFeHRyYWN0b3IiLCJnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yIiwiYXJyYXlpZnkiLCJfaWRfY291bnRlciIsImdldEtleVBhdGhBbGlhcyIsImNyZWF0ZURCQ29yZSIsInRtcFRyYW5zIiwiZXh0cmFjdFNjaGVtYSIsInRhYmxlcyIsIm9iamVjdFN0b3JlTmFtZXMiLCJhdXRvSW5jcmVtZW50IiwiaW5kZXhCeUtleVBhdGgiLCJpc1ByaW1hcnlLZXkiLCJpbmRleE5hbWVzIiwibXVsdGlFbnRyeSIsImhhc0dldEFsbCIsIm1ha2VJREJLZXlSYW5nZSIsImlkYlJhbmdlIiwidXBwZXJCb3VuZCIsImxvd2VyQm91bmQiLCJib3VuZCIsImNyZWF0ZURiQ29yZVRhYmxlIiwiaXNBZGRPclB1dCIsInJlcSIsInJlcXMiLCJlcnJvckhhbmRsZXIiLCJhcmdzMSIsImFyZ3MyIiwic291cmNlIiwib3BlbktleUN1cnNvciIsIl9fX2lkIiwiX2N1cnNvckNvbnRpbnVlIiwiX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSIsImNvbnRpbnVlUHJpbWFyeUtleSIsIl9jdXJzb3JBZHZhbmNlIiwiZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZCIsImRvVGhyb3dDdXJzb3JJc1N0b3BwZWQiLCJnb3RPbmUiLCJpdGVyYXRpb25Qcm9taXNlIiwicmVzb2x2ZUl0ZXJhdGlvbiIsInJlamVjdEl0ZXJhdGlvbiIsImd1YXJkZWRDYWxsYmFjayIsInJlcXVlc3QiLCJub25JbmZpbml0TGltaXQiLCJpZGJLZXlSYW5nZSIsImdldEFsbCIsImdldEFsbEtleXMiLCJrZXlDb3VudCIsImNhbGxiYWNrQ291bnQiLCJzdWNjZXNzSGFuZGxlciIsIl9wb3MiLCJ0YWJsZU1hcCIsIk1JTl9LRVkiLCJNQVhfS0VZIiwiY3JlYXRlTWlkZGxld2FyZVN0YWNrIiwic3RhY2tJbXBsIiwibWlkZGxld2FyZXMiLCJkb3duIiwiY3JlYXRlTWlkZGxld2FyZVN0YWNrcyIsImRiY29yZSIsImdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyIsIl9ub3ZpcCIsIl9taWRkbGV3YXJlcyIsInRibCIsInNldEFwaU9uUGxhY2UiLCJvYmpzIiwidGFibGVOYW1lcyIsInByb3BEZXNjIiwiZW51bWVyYWJsZSIsInJlbW92ZVRhYmxlc0FwaSIsImxvd2VyVmVyc2lvbkZpcnN0IiwiX2NmZyIsInZlcnNpb24iLCJydW5VcGdyYWRlcnMiLCJvbGRWZXJzaW9uIiwiaWRiVXBncmFkZVRyYW5zIiwiZ2xvYmFsU2NoZW1hIiwiX3N0b3JlTmFtZXMiLCJyZWplY3RUcmFuc2FjdGlvbiIsImNyZWF0ZVRhYmxlIiwicG9wdWxhdGUiLCJ1cGRhdGVUYWJsZXNBbmRJbmRleGVzIiwicXVldWUiLCJ2ZXJzaW9ucyIsIl92ZXJzaW9ucyIsImJ1aWxkR2xvYmFsU2NoZW1hIiwiYW55Q29udGVudFVwZ3JhZGVySGFzUnVuIiwidmVyc1RvUnVuIiwib2xkU2NoZW1hIiwibmV3U2NoZW1hIiwiYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMiLCJkaWZmIiwiZ2V0U2NoZW1hRGlmZiIsInR1cGxlIiwiY2hhbmdlIiwicmVjcmVhdGUiLCJVcGdyYWRlIiwiYWRkSW5kZXgiLCJkZWxldGVJbmRleCIsImRlbCIsImlkeE5hbWUiLCJjb250ZW50VXBncmFkZSIsInVwZ3JhZGVTY2hlbWEiLCJjb250ZW50VXBncmFkZUlzQXN5bmMiLCJyZXR1cm5WYWx1ZSIsInByb21pc2VGb2xsb3dlZCIsImRlY3JlbWVudG9yIiwiZGVsZXRlUmVtb3ZlZFRhYmxlcyIsInJ1blF1ZXVlIiwiY3JlYXRlTWlzc2luZ1RhYmxlcyIsIm9sZERlZiIsIm5ld0RlZiIsImRlZiIsIm9sZEluZGV4ZXMiLCJuZXdJbmRleGVzIiwib2xkSWR4IiwibmV3SWR4IiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJjb250YWlucyIsInN0b3JlTmFtZSIsImRlbGV0ZU9iamVjdFN0b3JlIiwiY3JlYXRlSW5kZXgiLCJkYlN0b3JlTmFtZXMiLCJqIiwiaWRiaW5kZXgiLCJyZWFkR2xvYmFsU2NoZW1hIiwidmVybm8iLCJ2ZXJpZnlJbnN0YWxsZWRTY2hlbWEiLCJpbnN0YWxsZWRTY2hlbWEiLCJjaCIsIl9oYXNHZXRBbGwiLCJkZXhpZU5hbWUiLCJpbmRleFNwZWMiLCJXb3JrZXJHbG9iYWxTY29wZSIsInBhcnNlSW5kZXhTeW50YXgiLCJwcmltS2V5QW5kSW5kZXhlcyIsImluZGV4TnVtIiwidHJpbSIsInJlcGxhY2UiLCJWZXJzaW9uIiwiX3BhcnNlU3RvcmVzU3BlYyIsInN0b3JlcyIsIm91dFNjaGVtYSIsInN0b3Jlc1NvdXJjZSIsInN0b3Jlc1NwZWMiLCJ1cGdyYWRlIiwidXBncmFkZUZ1bmN0aW9uIiwiY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yIiwidmVyc2lvbk51bWJlciIsImdldERiTmFtZXNUYWJsZSIsImRiTmFtZXNEQiIsIkRleGllJDEiLCJhZGRvbnMiLCJkYm5hbWVzIiwiaGFzRGF0YWJhc2VzTmF0aXZlIiwiZGF0YWJhc2VzIiwiZ2V0RGF0YWJhc2VOYW1lcyIsImluZm9zIiwiaW5mbyIsIl9vbkRhdGFiYXNlQ3JlYXRlZCIsIl9vbkRhdGFiYXNlRGVsZXRlZCIsInZpcCIsImlkYlJlYWR5IiwiaXNTYWZhcmkiLCJ1c2VyQWdlbnREYXRhIiwiaW50ZXJ2YWxJZCIsInRyeUlkYiIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImRleGllT3BlbiIsInN0YXRlIiwib3BlbkNhbmNlbGxlciIsInRocm93SWZDYW5jZWxsZWQiLCJyZXNvbHZlRGJSZWFkeSIsImRiUmVhZHlSZXNvbHZlIiwidXBncmFkZVRyYW5zYWN0aW9uIiwid2FzQ3JlYXRlZCIsInRyeU9wZW5EQiIsImRiTmFtZSIsImF1dG9TY2hlbWEiLCJyb3VuZCIsIm9uYmxvY2tlZCIsIl9maXJlT25CbG9ja2VkIiwib251cGdyYWRlbmVlZGVkIiwiYWxsb3dFbXB0eURCIiwiY2xvc2UiLCJkZWxyZXEiLCJkZWxldGVEYXRhYmFzZSIsIk5vU3VjaERhdGFiYXNlIiwib2xkVmVyIiwicG93Iiwib252ZXJzaW9uY2hhbmdlIiwidmNGaXJlZCIsIm9uY2xvc2UiLCJvblJlYWR5QmVpbmdGaXJlZCIsInJlYWR5IiwiZmlyZVJlbWFpbmRlcnMiLCJyZW1haW5kZXJzIiwiYXdhaXRJdGVyYXRvciIsImNhbGxOZXh0IiwiZG9UaHJvdyIsInRocm93Iiwib25TdWNjZXNzIiwic3RlcCIsIm9uRXJyb3IiLCJnZXROZXh0IiwiZXh0cmFjdFRyYW5zYWN0aW9uQXJncyIsIl90YWJsZUFyZ3NfIiwic2NvcGVGdW5jIiwiZW50ZXJUcmFuc2FjdGlvblNjb3BlIiwicGFyZW50VHJhbnNhY3Rpb24iLCJzY29wZUZ1bmNJc0FzeW5jIiwiUHJlbWF0dXJlQ29tbWl0IiwicGFkIiwiY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZSIsImluZGV4TG9va3VwIiwiYWxsVmlydHVhbEluZGV4ZXMiLCJhZGRWaXJ0dWFsSW5kZXhlcyIsImtleVRhaWwiLCJsb3dMZXZlbEluZGV4Iiwia2V5UGF0aEFsaWFzIiwiaW5kZXhMaXN0Iiwia2V5TGVuZ3RoIiwiaXNWaXJ0dWFsIiwidmlydHVhbEluZGV4IiwidmlydHVhbEtleVBhdGgiLCJmaW5kQmVzdEluZGV4IiwidHJhbnNsYXRlUmFuZ2UiLCJ0cmFuc2xhdGVSZXF1ZXN0IiwiY3JlYXRlVmlydHVhbEN1cnNvciIsIl9jb250aW51ZSIsInZpcnR1YWxDdXJzb3IiLCJ2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlIiwibGV2ZWwiLCJnZXRPYmplY3REaWZmIiwicHJmeCIsImFwIiwiYnAiLCJhcFR5cGVOYW1lIiwiYnBUeXBlTmFtZSIsImdldEVmZmVjdGl2ZUtleXMiLCJob29rc01pZGRsZXdhcmUiLCJkb3duQ29yZSIsImRvd25UYWJsZSIsInRhYmxlTWlkZGxld2FyZSIsImR4VHJhbnMiLCJkZWxldGluZyIsImNyZWF0aW5nIiwidXBkYXRpbmciLCJhZGRQdXRPckRlbGV0ZSIsImRlbGV0ZVJhbmdlIiwiZ2V0RXhpc3RpbmdWYWx1ZXMiLCJleGlzdGluZ1ZhbHVlcyIsImNvbnRleHRzIiwiZXhpc3RpbmdWYWx1ZSIsImdlbmVyYXRlZFByaW1hcnlLZXkiLCJvYmplY3REaWZmIiwiYWRkaXRpb25hbENoYW5nZXMiLCJyZXF1ZXN0ZWRWYWx1ZSIsImRlbGV0ZU5leHRDaHVuayIsImVmZmVjdGl2ZUtleXMiLCJnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZSIsImNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlIiwiY2FjaGVkUmVzdWx0IiwiaXNFbXB0eVJhbmdlIiwibm9kZSIsIlJhbmdlU2V0IiwiZnJvbU9yVHJlZSIsInRvIiwiZCIsInJhbmdlU2V0IiwibWVyZ2VSYW5nZXMiLCJhZGRLZXkiLCJhZGRLZXlzIiwiZ2V0UmFuZ2VTZXRJdGVyYXRvciIsImxlZnQiLCJyaWdodCIsInIiLCJyZWJhbGFuY2UiLCJyaWdodFdhc0N1dE9mZiIsIm5ld1NldCIsIl9hZGRSYW5nZVNldCIsInJhbmdlc092ZXJsYXAiLCJyYW5nZVNldDEiLCJyYW5nZVNldDIiLCJpMSIsIm5leHRSZXN1bHQxIiwiaTIiLCJuZXh0UmVzdWx0MiIsImtleVByb3ZpZGVkIiwidXAiLCJfYiIsInJvb3RDbG9uZSIsIm9sZFJvb3RSaWdodCIsImNvbXB1dGVEZXB0aCIsIm9ic2VydmFiaWxpdHlNaWRkbGV3YXJlIiwiRlVMTF9SQU5HRSIsInRhYmxlQ2xvbmUiLCJtdXRhdGVkUGFydHMiLCJnZXRSYW5nZVNldCIsInBhcnQiLCJwa1JhbmdlU2V0IiwiZGVsc1JhbmdlU2V0IiwibmV3T2JqcyIsIm9sZENhY2hlIiwib2xkT2JqcyIsInRyYWNrQWZmZWN0ZWRJbmRleGVzIiwiZ2V0UmFuZ2UiLCJyZWFkU3Vic2NyaWJlcnMiLCJtZXRob2QiLCJzdWJzY3IiLCJxdWVyaWVkSW5kZXgiLCJxdWVyaWVkUmFuZ2VzIiwia2V5c1Byb21pc2UiLCJyZXN1bHRpbmdLZXlzIiwicEtleXMiLCJ3YW50VmFsdWVzIiwicGtleSIsImFkZEFmZmVjdGVkSW5kZXgiLCJhZGRLZXlPcktleXMiLCJvbGRLZXkiLCJuZXdLZXkiLCJkZXBzIiwiZGVwZW5kZW5jaWVzIiwiY2FuY2VsT3BlbiIsImJTdGlja3kiLCJuZXdWZXJzaW9uIiwidXNlIiwiYWRkb24iLCJ2ZXJzaW9uSW5zdGFuY2UiLCJfd2hlblJlYWR5IiwidW51c2UiLCJtdyIsImhhc0FyZ3VtZW50cyIsImRvRGVsZXRlIiwiYmFja2VuZERCIiwiaGFzQmVlbkNsb3NlZCIsImhhc0ZhaWxlZCIsImR5bmFtaWNhbGx5T3BlbmVkIiwiX3RyYW5zYWN0aW9uIiwib25seUlmQ29tcGF0aWJsZSIsImlkYk1vZGUiLCJTdWJUcmFuc2FjdGlvbiIsImVudGVyVHJhbnNhY3Rpb24iLCJJbnZhbGlkVGFibGUiLCJzeW1ib2xPYnNlcnZhYmxlIiwib2JzZXJ2YWJsZSIsIk9ic2VydmFibGUiLCJfc3Vic2NyaWJlIiwiZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCIsImxpdmVRdWVyeSIsInF1ZXJpZXIiLCJoYXNWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsIm9ic2VydmVyIiwiZXhlY3V0ZSIsImV4ZWMiLCJjbG9zZWQiLCJhY2N1bU11dHMiLCJjdXJyZW50T2JzIiwic3Vic2NyaXB0aW9uIiwibXV0YXRpb25MaXN0ZW5lciIsInF1ZXJ5aW5nIiwic3RhcnRlZExpc3RlbmluZyIsInNob3VsZE5vdGlmeSIsImRvUXVlcnkiLCJnZXRWYWx1ZSIsImRvbURlcHMiLCJtb3pJbmRleGVkREIiLCJ3ZWJraXRJbmRleGVkREIiLCJtc0luZGV4ZWREQiIsIndlYmtpdElEQktleVJhbmdlIiwiRGV4aWUiLCJkYXRhYmFzZU5hbWUiLCJleGlzdHMiLCJpZ25vcmVUcmFuc2FjdGlvbiIsImFzeW5jIiwiZ2VuZXJhdG9yRm4iLCJzcGF3biIsImN1cnJlbnRUcmFuc2FjdGlvbiIsInByb21pc2VPckZ1bmN0aW9uIiwib3B0aW9uYWxUaW1lb3V0Iiwic2VtVmVyIiwibWF4S2V5IiwiYWRkRXZlbnRMaXN0ZW5lciIsInVwZGF0ZWRQYXJ0cyIsInByb3BhZ2F0aW5nTG9jYWxseSIsImluaXRDdXN0b21FdmVudCIsInByb3BhZ2F0ZUxvY2FsbHkiLCJ1cGRhdGVQYXJ0cyIsIndhc01lIiwiQnJvYWRjYXN0Q2hhbm5lbCIsImJjIiwidW5yZWYiLCJjaGFuZ2VkUGFydHMiLCJwb3N0TWVzc2FnZSIsIm9ubWVzc2FnZSIsImRhdGEiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwidHJpZyIsInJhbmRvbSIsIm1hdGNoQWxsIiwiaW5jbHVkZVVuY29udHJvbGxlZCIsImNsaWVudCIsInBhcnNlIiwibmV3VmFsdWUiLCJzd0NvbnRhaW5lciIsInNlcnZpY2VXb3JrZXIiLCJwcm9wYWdhdGVNZXNzYWdlTG9jYWxseSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/dexie@3.2.7/node_modules/dexie/dist/modern/dexie.mjs\n");

/***/ })

};
;